<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【调研学习】星闪无线短距离通信技术</title>
    <link href="/2023/09/22/%E3%80%90%E8%B0%83%E7%A0%94%E5%AD%A6%E4%B9%A0%E3%80%91%E6%98%9F%E9%97%AA%E6%97%A0%E7%BA%BF%E7%9F%AD%E8%B7%9D%E7%A6%BB%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/09/22/%E3%80%90%E8%B0%83%E7%A0%94%E5%AD%A6%E4%B9%A0%E3%80%91%E6%98%9F%E9%97%AA%E6%97%A0%E7%BA%BF%E7%9F%AD%E8%B7%9D%E7%A6%BB%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="星闪-NaerLink"><a href="#星闪-NaerLink" class="headerlink" title="星闪_NaerLink"></a>星闪_NaerLink</h1><p>偶然间看到HUAWEI即将发布的MatePad 平板海报，其中一个“NareLink技术”吸引力我的注意。做过半年的蓝牙开发，对无线技术有一点浅显的理解。很感兴趣，进行一个研的调。</p><p><img src="/img/Untitled.png" alt="NearLink"></p><h2 id="什么是星闪通信技术？"><a href="#什么是星闪通信技术？" class="headerlink" title="什么是星闪通信技术？"></a>什么是星闪通信技术？</h2><h3 id="故事，要从这里讲起"><a href="#故事，要从这里讲起" class="headerlink" title="故事，要从这里讲起"></a>故事，要从这里讲起</h3><p>首先搜索NareLink，可以找到很多媒体讲的故事：</p><ul><li>2019 年，华为因美国制裁被迫退出蓝牙技术联盟。</li><li>荣耀20推出一个“超级蓝牙技术”，称之为“绿牙”。</li><li>2020年9月，由华为牵头组织、会员超过320家企业的星闪联盟SparkLink正式成立，另起炉灶开始了星闪技术的研究和标准制定。</li><li>2023年8月4日华为正式发布<strong>星闪Nearlink。</strong>三年过去，SparkLink改名NearLink，以新的姿态重磅亮相.</li></ul><p>在sparklink官网的测试认证界面，可以找到即将发布的平板：</p><p><img src="/img/Untitled%201.png" alt="SparkLink-MatePad2023"></p><p>什么爽文模板！三年之期已到的既视感</p><p>Wi-Fi和蓝牙几乎是近场无线通信方案的标准答案，高速率高稳定用WiFi，低功耗用蓝牙，而其他诸如zigbee几乎只用于低带宽物联网设备，2.4G用于键鼠办公设备，NFC只适用与一些无源场景。那推出星闪主要目的是什么呢？自主可控，以及“技术更先进、标准更领先”。</p><blockquote><p><a href="http://www.sparklink.org.cn/news_info.php?id=670">【星闪资讯】从人机交互到全屋智能，星闪正掀起一场智能设备互联体验革新潮 - 星闪联盟 (sparklink.org.cn)</a></p><p><strong>“连接”这件事如果做不好，体验上要出大问题。</strong>家中的智能音箱被手机、平板、电视各类设备共用，频繁的连接和断开操作令人苦恼；当我们准备与朋友一同享受游戏电竞的乐趣时，无线键鼠、耳机等外设的高延迟让我们不得不在稳定和轻便之间做二选一；在全屋智能的打造过程中，上百个设备难以同时接入、精准控制，成为我们尝鲜智能家居生活的突出阻碍。造成这些体验不佳现象的底层原因之一，就是以WiFi、蓝牙为代表的传统短距无线通信技术的发展正遇到瓶颈，<strong>传统技术的迭代难以从根本上解决用户痛点。</strong></p><p><strong>星闪在短距无线通信领域与蓝牙、WiFi形成“三足鼎立”之势，让国内市场的玩家有了更先进、更安全的技术选择，</strong>这对于国内科技产业各领域的发展都有关键作用。星闪具有成为中国产业链、供应链的重要基石的潜力。中国通信产业首次将三十多年来从跟随到领跑全球所积累的经验和技术，创新地应用在近距离无线连接领域，星闪是中国科技自立自强的又一重要里程碑。</p></blockquote><h3 id="技术概述"><a href="#技术概述" class="headerlink" title="技术概述"></a>技术概述</h3><p>作为信息传播的最后一环，无线短距通信技术在社会生活的方方面面发挥着巨大的作用。蓝牙和Wi-Fi是目前近场无线通信的主要解决方案，但蓝牙和 Wi-Fi 之间的标准是割裂的，蓝牙主打低功耗，Wi-Fi 追求高速率，各有长处却不能兼容。而“星闪”从架构设计上做成了一个标准多个模式[1]。在2023年华为HDC发布会上，有这样一个动图：<strong>蓝牙和Wi-Fi两个图标变化后融合成了星闪的图标。</strong></p><p>星闪接入层为星闪上层提供<strong>SLB和SLE两种通信接口</strong>。其中，<strong>SLB</strong>采用超短帧、多点同步、双向认证、快速干扰协调、双向认证加密、跨层调度优化等多项技术，<strong>用于支持具有低时延(20us)、高可靠、精同步、高并发和高安全等传输需求的业务场景</strong>。<strong>SLE</strong>采用Polar信道编码提升传输可靠性，减少重传节省功耗，同时支持最大4MHz传输带宽、最大8PSK调制，支持1对多可靠组播，支持4KHz短时延互，安全配对，隐私保护等特性，在尽可能保证传输效率的同时，充分考虑了节能因素，<strong>用于承载具有低功耗诉求的业务场景。</strong>SLB和SLE面向不同业务诉求，提供不同的传输服务，两者相互补充并且根据业务需求进行持续平滑演进[4]。</p><p><img src="/img/Untitled%202.png" alt="SLB&amp;SLE"></p><p>基础服务层由一系列基础功能单元构成，星闪无线通信系统通过调用不同功能单元实现对于上层<br>应用功能以及系统管理维护的支持。基础应用层用于实现各类应用功能，服务于包括智能网联汽车领域在内等不同场景[4]。</p><p>星闪接入层根据实现功能的不同分为管理节点（G节点）和终端节点（T节点），其中G节点为其<br>覆盖下的T节点提供连接管理、资源分配、信息安全等接入层服务。单个G节点以及与其连接的T节点共同组成一个通信域。</p><p>以智能汽车场景为例(如下图所示)，座舱域控制器CDC可以作为G节点，各类车载设备(例如麦克风、扬声器等)作为T节点，共同完成座舱娱乐功能。此时，CDC与车载设备组成了一个通信域[1]。</p><p><img src="/img/Untitled%203.png" alt="connectionInCar"></p><h2 id="星闪的具体性能指标是怎么样的？"><a href="#星闪的具体性能指标是怎么样的？" class="headerlink" title="星闪的具体性能指标是怎么样的？"></a>星闪的具体性能指标是怎么样的？</h2><p>在很多报道中，可以看到下面的介绍：相比“传统无线连接”蓝牙技术，星闪技术功耗降低60%、传输速率提升6倍，具备更低时延、更稳定连接、更强抗干扰能力的特点，覆盖距离提升2倍，连接数提升10倍。</p><p><img src="/img/Untitled%204.png" alt="性能领先"></p><p>听上去是完全碾压，但这个性能指标得量化一下，毕竟蓝牙都5.2了，不同工况下功耗、速度、延时都不一样。</p><h3 id="指标量化"><a href="#指标量化" class="headerlink" title="指标量化"></a>指标量化</h3><p>在最新的白皮书，2022年8月的[2] <strong>星闪无线短距通信技术（SparkLink1.0）产业化推进白皮书</strong>，可以找到：</p><p><img src="/img/Untitled%205.png" alt="SLE参数"></p><p>星闪对标蓝牙的是<strong>SLE模式</strong>，所以这里列出了SLE模式下的性能指标；SLB在速率、时延、多用户方面要更强一些。</p><p>而关于低功耗的指标，四篇白皮书中只有[2]给出了关于功耗的量化指标：</p><p><img src="/img/Untitled%206.png" alt="SLE功耗"></p><p>于此同时，再来看看“被遥遥领先”的蓝牙是什么样的指标呢？</p><p>在蓝牙5.2中，<strong>蓝牙最大的通信速度可以达到2Mbps</strong>[5]，但是这需要使用支持2Mbps速率的物理层变体（PHY），如LE 2M PHY。以及保证设备之间良好的通信质量。目前能支持2Mbps速率的蓝牙硬件较少。</p><p>一篇关于蓝牙5音频协议性能的报道[7]中，给出了关于蓝牙音频比较可信的指标：</p><p> <a href="https://soundsightheadphones.com/guides/bluetooth-5-0-codecs-and-other-bluetooth-formats/">Bluetooth 5.0 and Others: Demystifying aptX HD, Low Latency Standards and MIDI Technology - SoundsightR (soundsightheadphones.com)</a></p><p><img src="/img/Untitled%207.png" alt="BLE_A2DP_Speed"></p><p><img src="/img/Untitled%208.png" alt="BLE_A2DP_Delay"></p><p>蓝牙音频协议A2DP是蓝牙实现音频服务的基础协议，而不同的编解码协议是A2DP其中的一环。详情见[9] <a href="https://yiyangc18.github.io/2022/09/06/%E3%80%90%E8%B0%83%E7%A0%94%E5%AD%A6%E4%B9%A0%E3%80%91%E8%93%9D%E7%89%99-%E9%9F%B3%E9%A2%91-%E5%8D%8F%E8%AE%AE%E6%A0%88/">【调研学习】蓝牙-音频-协议栈 - CHER-YOUNG BLOG (yiyangc18.github.io)</a> 。各个耳机产商会根据自己的需求对A2DP进行魔改，主要的一个环节就是更改编解码协议。例如索尼的LDAC，传输带宽接近A2DP的物理极限，可以播放压缩前24bit&#x2F;96kHz的Hi Res音频，达到了星闪无压缩的带宽。</p><p>在时延方面，好一些的<strong>蓝牙耳机时延都可以做到50ms</strong>，毕竟延时大了是很影响使用体验的。LC3协议是蓝牙5.2最新推出的协议，现在适配的耳机还很少，主要用于语音通话方面。而蓝牙单词回报时长大概10ms，星闪SLE大概是205us，为什么单次数据时延比耳机时延小很多？可以见我之前的文章[8] <a href="https://yiyangc18.github.io/2023/06/04/%E3%80%90IOT%E5%BC%80%E5%8F%91%E3%80%91%E9%9F%B3%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BA%8F%E4%B8%8E%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/">【IOT开发】音频传输中的时序与同步问题 - CHER-YOUNG BLOG (yiyangc18.github.io)</a>。</p><p>就是说，蓝牙音频工程师为了在A2DP那有限的带宽和有限的抗干扰能力下，优化传输音频的码率、时延不知道掉了多少头发，而现在星闪带着更低的延时、更大的带宽、更低的功耗来了。蓝牙音频工程师从某种程度上来失业风险直线增加sigh。</p><p>蓝牙功耗方面，以苹果的airpods pro2为例，电池容量43mAh，歌曲编码为 256-Kbps AAC。音量设置为 50%，并启用了主动降噪功能。在启用空间音频和头部跟踪功能的情况下，聆听时间最长可达 5.5 小时。见：<a href="https://support.apple.com/zh-cn/HT207012">为 AirPods 充电并了解电池续航能力 - 官方 Apple 支持 (中国)</a></p><p>可以计算出功耗为：</p><p>功耗 &#x3D; 电量 &#x2F; 时间 &#x3D; 容量 × 电压 &#x2F; 时间 ~&#x3D; 29mWh&#x2F;h</p><p>我们日常使用耳机更看重的是续航时间，而不是每bit传输能耗。而且传输量增加，功耗也不会线性增加。不过还是需要指出，airpods目前的300Kbps AAC编解码协议在功耗方面本就该低一些。</p><p>所以星闪音频12Mbps吞吐率下的10mW功耗，是产品airpods pro2 功耗的1&#x2F;3。至于每bit能耗，1：120 没什么可比性。</p><p>而在抗干扰能力方面，<strong>最小SINR（信号与干扰加噪声比）为 -3dB</strong>。而关于蓝牙的信号最小信噪比，在搜索引擎、《Bluetooth® Core Specification Version 5.0 nFeature Enhancements》和[5]Bluetooth Core Specification Version 5.2 Feature Overview中并没有给出具体指标。询问GPT：A typical SINR threshold for reliable BLE communication might be around 10-15 dB or even lower, depending on factors like the modulation scheme, coding scheme, and other protocol parameters.</p><p>按照星闪发布会的说法，-3dB+7dB&#x3D;4dB，星闪的抗干扰能力还是很值得期待的。在目前的办公室场景，蓝牙设备非常多，所以蓝牙鼠标、键盘的延时都会变高，所以目前高端一些的键鼠都会支持2.4G连接；期待星闪在办公室场景的测试与应用。</p><p>通信距离指标的意义有限，毕竟大多数使用场景都是很近的，更加关注的是穿墙后还能否稳定链接；而测试都是在开阔低带，最远距离只有一定的参考意义。蓝牙5.0给出的参考覆盖距离是100m，和星闪SLE类似。组网数量方面，蓝牙一般是一个主设备八个从设备（不过实际上连蓝牙键鼠耳机之后体验就会明显下降），而星闪SLE可以支持一个G设备256个T设备，10X没什么毛病，不过多设备组网性能还得看后续实测表现。</p><p>综上所述，可以给出在“蓝牙耳机”场景下量化的性能指标对比</p><table><thead><tr><th>指标</th><th>功耗</th><th>速度</th><th>时延</th><th>抗干扰</th></tr></thead><tbody><tr><td>蓝牙 BLE</td><td>30mW</td><td>1Mbps</td><td>50ms</td><td>10dB SINR</td></tr><tr><td>星闪 SLE</td><td>10mW</td><td>12Mbps</td><td>10ms</td><td>-3dB SINR</td></tr></tbody></table><h2 id="实现低功耗、大带宽、快回报、链接稳、多接入的关键是什么？"><a href="#实现低功耗、大带宽、快回报、链接稳、多接入的关键是什么？" class="headerlink" title="实现低功耗、大带宽、快回报、链接稳、多接入的关键是什么？"></a>实现低功耗、大带宽、快回报、链接稳、多接入的关键是什么？</h2><p>单从指标上来看，星闪可谓是全方面暴打了蓝牙，这听上去就像是“大人，时代变了”。那么它为什么能做到全方位“遥遥领先”呢？</p><p>在一些概述中，对于技术优势的总结：星闪在空口技术上采用了很多类似 5G 的技术，而在技术细节上比蓝牙和 Wi-Fi 更先进。比如星闪在 OFDM 和 CP 设计、时域和频域调度颗粒方面就和 5G 很类似，甚至用上了 5G 的 Polar 编码技术，带来了传输带宽以及抗干扰能力的提升。</p><p><img src="/img/Untitled%209.png" alt="NearLink协议栈"></p><p>星闪系统协议栈分为应用层(OSI 5<del>7层)、网络与传输层(OSI 3</del>4层)和接入层(OSI 1~2层)[1].数据链路层保障数据的可靠传输，数据链路层包含链路控制层和媒体接入层，这和蓝牙的链路控制层非常相似。而物理层实现比特流传输功能，星闪技术要点应该集中在物理层的提升。</p><p>所以，接下来，从物理层的频段与传输波形、帧结构、多域协同、低功耗设计、混合自动重传机制、信道编码与调制几个方面讲解其对性能的提升。</p><h3 id="频段与传输波形"><a href="#频段与传输波形" class="headerlink" title="频段与传输波形"></a>频段与传输波形</h3><p>[1]空口性能白皮书在物理层特性的开头写道：</p><blockquote><p>系统采用CP-OFDM波形传输，物理层时间度量为基本时间单位Ts的倍数。Ts定义为Ts&#x3D;1&#x2F;fs，<br>fs&#x3D;30.72MHz，子载波间隔Δf&#x3D;480kHz。</p></blockquote><p>CP-OFDM波形传输，循环前缀-正交频分复用，真是让人一脸懵逼呢。</p><p>推荐两个讲的比较好的文章：</p><p><a href="https://zhuanlan.zhihu.com/p/438568996">无线通信基础2：深入理解OFDM（含Matlab代码） - hal3515的文章 - 知乎</a></p><p><a href="https://blog.csdn.net/madongchunqiu/article/details/18614233?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%2218614233%22,%22source%22:%22cyy010617%22%7D&fromshare=blogdetail">给“小白”图示讲解OFDM的原理</a></p><blockquote><p>CP-OFDM（Cyclic Prefix Orthogonal Frequency Division Multiplexing）是一种非常常见的无线通信技术，常用于短距离无线通信，例如WiFi和4G&#x2F;5G移动通信。OFDM（正交频分复用）是一种多载波调制技术，它将高速数据流分割为多个较低速的子数据流，然后在多个正交子载波上并行传输。</p></blockquote><blockquote><p>在CP-OFDM系统中，每个OFDM符号都会添加一个循环前缀，这个循环前缀是该符号的一部分，以便在接收端进行解码时可以将其视为一个连续的信号。循环前缀的引入可以消除多径干扰的影响，并且可以使得OFDM符号的末尾与下一个OFDM符号的开始之间有一个平滑的过渡，从而避免了符号间干扰。</p></blockquote><p>简而言之，OFDM是一种在多个正交子载波上并行传输，提高传输速度的技术，而循环前缀是为了提高传输的正确率。</p><p>至于“物理层时间度量为基本时间单位Ts的倍数”，可以这么理解：基带上一个OFDM symbol的发送时间正好发送一个一次谐波的完整波形。</p><p>那么OFDM的优势是什么呢？</p><ol><li><strong>频谱效率高</strong>：OFDM系统将信号分割为多个子载波进行传输，可以有效地提高频谱效率。</li><li><strong>适用于高速数据传输</strong>：由于OFDM系统可以将数据分割为多个子载波进行传输，因此可以实现高速数据传输。</li></ol><blockquote><p>OFDM的子载波间隔最低能达到奈奎斯特带宽，也就是说（在不考虑最旁边的两个子载波情况下），<strong>OFDM达到了理想信道的频带利用率</strong>。</p></blockquote><p>所以白皮书之后关于频段宽度的指标也可以解释了：</p><blockquote><p>星闪系统载波带宽最小为20MHz，向上支持40&#x2F;60&#x2F;80&#x2F;100&#x2F;160&#x2F;320MHz规格的载波带宽，分别由连续多个20MHz的载波聚合方式组成。20MHz载波由连续39个子载波组成，子载波间隔480KHz。</p></blockquote><p><img src="/img/Untitled%2010.png"></p><p>因此正交频分复用相当于<strong>提高频带的利用率</strong>，更准确来说它可以<strong>使频带的利用率达到理论上的最大值</strong>。SLE和SLB都是用CP-OFDM波形传输，但是SLB的频带可以扩展到最大320MHz，而SLE只使用20MHz中的38个信道。OFDM会使用全频带的载波进行传输，一定程度上传输速率与频带宽度成正比。</p><p>那么<strong>“传统”的蓝牙物理层频段与波形是怎么样的呢？</strong></p><p>蓝牙的调制方式: GFSK，高斯频移键控，以及跳频技术FHSS。</p><p>蓝牙工作在2.4G的ISM频段，具体为2400-2483.5MHz，信道带宽1MHz，有79个信道。第一个信道从2.402开始，信道频率为2402+K，K取0-78，共79个信道。在频段前面和后面均有一段的保护带宽，分别为2.4<del>2.4019G和2.481</del>2.4835M。</p><p>蓝牙技术运用了<strong>跳频技术</strong>，主设备按照特定的伪随机码以每秒1600次的频率不断地从一个信道跳到另一个信道，这样可以有效避免信号干扰。</p><p>可以看到，蓝牙通过在快速切换频率来实现数据传输的稳定和安全，而正交频分复直接把各个载波频段都用了起来，传输速率更快理所当然。</p><h3 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h3><p>这一部分首先需要理解一下星闪的帧结构。就数据构成而言，它和蓝牙的数据帧构成很相似，分为：地址、链路层包头、数据。不同的点在于，蓝牙的包头会更冗杂，它包括前导码、MAC地址、PDU、循环冗余校验等。另外，对于递延时高并发场景，星闪支持初步验证后直接透传，就是说不传包头啥的直接传数据。</p><p><img src="/img/Untitled%2011.png"></p><p>星闪系统采用TDD（Time-Division Duplex）方式，超帧格式如下图所示，每超帧包含48个无线帧，每超帧持续时间为1ms，每个无线帧的持续时间为20.833µs。</p><p><img src="/img/Untitled%2012.png"></p><p>就是说传输的每个短帧包都是双工的，并且G和T的配比是可以调节的，中间有符号位和GAP位。</p><p>每个帧更“轻量化”，打包拆包时间更短，帧间隔更短，延时也就更低。</p><p>另一方面，在空口技术测评中由这么一段话：</p><blockquote><p>星闪系统开销信号(如同步信号，广播信息，控制信息，接入信息，物理层ACK反馈信息等)的资源分散到多个无线帧中传输，从而确保了每个无线帧都有资源传输G链路数据包和T链路数据包。</p></blockquote><p>也就是说，类似于蓝牙每个帧头内的PDU数据，会被分散到各个无线帧中，从而减小帧结构。</p><p>那么，为什么蓝牙不采用更低的帧间隔呢？在之前实践中[10]可以看到，更低的传输间隔是提高传输的速度的关键，但间隔短了容易出现帧堵塞情况，即使你在程序中没1ms调用一次蓝牙发送，但实际也只能per10ms发送一次，发送程序要么堵塞等待，要么缓存区溢出。蓝牙协议底层限制了传输间隔，可能出出于低功耗和设备的复杂性考虑。</p><h3 id="同步与多域协同"><a href="#同步与多域协同" class="headerlink" title="同步与多域协同"></a>同步与多域协同</h3><p>星闪使用短帧结构，各设备之间可以快速实现同步。另一方面，星闪系统通过多G节点间时间&#x2F;频率同步降低多域间的干扰。</p><p>同步的过程会采用一个包含同步信号的帧，而各设备间建立同步能有效减少干扰。星闪系统采用OFDM波形，存在多个通信域的场景下，即使不同的通信域使用不同的频点，如果频率差不是子载波间隔SCS&#x3D;480KHz的整数倍或者定时差异超过CP，则会造成子载波间的干扰，特别的，在干扰来自多个通信域的情况。</p><p><strong>这是因为OFDM波形，子载波之间是正交的。如果不同通信域的频率差异不是子载波间隔的整数倍，就会导致子载波之间的正交性受到破坏，从而引入干扰。</strong><br>即使在干扰源比信号源距离接收设备近得多的情况，G节点之间的时频不对齐引入的干扰会显著降低<br>接收信干噪比。<strong>多G节点间时&#x2F;频同步可以显著降低多域间的干扰</strong>，提升多域共存时的频谱效率。所以在多个域连接时，会进行时间同步，下图是一个同步过程示意图，当两个域连接后，他们就会逐渐同步。</p><p><img src="/img/Untitled%2013.png" alt="多域同步"></p><p>这个同步抗干扰在多设备情况下很有用，比FHSS在多设备场景下的抗干扰能力更强。但可以预见的是，这在只有星闪的2.4GHz环境下会比较有用，因为它无法消除2.4GWIFI蓝牙的干扰。</p><h3 id="低功耗设计"><a href="#低功耗设计" class="headerlink" title="低功耗设计"></a>低功耗设计</h3><p>蓝牙4.0一个重要的升级就是支持了BLE，低功耗蓝牙，甚至4.0之后的蓝牙协议都称为BLE而不是BT。</p><p>那么BLE是怎么做到低功耗的？</p><ul><li>传统蓝牙使用16<del>32个频段进行广播，而BLE仅使用3个广播频段；每次广播时的射频开启时间由传统蓝牙的22ms减少为0.6</del>1.2ms</li><li>BLE设计了深度睡眠状态(Duty-Cycle)来替代传统蓝牙的空闲时间</li><li>缩短连接过程；为每个设备发放唯一的MAC地址，优化连接拓扑</li></ul><p>在星闪中是如何设计低功耗模式的呢?</p><p>星闪系统中，G节点可以根据数据的传输特性，通过配置非连续传输(DRX)节省T节点的功耗。T节点工作在DRX状态时，可以根据G节点的配置的接收周期以及每个周期内的持续接收时间，有选择性的在被配置的无线帧&#x2F;超帧上接听数据，节省T节点功耗。<br>G节点在通过高层信令配置T节点非连续传输(DRX)的基础上，还可以通过G链路控制信息动态指示T节点跳过当前的非连续传输周期，进一步节省T节点功耗。</p><p>就是说可以通过降低接受和发送频率来降低功耗。而在连接、广播方面，建立连接的速度比较快，而且也没有看到广播模式。</p><blockquote><p>大量用户稳定连接: 星闪系统中，用于标识T节点的物理层标识(ID)长度为12比特，理论上单<br>个G节点可最多支持2^12&#x3D;4096个T节点。<br> 接入控制方式：星闪系统采用集中式调度，避免了大量节点分布式资源抢占带来的链路冲突，<br>提高了系统吞吐量。星闪系统也支持非竞争接入方式，即可支持大量T节点在相互正交的资<br>源上同时发起群接入，可实现毫秒量级接入，可满足“上电即工作”的场景下的服务需求。</p></blockquote><p>此外，上面是技术文档中关于接入的描述，那么如果把“T节点ID长度为24比特”，是否就可以说理论上支持接入2^24个设备了呢？（蓝牙MAC地址24bit）</p><h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p>星闪支持混合自动重传请求(HARQ，Hybrid ARQ)，是一种FEC和ARQ相结合的技术，目的是增加链路的传输可靠性。传统ARQ，当接收端检测到接收的信息中有错误时，接收的错误包信息直接丢弃，并请求发送端重传相应的数据包。与ARQ相比，HARQ对ARQ进行了相应的增强，即<strong>接收的错误包信<br>息并不丢弃，而是与重传包信息进行合并</strong>，提高接收可靠性。</p><p>星闪系统采用基于Polar码的异步HARQ技术，支持最大4个HARQ进程，支持CC-HARQ方案和<br>IR-HARQ方案。CC-HARQ方案的收益来源于接收端多次软信息合并，提升接收端信息的等效SNR，<br>降低错误概率。IR-HARQ方案，根据Polar码的特点，重传时扩展母码长度或者发送第一次传输时没<br>有发送的编码比特，在获取能量增益的基础上进一步获取编码增益。</p><p>该方案先进的地方在于，通过编码方式可以知道那一部分的数据是错误的，然后定向重传，而不像蓝牙CRC校验对不上就直接舍弃。</p><h3 id="信道编码和调制"><a href="#信道编码和调制" class="headerlink" title="信道编码和调制"></a>信道编码和调制</h3><p>Polar码是基于信道极化理论构造的一种信道编码，是经过理论分析论证可以达到香农极限的信道编码，可以较好的对抗随机错误。RS码是一种线性分组码，是基于伽罗华域构建的多进制信道编码，每个符号可包含多个比特，抗突发干扰性能好，可以较好的对抗连续错误。星闪系统使用Polar码或RS码传输超低时延的小包业务(如车载主动降噪)，确保系统可以在不同应用场景下实现高可靠传输。</p><p>关于Polar码的功能推荐看这个视频：<a href="https://www.bilibili.com/video/BV1fq4y1g7hq/?share_source=copy_web&vd_source=6f08b57d80a641dde8fbade3a5ba8a94">【老奇】5G，华为，土耳其——我花了两个月，搞懂了5G背后的秘密】</a> </p><p>简而言之，极化码是一种为了让信息从A-B传递无误差的编码方式，能收到就能知道对错，而不用像蓝牙一样加一大堆校验。</p><p>综上所述，星闪实现快响应是依赖于物理层的时域和频域调度颗粒，以及混合自动重传机制，这些技术减少了传输延迟和提高了数据的可靠性；</p><p>快传输、大带宽是依赖于物理层的波形采用CP-OFDM波形传输，充分利用多个频段；</p><p>抗干扰是依赖于物理层的信道编码和调制技术，以及采用了5G的Polar编码技术，以及同步协同机制；</p><p>低功耗主要是依赖于G端对T端低功耗模式调度和传输高数据可靠性；而多设备连接主要是因为其抗干扰能力和稳定性。</p><h2 id="对开发者支持"><a href="#对开发者支持" class="headerlink" title="对开发者支持"></a>对开发者支持</h2><p>在[2]中有提到，2022第四季度实现搭载星闪的芯片量产，2023-2024推动产业化落地。中科晶上表<br>示 2022 年将发布基于 DX502c DSP 平台的星闪芯片。极芯通讯技术有限公司也将于同年发布南迦巴瓦（UC6010）星闪 SoC 芯片。但是搜索搜到的都是新闻稿，这几家公司的官网也没有相关的产品。</p><p><img src="/img/Untitled%2014.png"></p><p>在一些2023HDC的视频能卡电脑，有相关芯片和模组了，但是淘宝、华秋、嘉立创等个人开发者买硬件的地方差不到相关芯片。</p><p><img src="/img/Untitled%2015.png" alt="NearLinkModel"></p><p>在harmony Developer的API参考中，也只找到了蓝牙相关的api，没有Nearlink或者SparkLink相关的API。看来离DIY一个星闪耳机玩玩还有一定的距离。</p><h2 id="畅想"><a href="#畅想" class="headerlink" title="畅想"></a>畅想</h2><p>在[1]星闪无线短距通信技术（SparkLink1.0）产业化推进白皮书中，详细描述了主推的四个产业：智能汽车、智能制造、智能家居、智能终端。</p><p>目前还在demo阶段：2022年11月4日，星闪联盟产业峰会在深圳顺利召开，联盟多家创新领先成员单位展示了基于星闪技术的最新原型系统，包括星闪快速无间断抗扰（FISA）技术、星闪商用车360度全景环视系统、星闪电机无线同步控制系统、星闪无线主动降噪系统、星闪沉浸式氛围灯系统、星闪7.1声道环绕声场系统和星闪4K高清无线投屏系统。</p><p><img src="/img/Untitled%2016.png"></p><p>让我比较感兴趣的是一个无线控制电机同步的技术：以伺服电机控制齿轮同步运动为呈现，展示了通过星闪技术实现多个步进式电机的超高精度同步控制。齿轮的运转指令通过星闪技术在电机两端交互协商，双端以小于1微秒的超高精度协同。星闪通过Polar编码和冗余传输等机制，实时快速匹配信道环境，确保工控数据的稳定传输。经实际测量，端到端时延低至100微秒，同步精度100纳秒，可靠性大于6个9。星闪技术可以<strong>有效降低智能制造工厂通信系统的复杂度，节省大量线缆及人工操作成本</strong>，降低风险并实现灵活部署。</p><p>文献[2]星闪技术在智能网联汽车领域应用白皮书中提到，随着智能驾驶崛起，汽车控制器数量增加，不仅会导致线束用量和成本上升，传统线束还存在难以满足灵活部署零部件的要求，装配难度加大等缺陷，且由于电磁兼容等问题，可能存在线束接插件失效等风险。如果都采用有线连接，一辆车的线材总长度就可以2000 米以上！目前蓝牙显然无法支撑数量如此庞大的传感器。</p><p>而目前星闪正在使用无线的方式代替其中一部分传感器，例如车内无线主动降噪-涉及到多个麦克风到座椅旁的反噪声构造扬声器；无线电池管理-200 节以上电池单体的快速接入工作和多维传感器信息采集上报。</p><p><img src="/img/Untitled%2017.png"></p><p>星闪技术目前落地的产品还比较少，或许未来其能够凭借优势打入蓝牙&#x2F;wifi构筑的生态墙，提供更好的无线解决方案。我本科时毕业设计就是设计一个无源无线的传感器，那是我首次接触无线技术，并且相信无线通信是一项改变世界的技术。无线技术将我们与信息世界连接在一起，这些年来逐渐习惯无线耳机、无线键鼠、无线充电、NFC也取代了各种钥匙，再让我使用有线的这些设备总会感觉由奢入俭难。</p><p><img src="/img/Untitled%2018.png" alt="linkEverythin"></p><p>万物互联，你不觉得这很酷吗？作为一名工科生我觉得这太酷了，大带宽、快响应、低功耗、多设备的美妙结合！这符合我对未来近场无线通信的一切幻想。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>白皮书：</p><p>[1] 星闪1.0空口技术性能评估报告</p><p>[2] 星闪无线短距通信技术（SparkLink1.0）产业化推进白皮书</p><p>[3] 星闪技术在智能网联汽车领域应用白皮书</p><p>[4] 星闪无线短距通信技术 (SparkLink 1.0)安全白皮书 一 网络安全</p><p>蓝牙相关</p><p>[5]Bluetooth Core Specification Version 5.2 Feature Overview, Martin Woolley, 9 December 2020</p><p>较好的新闻稿</p><p>[6] <a href="https://36kr.com/p/2378087132424962">华为这次一笔带过的“星闪”，大有来头-36氪 (36kr.com)</a></p><p>[7] <a href="https://soundsightheadphones.com/guides/bluetooth-5-0-codecs-and-other-bluetooth-formats/">Bluetooth 5.0 and Others: Demystifying aptX HD, Low Latency Standards and MIDI Technology - SoundsightR (soundsightheadphones.com)</a></p><p>自引</p><p>[8] <a href="https://yiyangc18.github.io/2023/06/04/%E3%80%90IOT%E5%BC%80%E5%8F%91%E3%80%91%E9%9F%B3%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BA%8F%E4%B8%8E%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/">【IOT开发】音频传输中的时序与同步问题 - CHER-YOUNG BLOG (yiyangc18.github.io)</a></p><p>[9] <a href="https://yiyangc18.github.io/2022/09/06/%E3%80%90%E8%B0%83%E7%A0%94%E5%AD%A6%E4%B9%A0%E3%80%91%E8%93%9D%E7%89%99-%E9%9F%B3%E9%A2%91-%E5%8D%8F%E8%AE%AE%E6%A0%88/">【调研学习】蓝牙-音频-协议栈 - CHER-YOUNG BLOG (yiyangc18.github.io)</a></p><p>[10] <a href="https://yiyangc18.github.io/2022/09/06/%E3%80%90IOT%E5%BC%80%E5%8F%91%E3%80%91%E8%93%9D%E7%89%99SPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%BF%E7%94%A8/">【IOT开发】蓝牙SPP协议的使用 - CHER-YOUNG BLOG (yiyangc18.github.io)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>IOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【软件开发】设计模式</title>
    <link href="/2023/08/14/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/08/14/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><p>类与对象 - 对象是实体，类是对象的抽象集合。</p><p>类的构造函数 - 代替默认</p><p>重载- 相同函数名但是不同参数类型</p><p>属性 - 一种限制了外部修改情况的 public 方法，与 public 成员区别是可以限制读写或数值区间</p><p>封装 - 暴露可操作的接口，减少耦合</p><p>继承 - b is a，b 继承 a 的非 private 属性和功能，可以派生和重写。</p><p>多态 - 不同的对象，相同的方法不同的结果，父类虚函数子类重写</p><p>重构 - 代码冗余后，将子类方法重复的代码变为父类的方法</p><p>抽象类 - abstract 抽象类无法定义实例对象，抽象方法必须被重写</p><p>接口 - 实现某个功能的方法与属性组合，类可以基于接口更简洁地实现该功能，接口是对行为的抽象</p><p>集合 - 实现某一系列功能的类的组合，例如.net framwork 中实现数据存储和检索的集合 ArrayList</p><p>泛型 - 可以接收多种数据类型，但预定义会减少拆装箱开销， List<T> arrayT;</p><p>委托与事件 - 类似于触发-回调机制，当 A 类的对应方法发生时，会执行被添加到 event 的 delegate 实例。委托-引用方法。委托的方法可以带参数</p><h3 id="类与对象的好处"><a href="#类与对象的好处" class="headerlink" title="类与对象的好处"></a>类与对象的好处</h3><p>低耦合 - 》 易扩展，易维护，灵活性高，易于复用</p><p>重复代码多会导致维护困难 –</p><p>业务逻辑和界面逻辑分离</p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图"></a>UML 图</h3><p>方框-类 类名 字段属性 方法行为 ；</p><p>三角-继承  虚线箭头-依赖  实线箭头 -》关联；</p><p>虚线三角&#x2F;棒棒糖 实现接口；菱形-箭头 聚合【真子集】；实心菱形-箭头 组合关系【整体-部分 相同生命周期】；</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>字面意思是一个类的功能要单一；准确解释，一个类只有一个能引起其变化的原因。</p><h3 id="封闭-开放原则"><a href="#封闭-开放原则" class="headerlink" title="封闭-开放原则"></a>封闭-开放原则</h3><p>对于扩展是开放的，对于修改是封闭的。</p><p>对程序的新增需求通过增加代码来实现。</p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>面向过程开发时，先从底层着手，再逐步到应用层（高层）。高层模块依赖于低层模块，不易复用。</p><p>为了高层、底层都具备可扩展、复用，高层模块不应该依赖低层模块，两者都应该依赖于业务对象的抽象。而在初期应该针对交互接口编程，而不是针对业务编程。</p><p><img src="/img/R8YqbWvHNoLLvfxttGfcbXvYnLb.png"></p><p>针对接口而不是业务细节编程，依赖关系终止于抽象类或接口，是面向对象编程的精华所在。</p><h3 id="里氏替换"><a href="#里氏替换" class="headerlink" title="里氏替换"></a>里氏替换</h3><p>子类可以替代父类。如果一个程序中的父类都被子类替代，其业务行为不应该发生变化。</p><p>高层或低层模块，依赖了抽象接口或抽象类，具体的实现都在类中，可以被子类替换，具备封闭-开发的一些性质，扩展功能的话用扩展后的子类替代即可。</p><h3 id="合成-聚合复用原则"><a href="#合成-聚合复用原则" class="headerlink" title="合成-聚合复用原则"></a>合成-聚合复用原则</h3><p>之前的很多模式都是基于继承-多态实现的，主要优化是解耦和复用。但是继承是一个紧密依赖的方式，父类的任何变化都会导致子类变化，而需要复用子类时，可能继承的一些非虚后抽象的方法不在适用，需要修改父类。父类过多的继承又会导致修改牵一发而动全身；继承的强依赖关系限制了其灵活性。</p><p>合成-聚合复用模式 尽量使用合成 or 聚合，尽量不使用继承。</p><p>聚合 - 空心菱形 - 表示一种弱的拥有关系，A 对象可以包含 B 对象，但是 B 对象不一是 A 的一部分。</p><p>合成 - 实心菱形 - 强拥有关系，生命周期相同。</p><p>使用合成-聚合能保证类被集中在单个任务上，类的继承会保持较小的规模，避免增长到过长的继承链，难以修改。</p><h2 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h2><p>创建模式隐藏了这些需要被创建对象的实例类是如何被创建和放在一起的，创建时只需要知道由抽象类所定义的接口是怎样的。客户端只需要提出我想要什么，具体谁创建、如何创建、何时创建由创建类实现。</p><p>使用创建模型时，创建系统对于被创建对象是独立的，创建模式将系统需要使用的哪些类信息会封装，允许用结构和功能差别很大的产品对象配置一个系统，配置可以是动态的 运行时指定的。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>根据需求，在工厂中生成对应的对象。</p><p>需求可以是一类“商品”的具体名称，工厂则负责“生产“出对应的商品。</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>和简单工厂模式不同，工厂方法模式中使用不同的工厂还生成不同的对象，其工厂基类也是抽象类，需要具体的工厂实现。而且工厂方法模式的客户端操作更加复杂，需要在代码中指定工厂，不像简单工厂模式中 工厂类根据 case 选择生成方法。</p><p>好处是，符合了封闭-开放原则。当有新的产品添加时，简单工厂类需要添加产品类并修改工厂类的 case 函数–而工厂方法模式不需要修改基类。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>实例：一个与数据库交互的程序，当更换底层数据库后，程序修改会非常麻烦。 没有做好解耦，希望的效是如果添加对 access 的支持，只需要在数据库交互类组中添加访问 access 的类即可。</p><p>对于一个客户端对应着多个数据库类型交互类的情况，显然可以使用工厂模式，针对不同的数据库类型生成不同的数据库交互对象，它们拥有相同名称的方法， 但是实现不同。</p><p>在客户端，与数据库交互需要声明工厂类型，生成对应的数据库交互对象。</p><p>此时，如果要针对不同的表操作，新的 department 表，则需要创建新的接口，然后再创建新的产品，并在工厂接口添加对应的生产过程。</p><p>抽象工厂模式，和工厂方法模式的不同，在后者的基础上添加了更多的抽象产品，抽象工厂会有多种的实例工厂（取决于有多少类的抽象产品），它们有更多的实现方式。</p><p>相较于工厂模式，把多种抽象产品对应的多个抽象工厂在一个接口内实现的好处是，当需要修改产品的系列，可以直接更换需要实现的抽象工厂。而工厂模式中，每一个产品（department user project 等表）都会在抽象工厂中制造一次，导致了一些重复。相当于在工厂的基础上又抽象了一层。</p><p>反射 – 很像 matlab 中的某个函数，把字符串当成程序代码来运行。将程序由编译时转换为运行时，从而避免 switch-case；可以使用 config 文件记录字符串，来控制程序的不同运行模式。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>有印象，类似于全局变量，只生成一个。</p><p>某些类，例如窗体实例类，不希望出现多次。这个在我之前设计的.NET 多窗体程序中，我是使用了一个全局变量 ISxxFormOpen 来判断的，如果打开了，就不会重复打开。这显然不是一个好的设计。</p><p>稍微好一些的设计是判断是否实例化过 if(formObject !&#x3D; null)  这样会减少一些代码量。 注意实例化后可能会 disposed，这时候窗口对象并没有析构。</p><p>需要注意的是，这时候判断是否实例化过的代码是在客户端中的，而一个不能生成多对象的类，是否已开应该由其自身决定，尽量不麻烦客户端。单例模式中的做法是，把构造函数自由化，然后编写一个静态方法，对该对象初始化并返回对象，！&#x3D;null 确保单例。</p><p>多线程 – 单例 – 锁 ； 保证线程安全 - 减少每次调用 lock 的开销 双重锁定</p><p>C#中静态初始化可以提供类似的效果。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>通过原型实例指定所创建对象的种类，并通过拷贝这些原型创建新的对象。</p><p>对于某个对象有多个实例，多次创建可能有过多重复的代码段，可以使用克隆，然后对克隆的对象实例进行更改。</p><p>实现克隆接口。</p><p>在初始化信息不变的情况下，使用克隆可以隐藏创建的过程，并且节省构造函数的开销。</p><p>浅复制和深复制 – 值类型和引用类型 ； 浅表复制，会复制值类型的字段，但是引用类型的字段不会。深复制把引种对象的变量指向复制过来的新对象，而不是原来被引用的对象。copy - clone</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>复杂对象的构建和表示分离，使得同样的构建过程可以创建不同的表示。内部表象与生产过程分离，</p><p>创建一个复杂对象时，创造顺序是稳定的，但是每个过程的实现方法可以是各异的。</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>信息的隐藏促进了软件的复用，减小耦合。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>接口转换，convertor，将一个类的接口转换成另一个接口，克服接口不兼容导致的无法共同工作。</p><p>当系统的行为和数据都正确，但是接口不符；如果添加适配器的代价比修改交互的两个系统之一的代价小，可以使用适配器模式。在设计以及开放初期尽可能统一接口，避免使用适配器。</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式-将抽象部分与实现部分分离，实现指的是实现其方法的对象，他们可以独立变化。不是强 is a 关系，使用聚合代替继承。实现一个系统，会有多个角度的分类，每一种每类都会有派生变化；应该把多个角度分离让他们独立变化，而不是在大系统的基类上去继承。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>对象关系以 tree 的形式分布-枝 叶。枝尽可能复用根节点；</p><p>透明和安全方法 – 区分枝和叶</p><p>开发的对象是体现部分与整体层次结构，用户在使用时可以忽略组合对象与单个对象的不同；一致的使用组合对象与单个对象；</p><p>组合控件-自定义控件</p><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>一个可以更换小人衣服的系统。小人是核心类，有装饰其他衣服的装饰类。 为已有的功能动态添加更多功能。装饰类为核心的类添加新的方法、字段、逻辑，满足特定情况下的特定需求；在执行时，可以选择性地添加装饰。</p><p>把某个类的核心职责和装饰功能区分开，去除相关类中重复的装饰逻辑。动态地给一个对象添加一些额外的职责，比生成对应子类实现添加功能更加灵活。</p><p>和之前工厂模式不同的是，装饰模式是在核心类的基础上不断地派生子类，最终承载了所有装饰的子类执行对应方法。而工厂模式则是对每一个任务生成一个子类，然后每个子类都运行一次方法。</p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>为子系统的一组接口提供一个组合后的，高一级的接口，减少客户端调用量。</p><p>在设计时，有意识地将不同功能层分离，例如数据访问、业务逻辑、展示。不同层之间提供 facade 接口即可，尽可能减少耦合</p><p>代理提供某个对象的代表访问，外观提供一个子系统的代表访问。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>A 对象操作 B 对象，但可能 A 不方便直接与 B 交互，而 C 与 A 实现相同的接口。可以通过 C 来与 B 交互。</p><p>在范围 B 对象时加入一定的间接性，而这种间接性可以附加多种用途。</p><p>远程代理 - 为 B 对象提供不同地址空间的局部代理。加入 webService 引用，会预先生成 reference 的文件和文件夹。</p><p>虚拟代理 - 开销很大的对象，使用虚拟代理实现图片，先打开网页后再加载图片</p><p>安全代理 - 控制对实际对象的访问权限。</p><h2 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h2><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略类也是定义了一系列的算法，和工厂很类似，根据传递的参数选择具体的算法。但与之不同的是，策略模式的策略类是基类的组合，算法是抽象基类的具体实现子类，根据参数生成基类的具体策略算法，而工厂模式中，工厂类是实现子类的子类，根据传参生产具体的子类对象。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>在完成某一系列步骤时，详细实现只有很小的不同。可以把这个不同之处变为父类的虚方法，其余部分在父类实现，而子类只要重写该虚方法，最大程度复用代码。</p><p>模板-一个操作中的算法骨架，并且将一些需要动态变化的部分在子类实现，这样可以使用一个算法框架实现特定的步骤。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>发布-订阅模式。一种一对多的依赖关系，让多个观察者对象监听某一个主题对象，这个发布对象能通知订阅对象。</p><p>解耦合 – subject 不需要知道都有谁订阅了。让发布和订阅都依赖于抽象接口，而不依赖于具体操作流程。</p><p>当一个对象改变时，其他对象也需要对应的变化，但是不能确定具体的变化目标和结果。而观察者模式可以把两者分开封装。</p><p>观察者模式中，对于已封装的类，让其实现“订阅”修改会有一些困难。一是直接修改违背了封闭-开放原则，另一方面基于订阅发布的接口实现需要依赖于发布的类。这时候可以使用事件委托的方式实现。</p><p>委托对象搭载的方法不需要属于同一个类，但方法需要有相同的返回值和参数列表。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>当一个对象的行为依赖其状态，并且状态转变表达式过于复杂，可以将其拆分，把状态的判断逻辑转移到不同状态的一系列类中。将特定状态相关的行为局部化，并且将不同的状态分割。</p><p>当有很长的 if else，可以把状态行为定义为一个抽象类，每一个 if 分支去实现行为。这样当需要修改 if 语句中的某一个判断条件或执行，或者出现特殊情况（例如进度条加入了 pause 判断）添加额外的判断，不用去 那个很长的 if-else 语句中修改。</p><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>状态恢复-从内存而不是硬盘中。不要把备份的细节暴露在客户端</p><p>保存的实现可以通过一个 memento 类实现，定义一些需要保存的细则；恢复则在发起备份的类中添加参数为 memento 的 set 方法。</p><p>这适用于功能较为复杂，但需要维护或记录所选定的属性历史的类中。</p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>遍历。顺序方法，访问聚合对象中的各个元素，不暴露内部表示。</p><p>当需要访问一个聚合对象，并且无论是何种对象都需要遍历。迭代器支持多种遍历方式。</p><p>Foreach in</p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>行为请求者和行为实现者耦合过紧密，行为的申请会很复杂。行为实现有延时 、排队 、 请求日志 、 撤销等工作，在客户端实现会很困难。</p><p>命令模式可以较轻松地创建一个命令对了，并记录日志，实现请求的撤销和重做；允许接收方拒绝；添加新的具体命令很容易；请求一个操作对象并不用知道操作对象如何执行。</p><p>代码不用添加猜测的功能架构，例如命令模块，实在需要时再重构即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【IOT开发】音频传输中的时序与同步问题</title>
    <link href="/2023/06/04/%E3%80%90IOT%E5%BC%80%E5%8F%91%E3%80%91%E9%9F%B3%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BA%8F%E4%B8%8E%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
    <url>/2023/06/04/%E3%80%90IOT%E5%BC%80%E5%8F%91%E3%80%91%E9%9F%B3%E9%A2%91%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BA%8F%E4%B8%8E%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="音频传输中的时序与同步问题"><a href="#音频传输中的时序与同步问题" class="headerlink" title="音频传输中的时序与同步问题"></a>音频传输中的时序与同步问题</h1><h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><p>在流媒体应用和音频服务中，同步问题是决定用户体验的重要一环。在处理多媒体数据同步问题时，可以使用等时间间隔同步、时间轴同步和流控制同步等策略，这些同步规范方法可以根据具体的需求选择和应用。这篇文档将从实际应用场景出发，参考蓝牙音频协议栈及其他解决方案中关于音频传输时序问题的处理方法，尝试解释音频同步的基本思想和实现难点。最后，特定的应用场景，尝试提出可行的解决方案。</p><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>在蓝牙耳机、视频播放等场景，对时序同步要求较高，音画不同步以及蓝牙耳机的时延较大会严重影响用户体验。早期视频网站或直播网站经常出现音画不同步的问题，蓝牙耳机也或多或少存在时延问题。一般而言，我们对于音频与视频延时到 80ms 时，会较容易被察觉到。同时，声音比视频提前，会比视频提前更容易接受。</p><p>以蓝牙传输音频数据为例，我们假想最简单的模型：蓝牙音频发送端等时间间距，均匀的发送数据包，接收端等时间间距均匀的接收数据，这种情况下接收端可稍微延迟后将收到数据通过喇叭送出，在喇叭播放完这包数据之前可收到下包数据继而能够连续不断的播放，此时蓝牙音频的时延取决于发包间隔和传输时间，而这个时间是非常小的。在最早的 STM32F103 上基于定时器、UART 和 DMA 就是这种等时间间距收发、播放的策略，在有线传输的稳定传输下可以几乎不考虑时延（最终调整时延在 10~20ms）。</p><p>然而，现实中会有信号干扰，有可能出现传输错误的。传输错误重传导致其中某些包重传次数多传输时间变长(传输错误重传是在蓝牙协议层中进行的，在应用层开发看到的只是每次成功 write 的时间不一致)，接收端收到的数据包并不是等时间均匀的。这种情况下接收端想要流畅播放必须先缓存一定时间长度的数据之后再进行播放，以防止其中包晚到导致播放不连续。这种情况下真实主要因素是为了抵抗网络传输不稳定性而人为添加的延迟(缓存)，也就是蓝牙耳机主要的延时是因为要缓存一段时间的数据。</p><p>在实现音频同步主要是在应用层处理，操作系统和驱动层的目标是确保单个媒体流单元的平稳呈现。多个媒体流之间的同步需要在更高的层次上进行处理，例如在应用程序层或媒体层。接下来将简要介绍如何在下位机的驱动层实现对媒体流的稳定、连续播放，然后介绍一些经典的同步策略，并为目前的应用场景指定对应的同步机制和算法。</p><h2 id="音频流模型"><a href="#音频流模型" class="headerlink" title="音频流模型"></a>音频流模型</h2><p>尝试用一个数据流-管道-蓄水池模型来解释音频流的播放时序问题。音视频数据，我们可以看作一个数据流,数据流的最小处理单元是 LDU，Logical Data Unit。在对音频数据进行传输时，使用类似于 stream 类的数据流方式。stream 类没有预定长度，易于分段与组合，在底层可以基于 queue 结构实现。传输的过程，可以看作是数据流在管道中进行，不同的管道类型对应着不同的传输模式-wifi、蓝牙、UART；他们有着不同的带宽和稳定程度。在播放设备的控制器中，可能会有类似于蓄水池的缓存，来存储接收到的，还未播放的 stream。</p><p><img src="/img/GMeQbaqbzor9fYxvTabcR5lxnAh.png"></p><p>先进的音视频处理过程都会把音视频数据转换成流式处理。音视频数据一般比较大，所以对内存需求也比较高，流式处理可以在一段新数据到达时即开始处理。同时我们播放的音视频很多时候是无尽事件流，没有明确的停止时间，流式处理可以收到即处理，处理即注销。在我最早的 STM32F103 播放 HAPTIC 驱动中，数据是即发即用的数组格式，只能应用于收发时间间隔稳定的应用场景。而之后采用了队列结构，底层 PCM 数组仍然以数组存储，但基于队列控制数据流式播放，能有效地提高稳定性。</p><p>对于流的连续播放，在无法保证发送管道稳定时间间隔发送的情况下，会需要一定的缓存帮助。当收到下一段数据前播放上一段数据，就会造成卡顿，而蓝牙耳机协议的解决方法是缓存一段时间再播放。越大的缓存空间，能够抵抗越高强度的发送不稳定，但同时也会导致更高的延时。在使用蓝牙耳机时，暂停后点击“播放“需要卡一小下才能播放，这很可能是缓存延时导致的。在目前 ESP32-AHAP 解码的驱动中，还没有加入缓存播放机制，所以可能会造成卡顿，详情见 <a href="https://fuaqwpa97c.feishu.cn/docx/A9azdr57Lov4XSxawSpcQ6UvnWg">AHAP 上位机 时序优化</a> 。虽然通过上位机超量发送人为造成了一段冗余缓存解决了卡顿问题，但这也会造成数据堵塞造成小卡顿的隐患。但在该应用中加入缓存播放是不可能的——一个数据包的间隔是 100ms，缓存一个包就会导致 &gt;100ms 的延时，这会在播放、调整进度条、暂缓恢复时都会产生，显然是无法接受的。所以之后对于该驱动的优化，如果加入缓存机制，则需要改小包数据到 10ms 每个包（这对于 SPP 协议是极限了），然后缓存一两个包。</p><p>LDU 的数据长度与播放质量相关。模型中的流是连续的，但基于 LDU 发送的数据包显然是离散的数据。显然的，我们减小流的最小单位，可以提高数据流的”流畅程度“。但减小 LDU 的代价是什么呢？在基于 RFCOMM 的 SPP 蓝牙传输中，LDU 对应最小时间长度是 10ms，这对应了蓝牙 100HZ 的回报率。需要注意的是，RFCOMM 是伪双工程协议，所以如果希望基于 RFCOMM 建立同步链路，更小的包会影响下位机的回报效率。另一方面，蓝牙传输的带宽是和每个包的数据量相关的，一个包传输更多的数据能够得到更大的带宽。目前的 AHAP 数据流的回报和带宽都没有达到上限，所以后续可以基于减小 LDU 进行优化。</p><p>值得一提的是，在讨论连续播放时，我们更多的是关于发送时间间隔不稳定的讨论，而不是丢包、数据帧错误等情况。丢包的影响是致命的，这会导致数据流的不连续，如果没有相应的错误处理会影响流的后续播放。但无论 UART 还是 SPP 都有对应的纠错重发机制，成熟的传输接口都有类似的机制。目前的应用中还没有遇到丢包的情况，如果后续考虑强干扰环境，需要加入对应的错误处理机制。</p><h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><p>文献[3]中，对于时间依赖的媒体数据的同步方法，总结了以下同步策略：</p><ol><li>基于时间间隔的同步：要求多媒体对象之间的播放时间间隔保持一致。可以简单理解为在固定的 interval 内处理需要播放的数据单元。</li><li>基于轴的同步：要求多媒体对象之间的时间轴保持一致。1.在多媒体对象中添加时间轴信息，例如音频时间轴、视频时间轴等。在播放过程中，通过比较时间轴信息来同步多媒体对象之间的播放。可以使用一个全局时钟来同步多媒体数据，所有媒体对象都附加到全局实时时间轴。2.基于时间戳的同步。在多媒体数据中嵌入时间戳，然后建立虚拟时间轴，在接收端使用这些时间戳来同步多媒体数据。这更适用于被拆分的信号流。</li></ol><p><img src="/img/GZJ9bxf6Yofoq0x95ylcgAANnoc.png"></p><ol><li>基于控制流的同步：基于控制流来同步多媒体对象。在多媒体对象中添加控制流信息，例如播放、暂停、快进、倒退等操作。在播放过程中，通过比较控制流信息来同步多媒体对象之间的播放。控制流也可以基于反馈，在发送端和接收端之间建立反馈通道，通过接收端向发送端发送反馈信息来控制多媒体数据的播放速度与进度。</li></ol><p><img src="/img/SUijbmOqpob7RExAwgAcrv1mnsf.png"></p><p>例如上图中的事件控制流控制同步模型，需要播放的数据以树的数据结构存储，播放命令对应某一层的数据。但就音视频的同步而言，会简化成两个数组，只需要同步最小 LDU 的同时播放、暂停状态即可。</p><p>这些同步规范方法需要根据具体的需求选择和应用。对于没有用户互动的简单演示，可以选用基于全局定时器的方法。对于有交互的复杂结构，基于控制流的参考点模型似乎是合适的。</p><h2 id="discussion"><a href="#discussion" class="headerlink" title="discussion"></a>discussion</h2><p>对于最经典的流式音频播放，下位机对数据的实时性要求较高，而上位机无法满足稳定、精确的定时发送。所以我们需要一定的缓存空间。就像出水管道在蓄水池中的一定高度，要等蓄水量到一定值之后才会播放。而缓存的时间会导致一定的延时，即在更改进度条时需要新的等待时间。</p><p>在上位机发送数据的策略中，目前 python 上位机的做法是通过一个定时器，固定 interval 给下位机发送相应的数据包。在播放器中，通过进度条的回调函数让定时器发送函数的 index 与进度条同步。这种方法相当于固定给下位机发送包，通过进度条回调让发送的数据定期和视频画面同步。由于使用了微超量发送的策略保证流的连续播放，所以没有使用缓存时间，同步实现的较好。</p><p>对于稳定的延时，我们可以通过固定偏执的修正来减小延时的影响。例如大多数情况是音频延时，这时候可以让画面进行等待。当然，更常见的做法是通过控制流来达到稳定的延时，并通过调整偏执来进行同步。</p><p>在具体的应用中，我们会考虑基于轴同步的音视频同步，即在播放端的音频轴与发送端的音频轴同步，并基于事件控制进行音频流控制。需要注意到的是，音频缺失比存在稳定延时，对体验的影响小很多。所以在通过等待-轴同步的方案中，可以省略一定量的音频数据，让画面实时运行，在之后再进行同步。</p><p>从理论到实践：<a href="https://fuaqwpa97c.feishu.cn/docx/FGOgdS4OooRvgkx93uGcnh6mngc">AHAP-DECODE 解码时序优化</a></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="蓝牙链路"><a href="#蓝牙链路" class="headerlink" title="蓝牙链路"></a>蓝牙链路</h3><p>Synchronous Connection Oriented (SCO) link and the Asynchronous Connection-Less (ACL) link</p><p>SCO 更多是在语音信号流中使用，它只能支持 point to point 的连接。我们的设备目前是 point to point 的，不过没有使用 SCO 链路。因为在 SCO 实现的过程中，是基于等间距时隙交换实现同步的，所以 master 的收带宽会占用发一样通用量级的带宽。</p><table><thead><tr><th>Time processbar</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>MO</td><td>MI</td><td>MO</td><td>MI</td><td>MO</td><td>MI</td></tr><tr><td>SI</td><td>SO</td><td>SI</td><td>SO</td><td>SI</td><td>SO</td></tr></tbody></table><p>这种不同于流式的异步收-存储-连续播放的策略。信号不稳定不会导致时延，只会导致音频质量降低。</p><p>The term ‘advanced audio’ should be distinguished from ‘Bluetooth audio’, which indicates distribution of narrow band voice on SCO channels as defined by the Bluetooth Baseband specification.</p><p>The master maintains the SCO link by using reserved slots at regular intervals. The basic unit of reservation is two consecutive slots (one in each transmission direction).</p><table><thead><tr><th>Time processbar</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>MO</td><td>slots</td><td>MI</td><td>slots</td><td>MO</td><td>slots</td></tr><tr><td>SI</td><td>slots</td><td>SO</td><td>slots</td><td>SI</td><td>slots</td></tr></tbody></table><p>SCO 链路预留插槽后，微网中其他 ACL 链路的微微网带宽非常有限。</p><p>The transmission of audio&#x2F;video over the Internet requires the support of audio encoding and decoding schemes and a packet switched based network connection—which is not offered by the SCO connection.</p><h3 id="SCO"><a href="#SCO" class="headerlink" title="SCO"></a>SCO</h3><p>在配置A2DP蓝牙协议栈时，偶然发现有个东西叫：SCO  -Synchronous Connection Oriented link - 面向链接的同步链路<br>最近接触了一下音视频开发相关的项目，不同设备间、不同数据形式间的时间同步是一个比较重要的问题。了解这个链路的同步逻辑、实现原理，会有助于需要同步的项目开发。</p><p>百度百科：<br>支持对时延敏感的信息如语音。蓝牙中定义的两种数据链路方式之一。<br>用保留带宽进行同步通信，即两台设备在LMP层利用保留时隙在物理信道上周期传送传送数据包。这种类型的链接主要用于传送SCO包（语音数据）。SCO 包不包括CRC码，且不进行重传。主要支持传输有时间限制的信息，例如声音。仅仅在ACL链接已经建立之后，才可以建立SCO 链接。</p><blockquote><p>What is SCO in Bluetooth?<br>SCO (Synchronous Connection Oriented Link) This is a voice data link. While Bluetooth is the technology used to connect devices from different manufacturers without wires, the devices still have to talk to each other while providing what ever service they are designed for.<br>SCO is a symmetric link, i.e. fixed slots are allocated for each direction. Since fixed slots are reserved, SCO provides a circuit switched connection. SCO radio links are used for time critical data transfer, particularly for voice data.</p></blockquote><blockquote><p>The Synchronous Connection Oriented link is one of the two possible Bluetooth data link types defined. The SCO link is a symmetric, point-to-point link between the master device and a specific slave device. The SCO link reserves slots between the master and the slave and can therefore be considered to provide a circuit switched connection. The SCO link is usually used to support time critical information, e.g. voice, since time critical SCO packets are never retransmitted. The master device can support up to three SCO links, this might be to the same slave or to different slaves. A slave can support up to a maximum of three SCO links, assuming they are from the same master. If the slave has links from different masters, a maximum of two SCO links are available.</p></blockquote><p>蓝牙物理链路ACL(Asynchronous Connectionless)，另外的一种链路是SCO(Synchronous Connection Oriented)主要用来传输对时间要求很高的数据通信。<br>蓝牙基带技术支持两种连接类型：同步定向连接(SCO)类型和异步无连接(ACL)类型。前者主要用于同步话音传送，后者主要用于分组数据传送。<br>SCO连接为对称连接，利用保留时隙传送数据包。连接建立后，主设备和从设备可以不被选中就发送SCO数据包。SCO数据包既可以传送话音，也可以传送数据，但在传送数据时，只用于重发被损坏的那部分的数据。同步定向链接（SCO）是在匹克网中主单元和从单元之间实现 点到点链接。主单元通过有规律的 使用保留时隙来维持SCO 链接。 </p><p>SCO 链路是通过为传输预留时隙来实现同步的。主设备向从设备发送同步数据包以建立连接。然后，从设备向主设备发回一个数据包，以确认它已收到同步数据包。此后，两个设备同步并可以传输数据。<br>主单元以有规律的时间间隔来发送分组，所以在保留的主―从时隙里，称到从单元的SCO 间隔为Tsco（记数时隙）。在主―从时隙里SCO从单元总是允许响应SCO分组传输。SCO 链接由主单元发送SCO 建立消息，经链接管理（LM）协议来确立。该消息分组含定时参数（如SCO 间隔Tsco 和规定保留时隙补偿Dsco）等。在 SCO 链接不保留的时隙里，主单元可以与任何属于每个时隙基里的从单元进行分组交换。</p><p>所以SCO实现同步的两个核心分别是“间隙”和“回报”。在发送语言等数据时进行主从通信，确定时间同步。<br>在我的项目中，通过编码压缩的方式提高了数据的传输效率，有“空闲”来进行回报同步。但是目前使用的SPP协议是可以回报的，但是回报与server端接受-处理耗时可能会比较久。之后降低延时可以基于这种方法改进。</p><h3 id="AVDTP-协议"><a href="#AVDTP-协议" class="headerlink" title="AVDTP 协议"></a>AVDTP 协议</h3><p>音视频分发传输协议</p><p><img src="/img/Dsmpbx7oZo1lXXxSjWQcgR8Xnmg.png"></p><p>基带是蓝牙堆栈的物理层，用于管理纠错、数据包处理、寻呼和查询以访问蓝牙设备以及蓝牙安全等功能。基带收发器支持时分双工方案。</p><p>链路管理器协议 （LMP） 执行链路设置和配置、身份验证、加密管理等。</p><p>逻辑链路和控制适配协议 （L2CAP） 隐藏了蓝牙较低层的功能，对较小的基带数据包执行分段和重组操作。</p><p>AVDTP 指定使用 ACL 链路通过蓝牙空中接口分发音频和视频以及流式传输的传输协议。</p><p>AVDTP 提供规则和程序，为 A&#x2F;V 数据传输提供高质量的同步通信（传输时钟相关过程所必需的）。</p><p>AVDTP provides rules and procedures to provide high quality isochronous communication (required for the transmission of clock dependent processes) for the transfer of A&#x2F;V data.The transport mechanism and message formats of the AVDTP are based on the Real-time Transport Protocol (RTP).</p><p>在 A&#x2F;V 应用程序通过蓝牙链路传输 A&#x2F;V 流之前，AVDTP 会执行 A&#x2F;V 参数协商。根据此协商的结果，应用程序将传输 A&#x2F;V 内容。</p><p><img src="/img/CdDSbUUpDojFiOxQxblcAcDkngd.png"></p><p>上图显示了 AVDTP 架构（由 AVDTP 规范定义）。我们总结了 AVDTP 组件的主要功能（如图 <a href="https://www.sciencedirect.com/science/article/pii/S0140366404003408#fig2">2</a> 所</p><ul><li><em>流管理器</em>：提供流化、媒体成帧、时间戳管理、媒体数据包序号、上报报更高层丢包、抖动计算等功能。</li><li><em>恢复组件</em>：不提供前向纠错 （FEC） 和相等的 FEC。</li><li><em>适配层</em>：执行报头压缩和多路复用，以允许在一个传输通道上多路复用多个传输会话。</li><li><em>信令</em>：提供应用和传输服务能力的发现、流协商、流连接建立、流连接拆解、流暂停和恢复。</li></ul><p>AVDTP 的<em>传输服务功能</em>对应于 A&#x2F;V 传输层内更具体的传输相关“服务”。其中包括成帧和分段、封装、交付性能报告、数据包丢失检测、数据包恢复、强大的标头压缩以及将传输会话多路复用到传输通道。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] A. Rossholm and B. Lövström, “A robust method for estimating synchronization and delay of audio and video for communication services,” Multimedia Tools and Applications, vol. 75, no. 1, pp. 527-545, Jan. <a href="https://dl.acm.org/doi/10.1007/s11042-014-2306-6">2016, doi: 10.1007&#x2F;s11042-014-2306-6 </a></p><p>[2] S. Zeadally and A. Kumar, “Design, implementation, and evaluation of the audio&#x2F;video distribution transport protocol (AVDTP) for high quality audio support over Bluetooth,” Computer Communications, vol. 28, no. 2, pp. 215-223, Feb. <a href="https://www.sciencedirect.com/science/article/pii/S0140366404003408">2005, doi: 10.1016&#x2F;j.comcom.2004.09.007</a></p><p>[3] G. Blakowski and R. Steinmetz, “A media synchronization survey: reference model, specification, and case studies,” in IEEE Journal on Selected Areas in Communications, vol. 14, no. 1, pp. 5-35, Jan. 1996, doi: 10.1109&#x2F;49.481691.</p>]]></content>
    
    
    
    <tags>
      
      <tag>IOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【mems】一种三相静电旋转电机的设计</title>
    <link href="/2023/04/25/%E3%80%90MEMS%E3%80%91%E4%B8%80%E7%A7%8D%E4%B8%89%E7%9B%B8%E9%9D%99%E7%94%B5MEMS%E6%97%8B%E8%BD%AC%E7%94%B5%E6%9C%BA%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/04/25/%E3%80%90MEMS%E3%80%91%E4%B8%80%E7%A7%8D%E4%B8%89%E7%9B%B8%E9%9D%99%E7%94%B5MEMS%E6%97%8B%E8%BD%AC%E7%94%B5%E6%9C%BA%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>试设计一款静电驱动电机，要求：输出力矩可达 2nNm，驱动电压必须小于 50V。<br>要求：原理说明、可能的应用背景、结构图、尺寸参数、数学建模（可包含等效电路图、传递函数、仿真等）、工艺流程说明；按照发表的论文的形式（摘要、 关键字、正文、参考文献)</p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>静电 MEMS 旋转电机通过转子和定子两极之间的可变电容中储存的电能来运行。本文介绍了一种 MEMS 三相旋转微电机的设计、建模和制备工艺。该电机采用了“蝴蝶形”挠性悬挂枢轴，以避免运行过程中摩擦接触，提供精确、可重复和可靠的双向步进运动。对结构进行了数学建模，在 50V 驱动电压下最大能有 12.285nN·m 的输出力矩和 32° 的行程。结合垂直沟槽隔离和体硅工艺，设计了具有高纵横比电机的微电机制备方法。该电机可以使用在硬盘驱动器中的二级执行器或驱动微泵、微阀或微型镜片等设备。</p><h2 id="Keywords："><a href="#Keywords：" class="headerlink" title="Keywords："></a>Keywords：</h2><p>MEMS，静电力，微电机，三相电机，可变电容，挠性悬挂枢轴，微机械工艺，体硅工艺</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>MEMS 电机的应用范围很广，得益于其小型化、低功耗、高精度的特性，从推动微型车辆、微型机器人到驱动微泵、微阀或微型镜片等设备都有相应的应用。目前大功率 MEMS 电机大多是基于传统电机的电磁感应原理，使用体硅工艺制成的磁感应线圈和永磁体驱动转子旋转[1][2]，但是其工艺复杂，成本较高，与平面微加工工艺兼容性较差。目前 MEMS 电机研究的主要方向是静电力驱动型。静电驱动的主要来源是电容器的电场，它依赖于两个带相反电荷的平行板之间的吸引力。它们具有设计简单、响应速度快、易于制造和低能耗的特点[3]。从一个简化的角度来看，梳状驱动器只是由一个带有移动电极的可变电容器组成。然而，静电型电机需要高输入电压，而且它的扭矩一般较低。在一些低速、低功率的应用场合，静电型 MEMS 电机更具有优势。</p><p>典型的三相静电旋转步进微电机的布局和工作原理示意图见图 1[4]。该电机由一个转子和一个定子组成，两者都含有大量的疏齿状电极。转子由一个弯曲的枢轴机构悬挂，它会给转子旋转自由度，同时提供一定的机械刚度。在电机运行过程中，转子电极通过挠性悬架进行电气接地（GND），而定子电极以三个不同相的电位交替。</p><p>在工作时，每一相的定子电机分为一组。当相位 φi 被激活时，相应的定子电极和相对的转子电极之间的电压差（Ui）产生了一个静电力。由于对称性，作用在转子上的静电力的径向分量会被抵消，切向分量会产生一个全局扭矩。静电扭矩会驱动电机重新调整转子的电极到和激活的定子相对的位置。在常规的设计中，定子电极的间距会设定为转子间距的 4&#x2F;3 倍。因此，当某一相的电极与转子上的相对电极完全对齐时，另外两相的电极和定子电极有一个错位，这个错位等于转子间距的-1&#x2F;3 和 1&#x2F;3。当电压以适当的顺序施加到每一相上时，转子可以按顺时针（如图 1 所示）或逆时针方向上实现阶梯式运动，从而实现电机的双向旋转。</p><p><img src="/img/ROIhbDaY1oZHPSxCj5xcLbiontc.png"></p><p>图 1.三相静电旋转步进电机的工作原理。通过在每一相上连续施加电压，实现转子的阶梯式运动。</p><p>此外，当以步进模式运行时，这些电机会处于有限数量的稳定状态，稳定状态的数量（分辨率）由转子和定子磁极的空间分布定义。这使得转子的高精度可重复运动不需要复杂的反馈控制，而是取决于设计的定子电极密度和工艺能力。</p><h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><p>在 MEMS 电极的转子支撑结构中，一般有挠性结构和摩擦轴承[5]。摩擦轴承能够实现更大的旋转范围、更小的扭转限制，但是触摩擦和由此产生的磨损会影响器件的精确和可靠性。在本次的设计中，使用了挠性结构来悬挂转子。挠性结构很容易和平面工艺兼容，同时转子和定子之间可以避免物理解除。此外，挠性体可以作为一种电气连接，通过它实现转子与 GND 的连接，避免了复杂的布线。最后，挠性体的机械刚度虽然会减小电极的驱动能力，但其恢复力决定了转子在静止时的确定位置，电机的旋转范围也会受到保护。</p><p>挠性转子悬架的典型结构如图 2 所示。图 2(a)所示的平行四边形挠性枢轴一般会用在直线型执行器。图 2(b)所示的旋转执行器平行四边形挠性枢轴可以看作是(a)的演化，可以用作旋转执行器的悬挂。图 2(c)的蝴蝶形挠性机构可以看作是四个(b)的串联叠加，它相较于同尺寸的(b)结构，可以提供更大的旋转行程、更小的机械刚度和跟小的旋转中心偏移[6]。</p><p><img src="/img/OeQhb6j4bopxc5xEK07c1ALgn1e.png"></p><p>图 2.用于直线和旋转导向的挠性机构。(a) 用于直线引导的“双平行四边形挠性结构”的示意图。(b) 用于旋转导向的 “挠性支点 “示意图。(c) “蝴蝶形”枢轴，由四个串联的基本挠性枢轴组成。</p><p>蝴蝶形挠性枢轴在 2003 年提出，旨在建立了一个可以通过 IC 工艺加工，可以单体制造，具备非常小的寄生中心平移的结构。这种结构由四个串联的基本枢轴组成，它们的四个旋转中心都在一起，具体的结构见图 3。第一对挠性叶片连接中间块 1 和固定基座，它对于轴线 O 具有一个旋转自由度。第二对挠性叶片连接中间块 2（蝴蝶形结构）和中间块 1。类似的，第三和第四挠性叶片用于连接中间块 2、3 和旋转移动块。由于所有的挠性叶片都是相同的，所以基本枢轴的旋转刚度都是相同的。因此，当对移动块施加一个角度 α 时，四个枢轴平均分担行程（即块 2 相对于固定块旋转 α&#x2F;4，块 3 旋转 α&#x2F;2，块 3 旋转 3α&#x2F;4），系统的整体旋转刚度为单个枢轴的四分之一。</p><p><img src="/img/O3J1b8FfrovpWHxugHQcf2HZnEc.png"></p><p>图 3.”蝴蝶形”枢轴结构示意图。通过四个基本挠性铰链串联，使它们各自的寄生偏移矢量有效地互相补偿，从而减小中心偏移。</p><p>考虑图 2(b)中的挠性枢轴，当我们施加一个切向的旋转驱动力时，由于挠性梁长度方向不易变化，可动部分的旋转中心和所设计的选中中心会有一定的偏移，我们把这个偏移量称作寄生偏移矢量。而”蝴蝶形“枢轴通过将四个基本挠性铰链串联起来，由于这些偏移矢量的方向和大小不同，它们会产生一个合成矢量，其方向和大小是所有偏移矢量的矢量和。基本挠性铰链串联时，寄生偏移矢量会相互作用，它们的排列方式使它们各自的寄生偏移矢量有效地互相补偿。因此，”蝴蝶形“结构可以补偿中心偏移。</p><p>在本文的设计中，考虑到实际转动情况，将”蝴蝶形“与转子结合，作为旋转件；两个连接块作为固定件。在 3D 建模软件中构建 MEMS 电机的基本结构，在此我提供了所建模的模型，见下方附件和图 4。</p><div style="display: flex; flex-direction: row; gap: 10px;">  <img src="/img/e1c39cae-331d-421f-bd81-fa9e0b3e6bbb.png" alt="图 4.1">  <img src="/img/9a91d34f-2597-4347-87b0-9362183878ac.png" alt="图 4.2"></div>图 4.所设计 MEMS 电机的结构示意图。(a)单个电机结构总览 (b)疏齿处放大<p>在所设计的结构中，上下两个固定块通过绕行枢轴和转子”蝴蝶“连接。由于每个枢轴平均分担行程为转子总行程的二分之一，所以整体旋转刚度为单个枢轴的一半。在设计定子电极和转子电极的间距时，需要考虑电机的驱动能力、行程和工艺尺寸分辨率：电机的特征尺寸越小，每一相电机数越多，驱动能力越大，同时增大”蝴蝶枢轴“的弧度也能增多转子电极数，但会因为机械干涉减小器件的行程。所以，在初步设计中，转子间距为 1°，数量被设计为 204 个，不考虑驱动能力的最大行程为 ±16°。完成大致结构设计后，需要进行具体的尺寸参数和结构参数设计，具体参数的含义与设计结构见下节。</p><h2 id="Molding"><a href="#Molding" class="headerlink" title="Molding"></a>Molding</h2><p>在本节中，将对所设计的 MEMS 电机进行静态建模。首先会计算三相静电驱动所产生的扭矩。然后，通过悬架的机械刚度将静电扭矩与转子的角位移联系起来，最后进行了尺寸参数的设计。</p><p>转子的旋转位移 θ 与静电扭矩 M 成正比，与蝶形悬架的刚度 Kθ 成反比。该扭矩是由作用在转子和定子两极之间的静电力的切向分量产生的。施加在单个转子极 j 上的切向力 F 可以用平行板电容公式来估计。通过可动平行平板电容存储的能量对宽度方向的偏微分，可以得到单个电极对的切向静电力：</p><p>$$<br>F &#x3D; \frac{\varepsilon LU^{2}}{2g}\tag{1}<br>$$</p><p>其中 L 是电极的高度，g 是转子和定子电极之间的间隙，ε 是空气的介电常数，U 是施加在相关相上的电压。需要注意的是，（1）不包括边缘效应，因此是一个粗糙的近似值。</p><p>从（1）中，我们可以推导出由相位 φi 施加在转子上的静电扭矩 M：</p><p>$$<br>M &#x3D; \frac{n \varepsilon LU^{2}r}{2g}\tag{2}<br>$$</p><p>其中 r 是转子半径。由于 g&lt;&lt;r，所以上式简化了 g 的影响，n 是一相中的电极数。</p><p>我们所使用挠度枢轴会有弹力限制旋转，接下来计算挠性梁的旋转弹性系数。单个挠度枢轴的原理图如图 5 所示，枢轴是由两根梁 AB 和 A′B′组成的旋转导向。它的旋转轴线与两根梁在静止位置的交点平面所定义的线大致吻合，当挠度枢轴受到以 C 为中心的弯矩 C（↶）时，每根梁都会承受以 C 为中心的弯矩 M0&#x3D;C&#x2F;2。因此，对该机构的刚度计算可以通过应用于单根悬臂梁的计算实现。</p><p><img src="/img/FZrabBjX5oEWoFxcfQAcBen5nwh.png"></p><p>图 5.单个挠度支撑梁的示意图</p><p>关于单个挠性结构的旋转刚度可以见文献[4]的附录 A。在此简要说明计算步骤:</p><blockquote><ol><li>设一个梁的两个端点为 A 和 B，它们之间的距离为 l，枢轴的宽度为 b，厚度为 h。</li><li>根据弯曲应力公式，计算梁上任意一点 P 处的应力 σ，其中 P 距离 A 的长度为 x，距离梁中心线的高度为 y。</li><li>根据应力和应变之间的关系，计算枢轴上任意一点 P 处的应变 ε。</li><li>根据应变和位移之间的关系，计算枢轴上任意一点 P 处的位移 u 和 v，其中 u 是沿着 x 方向的位移，v 是沿着 y 方向的位移。</li><li>根据位移和角度之间的关系，计算枢轴上任意一点 P 处的角度 θ。</li><li>根据角度和扭矩之间的关系，计算枢轴上任意一点 P 处的扭矩 M。</li><li>根据扭矩和旋转弹性刚度之间的关系，计算枢轴的旋转弹性刚度 Kθ。</li></ol></blockquote><p>所对应结构的旋转刚度:</p><p>$$<br>K_{\theta} &#x3D; \frac{M}{\theta} &#x3D; \frac{4EI}{l}\left(1 + 3\frac{p}{l} + 3\frac{p^{2}}{l^{2}} \right),\qquad \text{for}\ \sin\theta \approx \theta\tag{3}<br>$$</p><p>其中 E 是梁材料的杨氏模量，l 是梁的长度，I 是其中心惯性矩,p 是悬臂梁端点到虚拟旋转中心的距离。对于矩形截面的梁，惯性面积矩是平面外高度 h 和宽度 b 的一个函数:</p><p>$$<br>I &#x3D; \frac{hb^{3}}{12} \tag{4} <br>$$</p><p>对于所设计的蝴蝶型挠度支架，弹性系数为单个挠度支架的一半</p><p>$$<br>K_{\theta\vert \otimes} &#x3D; \frac{K_{\theta}}{2}\tag{5}<br>$$</p><p>考虑性能要求和应用场景,设计如下尺寸参数：</p><p>表 1.尺寸参数设计</p><p>计算驱动力矩和旋转刚度时,保守估计,选择 &lt;1,1,1&gt; 晶相的单晶硅，杨氏模量为 188.5 GPa。空气的介电常数为 8.854e-12,在 U&#x3D;50V 的条件下,计算得到电机的驱动力矩:</p><p>$$<br>M &#x3D; 1.2285 ×10^{-8}Nm &#x3D;12.285nNm <br>$$</p><p>挠性枢轴的旋转刚度：</p><p>$$<br>I &#x3D; 8.3250×10^{-23}<br>$$</p><p>$$<br>K_{\theta\vert\otimes } &#x3D; 6.0809 × 10^{-11} N&#x2F;rad &#x3D; 0.06nN&#x2F;rad<br>$$</p><p>设计的理论指标可以满足要求，枢轴旋转刚度对电电机驱动能力的影响较小，能够完成设计的行程。需要注意的是，设计时的数学建模都是简化模型，实际的驱动能力还需要实验测量。本章计算没有考虑梁的最大弯曲应变，但参考文献[4]中基于材料屈服应变计算得到最大弯曲角度有较多冗余。</p><p>接下来，将构建静电力驱动型电机的等效电路模型可变电容等效模型。将机械部分（包括转子和定子）建模为旋转系统，可以使用旋转惯量 J，机械阻尼 B 和和旋转刚度 Kθ 来描述旋转系统的动态行为。在转动机械系统中，力矩定义为广义电压，角速度定义为广义电流，转动惯量定义为广义电感，旋转刚度定义为广义电容。电力部分包括了静电力驱动和旋转电机所消耗的功率等，得到的等效电路模型如图 6 所示。</p><p><img src="/img/UhvAbwvYwo3ynnxZkBKcwb1Bnkc.png"></p><p>图 6.所设计系统的等效电路模型</p><p>对于静电力驱动，参考式(2)，可以得到：</p><p>$$<br>\frac{n \varepsilon LU^{2}r}{2g} &#x3D; J \ddot{\theta}+B\dot{\theta}+K_{\theta}\theta \tag{6}<br>$$</p><p>至此，我们给出了所设计的基于可变电容原理的静电电机由电压驱动转子旋转的模型。</p><h2 id="Fabrication"><a href="#Fabrication" class="headerlink" title="Fabrication"></a>Fabrication</h2><p>在本节中，我们将讨论所设计结构的具体加工步骤。得益于选择枢轴的平面单体制造特性，我们可以在一次光刻-刻蚀中加工出如图(4)所示的平面结构。但是在加工具体定子-转子结构之前，我们还需要考虑有序分布的三相电极如何加工，以及如何得到足够高度的平面结构。由式(2)可以看到，静电电机的驱动能力和切向的电容宽度无关，而和电机高度 L 成正比。为了获得尽可能大的驱动力矩，我们希望制造具有高纵横比的电极。使用成膜的方法制造高纵横比电极是比较困难的，一般的做法是使用掺杂的硅基体作为电极的材料，通过刻蚀形成电极图案。</p><p>在有序分布的三相电极制备中，可以使用垂直沟槽隔离技术[7]。该技术是一种用于制造微电子器件的工艺技术，可以在单晶硅晶片上创建具有高纵横比极和集成电气网络的单片式步进电机。该技术基于 SOI、表面或体积微加工，利用填充有绝缘材料的沟槽来在单个器件层中创建机械连接组件之间的电气隔离。它可以实现高纵横比单晶硅元件的制造，并与集成的三相电气网络结合使用。</p><p>图 7 显示了垂直沟槽隔离工艺下定子的布局，并说明了绝缘沟是如何与导线结合以获得三相电网络所需的三级交叉连接的。我们把硅体作为一个大的导体，然后插入一系列垂直沟槽把它们分为 3n 个独立的电极。下一步，通过三个带有导体通孔的绝缘体带附着在分离电极的表面，并循环布置通孔作为电极连接。如图 7（a）中所示，每个定子电极（白色部分）都被绝缘沟槽（灰色部分）所包围，因此它与主体和其他磁极之间是电气绝缘的。在电绝缘的同时，每个电极仍然嵌入在硅体中，因此机械完整性得到了保留。为了将定子磁极连接到其中一个相位，采用了一种导电互连，通过蚀刻在电介质层上的通孔进入磁极。</p><p>图 7. 使用垂直沟槽隔离技术在硅片制作定子电极的示意图。(a)定子的顶部和(b)横截面显示了垂直沟槽隔离和互连的布局。(c)是加工出的定子结构的扫描电镜图。</p><p>在材料的选择中，互联层和沟槽填充层使用是多晶硅，绝缘层使用的是氧化硅。整体的工艺流程如图 8 所示，在之后我们会详细介绍从（a）到（h）的详细步骤。</p><p><img src="/img/F4s7bETiGoVlOux4cwJcncOLngg.png"></p><p>图 7. 使用垂直沟槽隔离技术在硅片制作定子电极的示意图。(a)定子的顶部和(b)横截面显示了垂直沟槽隔离和互连的布局。(c)是加工出的定子结构的扫描电镜图。</p><ul><li>A 备片，清洗，掺杂</li></ul><p>在一个 200 微米厚的标准硅片上进行加工，首先进行清洗。随后进行了掺杂，使用磷富含的旋涂玻璃（SOG）对多晶硅层进行掺杂，这种掺杂方法被称为“磷摻杂”，它可以增加多晶硅层的导电性能。</p><ul><li>B 垂直沟槽刻蚀 ，光刻（1#）</li></ul><p>在这一步，我们使用显示沟槽的掩模版，进行。通过深反应离子蚀刻（Deep Reactive Ion Etching，DRIE）来蚀刻垂直沟槽。DRIE 是一种高精度、高效率的微纳加工技术，可以用于制造微电子器件中的沟槽、孔洞等结构，该技术利用高能离子束和化学反应来实现对硅晶片的刻蚀，具有刻蚀速率快、精度高等优点。完成刻蚀后除胶。</p><ul><li>C 沟槽填充</li></ul><p>沟槽的宽度为 2μm，深 40μm（和电极的高度相同）。通过低压化学气相沉积（LPCVD）将多晶硅完全重新填充氧化硅和未掺杂多晶硅的组合。</p><ul><li>D 沟槽顶层剥离</li></ul><p>分别通过 TMAH 和氢氟酸和氢氧化铵混合物（Buffered Hydrofluoric Acid，BHF）溶液的湿化学蚀刻从晶片上表面去除多晶硅和氧化硅。BHF 是一种化学蚀刻液，其全称为。它主要用于蚀刻硅和氧化硅等材料。BHF 的优点是可以高效地去除硅和氧化硅，并且不会对其他材料产生太大的影响。</p><ul><li>E 绝缘体沉积和连接孔蚀刻，光刻（2#）</li></ul><p>这一步，我们使用显示连接过孔的掩模版，进行涂胶，光刻，刻蚀，除胶。首先在晶圆上通过湿氧化法生长一个 300 纳米厚的氧化硅层，然后进行甩胶、光刻，再使用 BHF 蚀刻法刻蚀电气通孔。</p><ul><li>F 电极层沉积，光刻（3#）</li></ul><p>在这一步中使用顶层电极形状的掩模版，制备顶层的电极形状。首先我们通过 LPCVD 沉积一个 1 微米厚的多晶层，并使用 SOG 进行掺杂。然后，甩胶、光刻，通过 ICP-RIE 蚀刻多晶硅，然后用 BHF 蚀刻氧化硅来形成互连。如图 7 所示，顶层的多晶硅电层为被垂直沟槽隔离的硅区域之间提供电连接，实现有规划的三相电极分布。</p><ul><li>G  背部硅刻蚀，光刻（4#）</li></ul><p>这一步中我们进行“背掏”工艺，生成可动 MEMS 器件的悬架结构。我们从背部进行 ICP 蚀刻，首先在硅片背面甩胶、光刻，在把需要“悬空”的部分进行刻蚀。在这一步中我们需要严格控制刻蚀的深度，因为留下的部分即为电极的高度。</p><ul><li>H 器件结构刻蚀，光刻（5#）</li></ul><p>在最后的制造步骤中，我们根据图 4 所设计的平面微机械绘制相应的掩模版，进行最后的图案转移。甩胶、光刻，通过 DRIE 在硅膜上进行蚀刻。</p><h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>静电驱动型选择电机的旋转速度与驱动信号的频率直接相关，从理论上速度随着循环频率的增加而线性增加。然而，我们从公式（6）中我们可以观察到转子的转动惯量和系统阻尼会阻碍电极的高速转动。步进电机实际的高频失效表现是：在高驱动频率下，以半步进模式运行的电机显示出漏步或卡顿等不正常运行。另一方面，由于方波激励所固有的驱动力矩的突然变化，快速地将转子从一个位置扣到另一个位置，在公式（6）中表现为角加速度和角速度很大，这显然会影响驱动效果。我们可以通过微步进电平的方式来减小这种影响，如图 8 所示，更平滑的电平变化可以减小驱动需要的电压值。</p><p><img src="/img/Kgp0bvcFNoCFbIxK76pcab2In9e.png"></p><p>图 8.微步进电压序列，以得到更平稳的步进过程。</p><p>在考虑驱动模式的同时，我们需要注意到转子的刚度影响不仅仅在于抵抗静电力的驱动：当静电驱动扭矩将转子从一个稳定的位置向外移动到另一个位置时，挠性体的机械刚度会抵消其运动并使转子减速。然而，当转子向其静止位置移动时，机械恢复力在同一方向上发挥作用，进一步加速转子，使其更容易跳步。所以在恢复的情况下，机械恢复力可用于在两个位置之间移动转子，而驱动扭矩将用于减速转子的运动，这将使电机的运行更加稳定。</p><p>最后，因为时间原因，本文没有进行三维有限元建模分析的工作。通过有限元模型，我们或许可以估计出运行过程中的旋转中心偏移，枢轴更准确的转动刚度和转子的转动惯量。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>本文介绍了一种采用“蝴蝶形”挠性悬挂枢轴的三相静电 MEMS 旋转电机的设计、建模和制备工艺。该电机具有精确、可重复和可靠的双向步进运动，可用于驱动微泵、微阀或微型镜片等设备。通过数学建模，我们证明了该电机在 50V 驱动电压下最大能输出 12.5mNm 的扭矩，满足了 2mNm 以上输出力矩和 50V 以下驱动电压的要求。此外，我们还分析了该电机结构设计中的参数和驱动电压对性能影响的规律，并提出了优化方案。总之，本文基于静电 MEMS 旋转电机领域给出了一些基础的研究方法与思路，具有一定的理论和应用价值。</p><h2 id="Acknowledgment"><a href="#Acknowledgment" class="headerlink" title="Acknowledgment"></a>Acknowledgment</h2><p>本文的动力来源于《微系统设计与系统集成技术》课程大作业。本文的结构设计主要参考自文献[4]和文献[6],关于挠性枢轴的旋转刚度建模主要参考自文献[4]。制备工艺主要参考自文献[3]和文献[7]。</p><h2 id="Citations"><a href="#Citations" class="headerlink" title="Citations"></a>Citations</h2><p>[1] C. Livermore, A. R. Forte, T. Lyszczarz, S. D. Umans, A. A. Ayon and J. H. Lang, “A high-power MEMS electric induction motor,” in Journal of Microelectromechanical Systems, vol. 13, no. 3, pp. 465-471, June 2004</p><p>[2] M. Takato, Y. Yokozeki, K. Mishima, Y. Han, K. Saito and F. Uchikoba, “Design of electromagnetic induction type MEMS motor with multilayer ceramic three-dimensional coil,” 2016 International Conference on Electronics Packaging (ICEP), Hokkaido, Japan, 2016</p><p>[3] S. Merzaghi, C. Koechli and Y. Perriard, “Development of a Hybrid MEMS BLDC Micromotor,” in IEEE Transactions on Industry Applications, vol. 47, no. 1, pp. 3-11, Jan.-Feb. 2011</p><p>[4]E. Sarajlic, C. Yamahata, M. Cordero and H. Fujita, “Three-Phase Electrostatic Rotary Stepper Micromotor With a Flexural Pivot Bearing,” in Journal of Microelectromechanical Systems, vol. 19, no. 2, pp. 338-349, April 2010</p><p>[5]  A. S. Algamili, M. H. M. Khir, J. O. Dennis and N. A. M. Amin, “A Review of Actuation and Sensing Mechanisms in MEMS-Based Sensor Devices,” Nanoscale Research Letters, vol. 16, no. 1, pp. 1-16, Jan. 2021.</p><p>[6] S. Henein, P. Spanoudakis, S. Droz, L. I. Myklebust and E. Onillon, “Flexure pivot for aerospace mechanisms”, Proc. 10th ESMATSESA SP, pp. 285-288, 2003.</p><p>[7] E. Sarajlic, C. Yamahata, M. Cordero and H. Fujita, “An electrostatic 3-phase linear stepper motor fabricated by vertical trench isolation technology”, J. Micromech. Microeng., vol. 19, no. 7, pp. 074001-1-074001-7, Jul. 2009.</p><p>[8] W. Gao, S. Sattayasamitsathit and J. Wang, “Fabrication of Micro&#x2F;Nanoscale Motors,” Chemical Reviews, vol. 115, no. 16, pp. 8704-8735, Aug. 2015.</p>]]></content>
    
    
    
    <tags>
      
      <tag>IOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【文献学习】TMR-隧道磁阻效应</title>
    <link href="/2023/04/18/%E3%80%90%E6%96%87%E7%8C%AE%E5%AD%A6%E4%B9%A0%E3%80%91TMR-%E9%9A%A7%E9%81%93%E7%A3%81%E9%98%BB%E6%95%88%E5%BA%94/"/>
    <url>/2023/04/18/%E3%80%90%E6%96%87%E7%8C%AE%E5%AD%A6%E4%B9%A0%E3%80%91TMR-%E9%9A%A7%E9%81%93%E7%A3%81%E9%98%BB%E6%95%88%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="TMR-隧穿磁阻效应-最新研究进展"><a href="#TMR-隧穿磁阻效应-最新研究进展" class="headerlink" title="TMR-隧穿磁阻效应-最新研究进展"></a>TMR-隧穿磁阻效应-最新研究进展</h1><h2 id="1-TMR-技术简介"><a href="#1-TMR-技术简介" class="headerlink" title="1.TMR 技术简介"></a>1.TMR 技术简介</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>铁磁薄片的磁化方向可以在外磁场的控制下被独立的切换。如果极化方向平行，那么电子隧穿过绝缘层的可能性会更大，其宏观表现为电阻小；如果极化方向反平行，那么电子隧穿过绝缘层的可能性较小，其宏观表现是电阻极大。</p><p><img src="/img/Vl9EbewUioN5pIxNJmtcjqUvnPd.png"></p><p><em>Yaodi Yang, Shaohua Yan, and Xiaobo Sharon Hu, “Developments and Applications of Tunneling Magnetoresistance Sensors,” Tsinghua Science and Technology, vol. 27, no. 3, pp. 443-454, June 2022.</em></p><p>GMR 是利用非磁性体的金属层 (Cu 等)被两层強磁性体夹住，而 TMR 是利用非磁性体的绝缘层 (Al2O3 等)被两层強磁性体夹住。GMR 和 TMR 的电阻变化率都比 AMR 高，但 TMR 比 GMR 更高，可以达到 100% 以上。TMR 相比 GMR 具有更高的温度稳定性、更低的功耗、更小的尺寸等优点。</p><p><a href="https://www.jstage.jst.go.jp/article/butsuri/65/5/65_KJ00006254747/_article/-char/ja/">TMR 和 GMR 的中间插入层的区别主要在于它们的电子输运机制</a><a href="https://www.jstage.jst.go.jp/article/butsuri/65/5/65_KJ00006254747/_article/-char/ja/">(1)</a><a href="https://www.sekorm.com/news/8718.html">(2)</a>：</p><ul><li>TMR 是指隧道磁电阻效应，它利用的是磁性多层膜材料的隧道磁电阻效应对磁场进行感应，其中间插入层是一层非磁性绝缘层，如氧化铝或氧化镁。当电子从一个铁磁层穿过绝缘层到另一个铁磁层时，会受到两个铁磁层的自旋极化的影响，从而导致电阻变化。当两个铁磁层的自旋极化同向时，电阻最小；当两个铁磁层的自旋极化反向时，电阻最大。</li><li>GMR 是指巨大磁电阻效应，它利用的是金属多层膜材料的巨大磁电阻效应对磁场进行感应，其中间插入层是一层非磁性金属层，如铜或银。当电子从一个铁磁层穿过金属层到另一个铁磁层时，会受到两个铁磁层的自旋散射的影响，从而导致电阻变化。当两个铁磁层的自旋平行时，电阻最小；当两个铁磁层的自旋反平行时，电阻最大。</li></ul><p>TMR 中的量子隧穿效应：</p><p>量子隧穿效应是一种量子力学现象，它指的是像电子等微观粒子能够穿过它们本来无法通过的“墙壁”的现象，又称势垒贯穿。对于能量势垒，按经典力学的观点，粒子需先像爬山一样翻过山顶再到山脚，如果能量势垒比粒子本身的能量高，则粒子无法通过；按量子力学的观点，只要势垒的能量不是无穷高，即只要山不是无限高无限厚，粒子就有概率可以穿透这道势垒，就像是有一条直达的隧道一样。</p><p>粒子穿过势垒并出现在经典力学禁阻区域的过程。当一个电子通过由金属层&#x2F;绝缘层&#x2F;金属层构成的三明治薄膜，绝缘层就形成一个势垒很高的势阱。电子具有波粒二象性，电子的运动可以用波函数表征。量子力学对这种情况的分析表明，电子能以一定的几率通过隧道效应而穿过势垒，逃出势阱。穿过势垒的几率是由波函数在势阱的两壁上必需连续这个条件决定的。当电子通过第一个金属&#x2F;绝缘体的界面时，在绝缘体内波函数较快地衰减，如果绝缘层足够薄，即势垒薄，电子通过绝缘层到达第二个绝缘体&#x2F;金属界面时波函数没有衰减到零，那么在第二个金属薄膜中发射电子的几率不是零，即电子穿越了势垒。</p><h3 id="TMR-现象"><a href="#TMR-现象" class="headerlink" title="TMR 现象"></a>TMR 现象</h3><p><img src="/img/VnEdbACB9oWohKxkh8gcmBAZnKc.png"></p><p><a href="https://en.wikipedia.org/wiki/Tunnel_magnetoresistance">Wiki:</a></p><p>Tunnel magnetoresistance (TMR) is a magnetoresistive effect that occurs in a magnetic tunnel junction (MTJ), which is a component consisting of two ferromagnets separated by a thin insulator. If the insulating layer is thin enough (typically a few nanometres), electrons can tunnel from one ferromagnet into the other. Since this process is forbidden in classical physics, tunnel magnetoresistance is a strictly quantum mechanical phenomenon.</p><p><img src="/img/YcWgbh8bEoSMblxgxUZcQ500nnd.png"></p><p>隧穿电导随着两铁磁层磁化方向的改变而变化，磁化矢量平行时的电阻低于反平行时的电阻。通过施加外磁场可以改变两铁磁层的磁化方向，从而使得隧穿电阻发生变化，导致 TMR 效应的出现。</p><p>传感器电路初级一般是全桥方案</p><p><img src="/img/Ryp3bLk0MoxMFgxIOMTcYDEUnRg.png"></p><h3 id="应用-存储"><a href="#应用-存储" class="headerlink" title="应用-存储"></a>应用-存储</h3><p>大容量存储介质–机械硬盘 和 SSD</p><p>机械硬盘也叫磁盘，但是磁盘读写头主要使用的是 GMR，TMR 也有用，但是比较少。</p><p>TMR 的灵敏度更高，功耗更小。但是读写头更改存储状态是使用 TMR 饱和状态测量的，这对读取单元的精度要求也更高，同时也提高了“不稳定性”和 volatile。硬盘追求的是速度、容量、稳定性和 non-volatile</p><p>硬盘的磁头如何读取数据？</p><p>硬盘磁头读取数据的原理是基于磁性媒介。硬盘盘片表面有许多微小的磁性颗粒，它们可以被物理上改变磁极性。当要写入数据时，磁振荡将影响磁性颗粒并使它们产生相应的极性。磁头上的读取器会检测这些极性变化，从而读取并解读出 01 数据信号。数据的读取过程中，磁头将自己靠近盘片，然后检测盘片表面的每一个磁性颗粒的磁极性。</p><p>它是如何检测每一颗磁性颗粒的磁极性的？</p><p>硬盘磁头检测每一个磁性颗粒的磁极性的方法主要是基于磁电阻的原理，并使用了磁电阻效应。磁电阻检测技术可以很灵敏地检测到磁颗粒的微小磁性变化并将其转化为对应的信号，通过信号放大、滤波等过程就可以正确地解读出数据信息。</p><p>你刚刚说”磁性颗粒大小远大于量子隧穿跨越的尺度“那么磁盘磁场变化大概是什么量级，量子隧穿磁阻效应敏感的磁场大概在什么量级？nT pT 还是 uT？</p><p>硬盘磁场的变化的量级通常在微特斯拉（μT）到毫特斯拉（mT）之间，同时磁性颗粒的尺寸也在纳米级别左右。而量子隧穿效应以及磁电阻效应通常对于磁场的强度要求比较低，大约在纳特斯拉至微特斯拉（nT-μT）的范围内。</p><p><a href="https://zh.wikipedia.org/wiki/%E5%B7%A8%E7%A3%81%E9%98%BB%E6%95%88%E5%BA%94">PMR 垂直磁记录是通过巨磁阻效应（GMR）来读出磁性的。巨磁阻效应是指物质在一定磁场下电阻改变的现象。当两层磁性材料之间夹有一层非磁性材料时，如果两层磁性材料的磁化方向平行，那么电阻较小；如果两层磁性材料的磁化方向反平行，那么电阻较大。</a></p><p>SSD 目前主要的方案还是浮栅晶体管：</p><p>基于量子隧穿的闪存芯片利用量子隧穿效应来存储数据。量子隧穿效应是指粒子即使没有足够的能量来克服势垒也可以通过势垒的现象。在闪存芯片中，电子隧道穿过薄氧化层到达浮栅，浮栅存储电荷。</p><p><img src="/img/JySkbVmfToFe6hxGcLLcm4NKndl.png"></p><p><img src="/img/GtPSb7VkgoPjlAxANZYcN6iPntJ.png"></p><p><img src="/img/RWtKbhol5oMProxFcBpcWf9YnFe.png"></p><p>通过给多晶硅导体注入电子(WRITE)，控制弱电势（READ）下的 01 状态。注入的原理是量子隧穿。微观尺度下量子的位置和动量不确定。只要势垒不是太高，总有概率穿过。绝缘层太薄不能长期保存，太厚不易写入。写入方式有两种：在置 0 的时候，在源极漏极加大电压，让热电子进入绝缘栅，置 1 则反向置位；另一种方法是在栅极加高压-FN 隧穿，置 0 或 1。</p><p>热电子注入是指当在漏和栅极上同时加高电压时，沟道中的电子获得很高的能量，并在栅极电场的吸引下，跃过氧化层电子势垒，形成热电子注入。F-N 隧道效应是指根据量子力学理论，电子有几率可以隧穿比本身能量高的势垒。隧穿的几率严重依赖势垒的高度与宽度，在存储器中，这个势垒就是介电层。</p><p>这两种现象都在闪存的工作原理中有应用，例如 NOR 型闪存通过热电子注入方式给浮栅充电，而 NAND 型闪存通过 F-N 隧道效应给浮栅充电。</p><p>晶体管平面-&gt;page-&gt;block-&gt;die-&gt;flash chip。</p><p>图右下是多态管，可以简要理解为一个一个晶体管存储多种状态，提高存储效率。目前高端、大容量的设备基本都是一个晶体管存多 bit 数据了。详情可以见硬件茶谈的<a href="https://www.bilibili.com/video/BV1aF411u7Ct/?spm_id_from=333.999.0.0&vd_source=780d24dc66c0ccace4122aa4edfd6aac">科普视频</a></p><p><img src="/img/MJMzbXPEEoMFMvxLBgDcPQFnnvi.png"></p><p>MLC 和 TLC 是两种不同的闪存技术，它们的原理是利用不同的电压水平来存储多个 bit 的信息。</p><ul><li>MLC 是 Multi Level Cell 的缩写，意思是多级单元，它可以在一个浮动栅中存储 2 个 bit 的信息，有 4 种不同的电压水平，分别对应 00、01、10、11 这四种状态。</li><li>TLC 是 Triple Level Cell 的缩写，意思是三级单元，它可以在一个浮动栅中存储 3 个 bit 的信息，有 8 种不同的电压水平，分别对应 000、001、010、011、100、101、110、111 这八种状态。</li></ul><p>MLC 和 TLC 相比于 SLC（单级单元，只存储 1 个 bit 的信息），都可以提高闪存的容量和降低成本，但是也会降低写入速度和寿命，因为电压水平之间的差异更小，更容易出现误差。</p><p>NVMe 和 SATA 是<strong>不同的硬盘接口和协议。</strong>NVMe 是为固态硬盘设计的逻辑设备接口规范，利用 PCIe 通道直接连接 CPU，提高带宽和降低延迟。SATA 是一种物理接口类型，执行的 AHCI 协议是为机械硬盘设计的，有 6Gbps 的读写限制，需要接口控制器。NVMe 和 SATA 的物理表现形式可以是 M.2+PCIe，U.2&#x2F;U.3+PCIe，或者 SATA 插槽。pcie 是一种高速接口，可以让固态硬盘直接连接到主板上，而不需要经过 sata 或其他控制器，从而提高数据传输速度和降低延迟。</p><p>slc cache 是一种利用单层单元（slc）闪存作为缓存的技术，可以让固态硬盘在写入数据时先写入 slc 区域，然后再慢慢转移到多层单元（mlc、tlc、qlc）闪存中，从而提高写入速度。</p><p><a href="https://zhuanlan.zhihu.com/p/344174968">知乎：Nand Flash 和 Nor Flash 的区别</a></p><p>1、NOR 的读速度比 NAND 稍快一些。NAND flash 需要按块进行读取数据，而 NOR flash 可以随机按字节读取数据。<br>2、NAND 的写入速度比 NOR 快很多。NAND 的擦除速度远比 NOR 快。</p><p>3、NOR flash 可以在片内运行程，不必再把代码读到系统 RAM 中。</p><p>4、NAND flash 适合于数据存储，NOR flash 适合于代码存储。</p><p>基于 TMR 原理生产的存储介质是 MRAM(magnet random access memory)。它既可以做计算机的内存 RAM，也可以做外存储器。</p><p><a href="https://www.chinastor.com/jishu/MRAM.html">基本原理</a>：</p><p>电子像一个小磁体一样在不断地旋转着，称这种运动为自旋。根据旋转方向可分为向上与向下两种自旋方向。自旋磁电阻就是一个存储单元，它是一些特殊的小点，拥有特殊的三明治结构，上下层为引发电子自旋、产生磁场的磁性层，中间为担负产生磁阻变化的非磁性层。由于电子自旋态的不同而产生磁场的性质差异，在不同的磁场下中间层的电阻也就不同，从而使通过的电流强度不同，电路再通过强度来控制或判断出是“0”还是“1”。 MRAM 是以磁电阻性质储存记录资料的随机存储器，采用磁化方向的不同来记录“0”与“1”。只要外在磁场不改变，磁化的方向就不会变更，不像 DRAM 为了要保持资料需让电流不断流动，MRAM 也不需 refresh 的动作。其优点为写入与读取时间的速度上可与 SRAM 媲美，同时在记忆容量上可与 DRAM 相抗衡。</p><p>磁性随机存取存储器 (MRAM) ，虽然叫 RAM，但其实是一种非易失性存储器，它使用磁荷而不是电荷来存储数据。它基于磁阻现象，即当施加外部磁场时材料电阻的变化。基于 TMR 效应制作的 MRAM 是指利用隧道磁阻（TMR）效应读写数据的 MRAM。</p><p>与 DRAM 相比，MRAM 的优势：高速、低功耗和高耐用性、长时间数据保留、可以在极端温度下运行。</p><p>劣势：工艺不够成熟、控制方法不够成熟。典型 MTJ 支持的最小平面尺寸是 90–130 nm，二浮栅晶体管特征尺寸已经到 10nm 内了。</p><p>MRAM 最大的特点就是掉电存储。闪存 flash 可用作一种非易失性 RAM (NVRAM)，但是 flash RAM 读写很慢，并且写周期数有限。大容量存储主要还是 SSD 和机械硬盘，它们都无法掉电存储。MRAM 芯片可以在断电的情况下依靠磁性的极性来保存数据， 用 MRAM 替代 DRAM 以后，或许可以实现一按开关机器就立刻运行起来，并进入到就绪状态。</p><p>一篇关于存储的文章：</p><p>*Efficient and Highly Reliable Spintronic Non-volatile Quaternary Memory Based on Carbon Nanotube FETs and Multi-TMR MTJs,” <strong>ECS</strong> Journal of Solid State Science and Technology, vol. 11, no. 6, p. *<em>061007, 2022</em></p><p>由于传统二进制电路的局限性，例如高功耗和大面积以及互连密度，多值逻辑（MVL）被提供作为解决方案。四元逻辑是一种与二进制系统高度兼容的 MVL 形式。本文提出了一种低成本且高度可靠的非易失性四元存储器，受益于环栅碳纳米管场效应晶体管 (GAA-CNTFET) 的可调阈值电压特性和磁隧道结 (MTJ) 的非易失性.所提出的四进制存储器占用更少的面积并且消耗更低的功率。仿真结果表明，所提出的设计可将平均功耗、静态功耗和写入功耗降低多达 53%、41% 和 69%。此外，它的读取功率延迟积 (PDP) 和写入 PDP 分别降低了 47% 和 34%。所提出的锁存器占用的面积也比最先进的非易失性四进制存储器(MLC flash nvs)低 23%。</p><h3 id="应用-微磁传感器"><a href="#应用-微磁传感器" class="headerlink" title="应用-微磁传感器"></a>应用-微磁传感器</h3><p>微型电流检测、人体磁场检测。最大的优点是灵敏度很高，作为 MR 传感器磁阻变化率很大，结构也不算复杂。</p><p><img src="/img/YJbGbXNHboP5kvxZsehcwYnZnib.png"></p><p><img src="/img/Knsrbu3BDonz6ex0OzocZfMVnGh.png"></p><p>总之是一个高灵敏度、低功耗的磁传感器</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>作为传感器：</p><p>优点：高灵敏度、低功耗、易实现三轴测量、相较于 AMR,GMR 温度稳定性更好</p><p>缺点：本底噪声大；多层膜结构薄膜电阻工艺 温漂严重</p><p>作为存储介质：</p><p>优点：RAM&amp;FLASH 统一，对于 DRAM 而言具有非易失性，同时速度较快，功耗小。对于 flash 而言，速度快，几乎没有寿命损耗。</p><p>缺点：典型 MTJ 支持的最小平面尺寸是 90–130 nm，同样芯片体积下存储空间小。工艺、控制方法不够成熟，贵。</p><h2 id="2-最新的研究进展"><a href="#2-最新的研究进展" class="headerlink" title="2.最新的研究进展"></a>2.最新的研究进展</h2><h3 id="原理、原型"><a href="#原理、原型" class="headerlink" title="原理、原型"></a>原理、原型</h3><p>偏理论的、基于 TMR 原理级的研究，或是提出了新的 TMR 原型</p><p><em>L. Šmejkal, A. Birk Hellenes, R. González-Hernández, J. Sinova, and T. Jungwirth, “Giant and Tunneling Magnetoresistance in Unconventional Collinear Antiferromagnets with Nonrelativistic Spin-Momentum <strong>Coupling</strong>,” Phys. Rev. X, vol. 12, no. 1, p. 011028, Feb. 2022.</em></p><p>本文提出了一种新型的自旋电子学概念，即在非相对论性反铁磁体系中实现巨磁电阻和隧道磁电阻效应。这些效应依赖于参考和感应铁磁电极之间传递的守恒自旋电流。最近，我们提出了这些基本自旋电子学效应可以在非常规的共线反铁磁体系中实现，其中具有非相对论性交替自旋动量耦合。在这里，我们通过提出具有这些非常规共线反铁磁体系的多层结构中巨磁电阻和隧道磁电阻效应的原型模型机制来详细阐述这一提议。这些模型分别基于交替自旋动量耦合的各向异性和谷相关形式。使用第一性原理计算，我们将这些模型机制与真实材料联系起来，并预测了效应的大约 100% 的比例。我们指出，除了巨磁或隧道磁电阻检测外，交替自旋动量耦合还可以通过自旋转移扭矩实现磁激发。</p><p><img src="/img/IJRnbUoZSokcIkxE0lacAdiLnZc.png"></p><p>非常规反铁磁铁中的 GMR 和 TMR 模型机制。红色和蓝色分别对应于上下自旋，灰色箭头标记了施加的电流方向。 （a）在平面上几何形状中带有金属垫片的 GMR 堆栈。 （b）能量带切断了围绕布里鲁因区域的 γ 点周围的各向异性交替自旋摩孔耦合，从而导致各向异性自旋依赖性电导率。 （c）紧密结合模型带分散。虚线的矩形突出了该区域，各向异性自旋摩孔在 γ 点上耦合。 （d）带有绝缘屏障的 TMR 堆栈。例如，我们显示了两个电极中 NéelVector 的并行配置。 （e）能量带切断了依赖山谷的交替自旋摩托孔偶联，围绕 M1 和 M2 点，导致山谷和旋转状态的密度。 （f）紧密结合模型带分散。虚线的矩形以相反的旋转分裂突出显示了山谷，标有洋红色箭头。</p><p>主要结论：在具有非相对论性自旋-动量耦合的非常规共线抗铁磁体中，可以实现巨磁阻和隧道磁阻效应，这些效应不依赖于自旋流的守恒。这些效应的物理机制是：在反铁磁体中，自旋极化的电子可以通过交错的自旋纹理隧穿，从而导致电阻的变化。</p><p>unconventional antiferromagnets 是一种特殊的反铁磁材料，它们具有与铁磁材料类似的自旋依赖的输运效应，对于自旋电子学器件的信息读出非常重要。自旋依赖的输运效应是指电子在材料中运动时，其电流和电阻等物理量与其自旋方向有关的现象。例如，当电子通过一个磁性材料时，其自旋会受到磁场的影响，导致不同自旋方向的电子有不同的输运特性，这就是磁阻效应。</p><ul><li>这些效应为设计新型的基于反铁磁体的自旋电子器件提供了新的思路和可能性。</li><li>这些效应可以在室温下实现，且不受外界磁场的影响，因此具有较高的稳定性和可靠性。</li><li>这些效应可以用于实现高密度、低功耗、快速切换的数据存储和逻辑运算。</li></ul><p><em>L. Zhang, Y. Zhang, J. Li, Y. Wang, and H. Zeng, “Transport properties of tunneling magnetoresistance sensors based on double indirect exchange <strong>coupling</strong> effect,” Journal of Magnetism and Magnetic Materials, vol. 500, p. 166382, 2020.</em></p><p>研究了基于双间接交换耦合效应的隧道磁阻 (TMR) 传感器的传输特性。在磁隧道结中获得了大约 150% 的 TMR rate，并且成功地实现了对面内磁场的线性响应。由于设计了 CoFeB&#x2F;NiFe&#x2F;Ru&#x2F;IrMn 传感层，实现了 1.85%&#x2F;Oe 的高灵敏度。此外，全惠斯通电桥配置的电压输出灵敏度和噪声水平分别为 10.7 mV&#x2F;V&#x2F;Oe、1 Hz 时 10 nT&#x2F;Hz$^{1&#x2F;2}$ 和 10 Hz 时 3.3 nT&#x2F;Hz$^{1&#x2F;2}$。这种磁传感器可用于智能电网领域、电流检测和传感。</p><p>双间接交换耦合效应是隧道磁阻 (TMR) 传感器中出现的一种现象。 它是指磁隧道结 (MTJ) 中两个铁磁层之间通过反磁性层的耦合。 双间接交换耦合效应可用于在 TMR 传感器 中实现对面内磁场的线性响应。（它允许 TMR 传感器以线性响应检测平行于传感器平面，并且是线性的）CoFeB&#x2F;NiFe&#x2F;Ru&#x2F;IrMn 多层薄膜结构中，CoFeB 和 NiFe 是铁磁性层，它们具有较高的饱和磁化强度和磁隧道效应。Ru 是非磁性层，它用于分隔两个铁磁性层，形成双间接交换耦合效应。IrMn 是反铁磁性层，它用于固定一个铁磁性层的磁化方向，形成直接交换耦合效应</p><p>铁磁性层和反铁磁性层：</p><p>铁磁性层和反铁磁性层的区别主要在于它们的原子磁矩的排列方式<a href="https://baike.baidu.com/item/%E5%B1%82%E9%97%B4%E8%80%A6%E5%90%88/22392618">(1)</a><a href="https://www.zhihu.com/question/337897711">(2)</a>：</p><ul><li>铁磁性层是指多层薄膜中具有铁磁性的层。在铁磁性物质内部，相邻原子的自旋磁矩趋于同向平行排列，这样就形成了一个净的磁矩，可以产生磁场。这种物质一般局限于铁、钴、镍等过渡金属元素。</li><li>反铁磁性层是指由两个或多个磁性层组成的结构，其中相邻的磁性层之间的交换耦合是反平行的，即它们的磁化方向相反。反铁磁性层可以通过改变非磁性层的厚度或材料来调节交换耦合强度和方向。在反铁磁性物质内部，相邻原子的自旋磁矩趋于反向平行排列，这样就抵消了彼此的磁矩，导致净的磁矩为零，不会产生磁场。这种物质比较不常见，大多数反铁磁性物质都是稀土元素或氧化物。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/386333986">在施加电流的时候，铁磁性层和反铁磁性层的表现也不同</a><a href="https://zhuanlan.zhihu.com/p/386333986">(3)</a>：</p><ul><li>铁磁性层在施加电流的时候，会受到电流产生的洛伦兹力的作用，从而改变其原子磁矩的方向，导致其净的磁场增强或减弱。</li><li>反铁磁性层在施加电流的时候，由于其净的磁场为零，不会受到洛伦兹力的影响，但是会受到电流产生的自旋转移力量（spin-transfer torque）的作用，从而改变其相邻原子间的自旋耦合强度，导致其反铁磁性增强或减弱。</li></ul><p>直接交换耦合和*indirect exchange *<em>coupling</em></p><ul><li>直接交换是由于相邻原子轨道的重叠而产生的磁性耦合，它只涉及相邻原子局域电子的波函数重叠。直接交换在多层薄膜中可以通过控制铁磁层的厚度和成分来调节，一般来说，铁磁层越厚，直接交换越强，铁磁层中含有过渡金属元素也有利于增强直接交换。</li><li>间接交换是由于非磁性介质层或反铁磁层对铁磁层的调节而产生的磁性耦合，它涉及相邻铁磁层之间的电子跃迁或反铁磁层对铁磁层的作用。间接交换在多层薄膜中可以通过控制非磁性介质层或反铁磁层的厚度和成分来调节，一般来说，非磁性介质层或反铁磁层越薄，间接交换越强，非磁性介质层或反铁磁层中含有稀土元素也有利于增强间接交换。</li></ul><p>器件性能指标：</p><p>噪声水平的单位是 mV&#x2F;V&#x2F;Oe，表示每个 Oe 的磁场强度变化引起的电压输出变化的百分比。这个单位反映了传感器的灵敏度和动态范围。</p><p>nT&#x2F;Hz$^{1&#x2F;2}$是磁场噪声密度的单位，表示每个 Hz 的频率带宽内的磁场噪声的均方根值。这个单位反映了传感器的噪声水平和信噪比。噪声是一个随机过程，它的功率谱密度是一个频率函数，表示每个 Hz 的频率带宽内的平均功率。为了得到噪声的均方根值，我们需要对功率谱密度进行积分，积分的结果是一个带有 sqrt(Hz)的单位</p><p><img src="/img/LXNnb8vH2oMunmxuDDJcK5iqnd9.png"></p><p><img src="/img/Xvbsbu4JtorcrXx3oD2cX0n2njd.png"></p><p>论文主要亮点：</p><ul><li>利用双间接交换耦合效应，实现了磁隧道结中的高 TMR 比率和对面内磁场的线性响应，提高了传感器的性能和稳定性。</li><li>设计了一种软固定传感层，利用 Ru 层的自旋阻挫效应，实现了高灵敏度和低饱和场。</li></ul><p>可能对后续研究和工程应用的影响：</p><ul><li>为基于 TMR 效应的磁传感器的设计和优化提供了一种新的思路和方法。</li><li>为智能电网领域的电流检测和传感提供了一种高性能、低成本、低功耗、易集成的磁传感器方案。为其他基于 TMR 效应的磁存储、磁逻辑、磁随机存取存储器等领域的发展提供了参考和启示。</li></ul><p>关于新型材料、结构的文章：</p><p><em>Z. Li, Y. Zhang, J. Wang and X. Zhang, “Giant tunneling magnetoresistance in two-dimensional transition metal carbides based magnetic tunnel junctions,” Nanoscale Advances, vol. 4, no. 1, pp. 218-225, <strong>Jan</strong>. 2022.</em></p><p>这篇文章研究了基于二维过渡金属碳化物（MXenes）的磁性隧道结（MTJs）的巨大隧穿磁电阻（TMR）效应。作者发现，通过调节 MXenes 的层数、外加电压和磁场，可以实现 TMR 效应的可调控和优化。所有构建的 MTJ 都可以保持超过 9 × 105% 的大隧道磁阻 (TMR) 比。这种基于二维材料的 MTJs 具有高自旋极化率、低界面散射和高结构稳定性等优点，对于未来的自旋电子学和磁性器件有重要的应用前景。</p><p><img src="/img/Hha2bJzuuo93KCxyX3Dc0r92n6c.png"></p><p>G_APC 和 G_PC 分别是 parallel configuration (PC) and antiparallel configuration (APC)  中的隧道阻力。1T-MoS2 作为电极，2H-MoS2 作为隧道势垒。</p><p>这篇文章的主要创新点：</p><ul><li>首次研究了基于二维过渡金属碳化物（MXenes）的磁性隧道结（MTJs）的电子输运性质，发现了巨大的隧穿磁电阻（TMR）效应。</li><li>系统地分析了 MXenes 的层数、外加电压和磁场对 TMR 效应的影响机制，发现了 TMR 效应的可调控和优化方法。</li><li>展示了 MXenes 具有高自旋极化率、低界面散射和高结构稳定性等优点，对于未来的自旋电子学和磁性器件有重要的应用前景。</li></ul><p>对后续研究以及工程应用的影响：</p><ul><li>为后续研究提供了一个新的平台和方法，可以利用二维材料的特性来设计和优化 MTJs 的性能和功能。</li><li>为工程应用提供了一种高效、灵活和稳定的 MTJs 方案，可以实现高速、低功耗和多功能的自旋电子学和磁性器件。</li></ul><ul><li>Y. Zhang, J. Wang, X. Li and Y. Liu, “Large Tunneling Magnetoresistance in van der Waals Ferromagnet&#x2F;Semiconductor Heterojunctions,” in Advanced Materials, vol. 34, no. 50, pp. 2104658, December 2022, <strong>doi</strong>: 10.1002&#x2F;adma.202104658.*</li></ul><p>该文章报道了全二维范德瓦尔斯垂直自旋阀器件，该器件将二维层状半导体 InSe 作为间隔物与二维层状铁磁金属 Fe3GeTe2 作为自旋注入和检测电极相结合。对于隧道器件，在 10 K 下施加 0.1 µA 的偏置电流时，可获得 41% 的大磁阻 (MR)，大约是金属器件 (3) 的三倍。</p><p><img src="/img/GOgwbGCkzoP9u3xWBhNc9Px9n5g.png"></p><p>使用了 2D van der Waals 垂直自旋阀器件，将 2D 层状半导体 InSe 作为隔离层，将 2D 层状铁磁金属 Fe3GeTe2 作为自旋注入和检测电极。他们观察到了两种不同的输运行为：隧道效应和金属效应。其中，隧道效应是由于在 Fe3GeTe2&#x2F;InSe 界面处形成了无针孔的隧道势垒，而金属效应则是由于 InSe 隔离层中存在针孔。此外，隧道器件表现出更低的工作偏置电流但更敏感的偏置电流依赖性。这些发现揭示了针孔在所有-2D van der Waals 铁磁&#x2F;半导体异质结器件的 MR 中的关键作用。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">[<span class="hljs-number">2</span>D van der Waals是指由两个或多个二维材料通过范德华力（van der Waals force）堆叠而成的异质结构。这种异质结构的特点是具有原子级别的平坦界面，且具有可调节性和灵活性。<br>](https:<span class="hljs-regexp">//</span>onlinelibrary.wiley.com<span class="hljs-regexp">/doi/</span>full<span class="hljs-regexp">/10.1002/</span>adfm.<span class="hljs-number">202104260</span>)[<span class="hljs-number">2</span>D范德华材料是指由弱的范德华力相互作用的单层或多层原子晶体构成的材料。这种材料具有许多独特的物理和化学性质，例如高强度、高导热性、高光电效应等](https:<span class="hljs-regexp">//</span>physicstoday.scitation.org<span class="hljs-regexp">/doi/</span><span class="hljs-number">10.1063</span><span class="hljs-regexp">/PT.3.3297)[。其中，一些2D范德华材料还具有磁性，例如CrI3、Fe3GeTe2等](https:/</span><span class="hljs-regexp">/iopscience.iop.org/</span>article<span class="hljs-regexp">/10.1088/</span><span class="hljs-number">0256</span>-<span class="hljs-number">307</span>X<span class="hljs-regexp">/40/</span><span class="hljs-number">5</span>/<span class="hljs-number">058501</span>)。在制备TMR多层薄膜时使用了<span class="hljs-number">2</span>D范德华材料，可能对薄膜的特性有以下影响：<br>[由于<span class="hljs-number">2</span>D范德华材料具有较低的界面粗糙度和较好的晶格匹配，可以减少界面散射和缺陷，从而提高TMR效应](https:<span class="hljs-regexp">//i</span>opscience.iop.org<span class="hljs-regexp">/article/</span><span class="hljs-number">10.1088</span><span class="hljs-regexp">/0256-307X/</span><span class="hljs-number">40</span><span class="hljs-regexp">/5/</span><span class="hljs-number">058501</span>)。<br>[由于<span class="hljs-number">2</span>D范德华材料具有较高的自旋极化率和较大的自旋轨道耦合，可以增强自旋过滤效应和自旋依赖隧穿效应，从而提高TMR效应](https:<span class="hljs-regexp">//i</span>opscience.iop.org<span class="hljs-regexp">/article/</span><span class="hljs-number">10.1088</span><span class="hljs-regexp">/0256-307X/</span><span class="hljs-number">40</span><span class="hljs-regexp">/5/</span><span class="hljs-number">058501</span>)。<br>[由于<span class="hljs-number">2</span>D范德华材料具有较强的光电响应和电场调控能力，可以实现对TMR效应的光电调制和电场调制，从而提高器件的功能性和灵活性](https:<span class="hljs-regexp">//i</span>opscience.iop.org<span class="hljs-regexp">/article/</span><span class="hljs-number">10.1088</span><span class="hljs-regexp">/0256-307X/</span><span class="hljs-number">40</span><span class="hljs-regexp">/5/</span><span class="hljs-number">058501</span>)。<br><br></code></pre></td></tr></table></figure><p>文章的主要结论是：利用二维层状半导体 InSe 作为隧道层，二维层状铁磁金属 Fe3GeTe2 作为自旋注入和检测电极，实现了全二维范德华垂直自旋阀器件。这种器件在 10 K 下施加 0.1 µA 的偏置电流时，可获得 41% 的大磁阻 (MR)，比金属器件高出三倍。此外，这种器件还具有较低的工作偏压电流和较敏感的偏压电流依赖性。</p><p>Here, all-2D van der Waals vertical spin-valve devices that combine the 2D layered semiconductor InSe as a spacer with the 2D layered ferromagnetic metal Fe(3)GeTe(2) as spin injection and detection electrodes, are reported.</p><p>对后续研究以及工程应用可能影响:</p><p>TMR 效应在自旋电子学中有重要的应用，例如磁存储、磁传感器和逻辑器件。因此，实现高效的全二维范德华垂直自旋阀器件可能对提高这些应用的性能和可靠性有积极的影响。同时，也可能为探索新型的自旋电子学现象和功能提供新的平台。</p><p><em>J. Yan, Y. Zhang, Y. Zhang, J. Wang and X. Zhang, “Significant tunneling magnetoresistance and excellent spin filtering effect in CrI3-based van der Waals magnetic tunnel junctions,” Science Advances, vol. 4, no. 3, Mar. 2018, Art. no. eaar4851.</em></p><p>本文报道了基于 CrI3 的 van der Waals 磁隧道结的自旋极化量子输运性质。通过第一性原理计算，我们研究了由单层 CrI3、六方氮化硼（h-BN）间隔层和 n 层 CrI3（n&#x3D;1、2、3 和 4）组成的三明治型 vdW 磁隧道结的自旋极化量子输运性质。在 n&#x3D;3 时，获得了几乎完全自旋极化电流和大的隧道磁电阻比（3600%）。在正偏压下，由于 MTJs 中固定层数的不同，这些 MTJs 的输运性质表现出有趣的奇偶效应。当 n 为奇数（n&#x3D;1 和 3）时，观察到几乎完美的自旋过滤效应和显著的负微分电阻（NDR）。我们的结果为基于 2D 磁性 vdW 材料的 MTJs 的实验研究提供了有效的指导。</p><p>文章的主要结论是：基于 CrI3 的范德华磁性隧道结具有显著的隧道磁阻和优异的自旋滤波效应，这些效应可以通过调节 CrI3 层数和外加电压来调控。这些效应的物理机制是：CrI3 作为自旋滤波隧道势垒，可以有效地选择性地传输不同自旋方向的电子，从而导致电阻的变化。</p><p>对后续研究以及工程应用可能有以下影响：</p><ul><li>这些效应为设计新型的基于二维磁性材料的自旋电子器件提供了新的平台和可能性。</li><li>这些效应可以在低温下实现，且受外界磁场的影响较小，因此具有较高的灵敏度和稳定性。</li><li>这些效应可以用于实现高密度、低功耗、快速切换的数据存储和逻辑运算</li></ul><p>刚好有一篇研究 2D van der Waals 结构的文章，偏原理：</p><p>Y. Zhang, Y. Li, X. Zhang, Y. Li, Y. Wang and J. Wang, “Tunable Tunneling Magnetoresistance in van der Waals Magnetic Tunnel Junctions with 1T-CrTe2 Electrodes,” in IEEE Transactions on Magnetics, vol. 58, no. 4, pp. 1-5, April 2022, doi: 10.1109&#x2F;TMAG.2022.3172466.</p><p><img src="/img/XS0FbON0uoY16exk7ZqcZAFVnXc.png"></p><p>二维 (2D) 范德华 (vdW) 异质结构为具有新颖特性的自旋电子学应用开辟了新途径。在这里，通过密度泛函理论计算，我们研究了由 1T-CrTe2 铁磁电极组成的 vdW 磁隧道结 (MTJ) 中的自旋相关传输。同时，石墨烯和六方氮化硼被用作隧道势垒。已经发现两种类型的 vdW MTJ 的隧道磁阻 (TMR) 效应呈现出类似的趋势：势垒厚度对 TMR 比率有很大影响，当势垒增加到五个单层时达到最大值。然而，尽管存在相似性，但石墨烯-势垒结更有希望进行优化。通过观察 vdW MTJ 的能量分辨透射光谱，我们注意到石墨烯-势垒结的 TMR 比率是可调的，并且可以通过调整费米能量的位置来提高。因此，我们通过置换掺杂成功实现了 TMR 优化。当在石墨烯势垒中用一个硼原子取代一个碳原子时，TMR 比显着提高，在掺杂的七单层势垒结中可以获得高达 6962% 的 TMR 比。我们的结果为自旋电子学中的 vdW MTJ 应用铺平了道路。</p><p>这篇文章的主要结论是，他们发现可以通过调整 h-BN 障碍层的厚度和石墨烯与 1T-CrTe2 电极之间的层间距来调节隧道磁电阻（TMR）比。TMR 比是指磁化反平行时的抵抗值与磁化平行时的抵抗值之比，用于衡量 TMR 效应的大小 文章中发现，障碍层厚度越大，TMR 比越大；层间距越大，TMR 比越小</p><h3 id="应用、制造、测试"><a href="#应用、制造、测试" class="headerlink" title="应用、制造、测试"></a>应用、制造、测试</h3><p>基于 TMR 原理制造的传感器，在一些特定领域的应用。</p><p><em>C. Li, B. Yang, X. Guo and X. Chen, “Design, Analysis and Simulation of a MEMS-Based Gyroscope with Differential Tunneling Magnetoresistance Sensing Structure,” Sensors, vol. 20, no. 17, p. 4919, Aug. 2020, doi: 10.3390&#x2F;s20174919.</em></p><p>本文介绍了一种基于差分隧道磁阻传感的新型微机电系统 (MEMS) 陀螺仪的设计、分析和仿真。该设备由静电力驱动，而科里奥利位移会通过磁场的强度变化测出，由隧道磁阻单元进一步检测。磁场由一对涂在内部质量背面的双层平面多匝铜线圈产生。与所提出的音叉陀螺仪的双质量结构一起，形成了两级差分检测，从而能够同时抑制机械和磁共模误差。</p><p><img src="/img/RjarbZHR1oAxPuxRq2FcejHgnWg.png"></p><p><img src="/img/GpGob23rWoFqJwxdKGmchYHfntf.png"></p><p>所提出方案的独特之处在于，在空的内部质量上镀上一个双层平面微型线圈，以在铜线施加励磁电流时产生恒定磁场。当输入垂直于平面的角速度时，驱动一对外质量块 vibrate in reverse 沿 X 轴 ，从而使一对内质量块受到沿 y 轴的科里奥利力。因此，这对铜微线圈形成两个独立的磁场，在感测轴上具有不同的变化。</p><p>由于磁场沿 Y 轴对称分布，一对 Y 感测 TMR 单元对称地布置在每个线圈下方，以差分检测磁场的局部变化，如图 2 所示。TFG 的双质量设计和 TMR 传感器的对称布局构成了两级差分测量。因此，可以同时抑制 Y 轴加速度引起的机械共模误差和电磁干扰引起的 TMR 共模误差。</p><p>同样是陀螺仪 +TMR：</p><p><em>L. Jin, S.-Y. Qin, R. Zhang, and M.-W. Li, “High-sensitivity tunneling magneto-resistive micro-gyroscope with immunity to external magnetic interference,” Scientific Reports, vol. 10, no. 1, p. 16441, Oct. 2020.</em></p><p><img src="/img/Ovgkb4nf6o2EEJx5KT2cJ7AsnMd.png"></p><p><img src="/img/N8SJbIBtqo33oPxA1ycciX0tnOc.png"></p><p>顶层是 TMR 结构，有多个磁阻结；中间层为微陀螺结构层，铜制电子线圈位于结构质量块表面；底层为接合基板，两个驱动磁体位于基板两侧，由脉冲激光沉积溅射 Nd_2Fe_14B 靶材制成，在驱动方向提供均匀磁场。当在驱动线的电极上施加电压时，微型陀螺仪的结构（包括驱动和传感质量块）被电磁力驱动，从而在 X 轴方向上往复运动。如果在 Z 轴上施加一个角速度信号，由于科里奥利力的作用，传感质量块和通电线圈将沿 Y 轴方向移动。通电线圈在驱动方向提供均匀磁场，在感应方向提供高梯度磁场。这种运动会改变 TMR 设备感应到的磁场强度。由于 TMR 器件对磁场的微弱变化具有很高的灵敏度，当磁场变化时 TMR 器件的电阻值变化很快。因此，微型陀螺仪的输入角速度 Ω 可以通过测量 TMR 器件输出电压的变化来获得。</p><p>实验装置的框图如图 3a 所示。谐波响应测试用于研究微型陀螺仪的模式匹配。信号发生器产生的扫频交流信号，用于驱动微型陀螺仪，驱动&#x2F;传感方向的输出信号经过放大和低通滤波后，使用锁相放大器进行同步解调。谐波响应测试的结果如图 3b 所示。共振频率经测试为 7850 Hz 和 7854 Hz。这种 4 Hz 的频率分裂主要是由制造过程中的不对称造成的。</p><p>文章的主要创新点是：建立了 TMR 微型陀螺仪的灵敏度计算模型，所设计的结构、磁场和磁阻器件对后续研究有参考意义。测试发现，传感器测量的精度取决于外部磁场波动；为此，提出了多桥电路的方法来抑制外部磁场干扰，有效避免 TMR 器件的积分误差，提高运算精度。</p><p>裂缝检测</p><p><em>C. Ye, Z. Zhou, Y. Yang, Q. Leng and W. Zhao, “Research on crack monitoring technology of flexible eddy current array sensor based on TMR sensors,” Measurement: Journal of the International Measurement Confederation, vol. 186, p. 109530, 2022.</em></p><p>设计了一种矩形柔性涡流阵列传感器，它由励磁线圈和 TMR 传感器组成。</p><p><img src="/img/QdcAbQzUbofifcxhbKXc1CQhn2b.png"></p><p><img src="/img/F4Ffbl6pYoqiSTxqrKXcaBxbnJf.png"></p><p>基于 TMR 传感器的柔性涡流阵列传感器的裂纹监测原理与传统涡流传感器相同。交变磁场是由交流电驱动空间中的励磁线圈产生的。当励磁线圈靠近金属导体时，金属导体上方会形成涡流。当结构出现裂纹时，结构上的涡流会受到扰动，从而产生扰动磁场。裂纹的出现可以通过 TMR 传感器测量扰动磁场来确定。</p><p>主要亮点是：</p><ul><li>提出了一种基于 TMR 传感器的柔性涡流阵列传感器，用于检测金属结构中的裂缝。</li><li>建立了柔性涡流阵列传感器的有限元模型，分析了不同参数对探头输出信号的影响。</li><li>进行了实验验证，比较了不同裂缝长度和深度下探头输出信号的变化。</li><li>提出了一种基于神经网络的裂缝识别算法，实现了对裂缝长度和深度的准确估计</li></ul><p>三相激励和集成阵列隧道磁阻传感器的涡流探头；旨在快速、可靠地检测金属结构中的缺陷。</p><p><em>Na Zhang, Chaofeng Ye, Lei Peng, and Yu Tao, “Eddy Current Probe With Three-Phase Excitation and Integrated Array Tunnel Magnetoresistance Sensors,” in <strong>IEEE</strong> Transactions on Industrial Electronics, vol. 68, no. 6, pp. 5325-5334, June 2021.</em></p><p>涡流探头使用承载三相电流的线圈作为激励。这与其他使用单相或两相电流的励磁方法不同。三相励磁法在导电样品中感应出涡流，涡流沿相位变化方向循环流动并发生电位移。这使得探头对任何方向的缺陷都敏感，并且无需多路复用励磁线圈，从而具有成本更低、噪音更小和检测速度更快的优势。</p><p>使用三相激励电路的原因是：</p><ul><li><a href="https://ieeexplore.ieee.org/document/9080544">三相激励电路可以实现涡流场的旋转和调制，从而提高探头的信噪比和抗干扰能力</a><a href="https://ieeexplore.ieee.org/document/9080544">(1)</a><a href="https://ieeexplore.ieee.org/document/8725600/">(2)</a>。</li><li><a href="https://ieeexplore.ieee.org/document/9080544">三相激励电路可以减少探头的尺寸和重量，从而提高探头的灵活性和可靠性</a><a href="https://ieeexplore.ieee.org/document/9080544">(1)</a><a href="https://ieeexplore.ieee.org/document/8725600/">(2)</a>。</li><li><a href="https://ieeexplore.ieee.org/document/9080544">三相激励电路可以避免探头的直流偏置，从而提高探头的稳定性和精度</a><a href="https://ieeexplore.ieee.org/document/9080544">(1)</a><a href="https://www.semanticscholar.org/paper/Eddy-Current-Probe-With-Three-Phase-Excitation-and-Zhang-Ye/6c1716201f94a150d62f52aece5644426237e89b">(3)</a>。</li></ul><p>涡流检测探头使用集成阵列隧道磁阻 (TMR) 传感器作为接收器来测量磁场。 TMR 阵列包含 64 个传感器，这些传感器经过微加工并封装在一条线上。在单次探测过程中，传感器会生成具有高灵敏度（1.99 nT&#x2F;√Hz @ 30 kHz）和精细空间分辨率（0.5 毫米间距）的磁场图像。通过分析输出图像，可以识别和定位缺陷。TMR 传感器通过测量被测金属结构中感应的涡流引起的磁场变化来工作。当涡流流过导电材料时，会在其周围产生磁场。 TMR 传感器检测这些磁场并将其转换为可分析的电信号，以识别被测材料中的缺陷。</p><p><img src="/img/CeUebs1DwoZnpKxbuwlc0ZPBnGb.png"></p><p><img src="/img/I9DlbiBhZo0JYPxieUKclmPpnwe.png"></p><p>DRTE 结构具有更低的噪声，但也有更低的灵敏度。SRTE 结构和 DRTE 结构在检测裂缝和腐蚀方面都有良好的性能，但 DRTE 结构更适合检测较小的缺陷。</p><p>这篇文章的主要亮点是：</p><ul><li>它提出了一种基于三相激励和集成隧道磁阻（TMR）传感器阵列的涡流探头。</li><li>它设计了一种新颖的三相激励电路，实现了涡流场的旋转和调制。</li><li>它利用 TMR 传感器阵列的高灵敏度和高分辨率，实现了对金属结构中的裂缝和腐蚀的检测。</li><li>它进行了理论分析和实验验证，表明了 TMR 涡流探头的优越性能和广泛应用前景。</li></ul><p>高精度微位移传感器</p><p><em>X. Wang et al., “High-precision micro-displacement sensor based on tunnel magneto-resistance effect,” Sci Rep, vol. 12, no. 1, Art. no. 1, Feb. 2022, <strong>doi</strong>: 10.1038&#x2F;s41598-022-06965-3.</em></p><p>基于隧道磁阻效应的高精度微位移传感器。采用细分插值技术，通过将 TMR 传感器的正余弦输出转换为随位移线性变化的输出来提高分辨率。同时，采用多桥电路方式抑制外磁和地磁干扰。实验结果表明，微位移传感器的分辨率为 800 nm，精度为 0.14%(全量程误差，最大误差为 0.7 μm，满量程为 500 μm)，毫米级的满量程范围。</p><p><img src="/img/W4lab9VFEo2yyRxd9PHcTva7nzb.png"></p><p>TMR 位移传感器由铜制电子线圈层和 TMR 器件层组成。电子线圈在 X 轴方向提供均匀的磁场，在 Y 轴（感应）方向提供高梯度磁场。磁阻结构由几组 TMR 装置组成，它有两种极性相反的磁阻结。磁场分布和 TMR 器件的灵敏度直接决定了基于 TMR 的位移传感器的性能。</p><p>工艺流程：</p><p><img src="/img/PTvcbY94CoxXK9xk9egc4Vk7nSh.png"></p><p>这篇文章中使用的 TMR 传感器的具体型号是 TMR1302，它是由 MultiDimension Technology （多维科技，江苏张家港）生产</p><p><em>C. Ren, Q. Bayin, S. Feng, Y. Fu, X. Ma, and J. Guo, “Biomarkers detection with magnetoresistance-based sensors,” Biosensors and Bioelectronics, vol. 165, p. 112340, Oct. 2020.</em></p><p>这是一篇综述文章。综述了三种基于 MR 的生物标志物检测技术，即各向异性磁阻 (AMR)、巨磁阻 (GMR) 和隧道磁阻 (TMR)。基于这三种常用技术，分别介绍了生物医学诊断、食品安全、环境监测等不同的典型应用。此外，通过结合微流控、微机电系统（MEMS）、免疫层析试纸（ICTS）等不同的先进技术，更好地扩展了现有的基于 MR 的检测方法，使其更符合当前的检测需求。基于磁阻的传感器具有易于集成、灵敏度高和元件成本低的优点。基于磁阻的传感器在医学检测、食品安全和环境监测等方面具有广阔的前景。各种先进技术与磁阻传感器的结合促进了它的发展。</p><ul><li>Y. Zhang, J. Wang, X. Li and Y. Liu, “New Small-Volume High-Precision TMR Busbar DC Current Sensor,” in <strong>IEEE</strong> Transactions on Magnetics, vol. 56, no. 4, pp. 1-5, April 2020, <strong>doi</strong>: 10.1109&#x2F;TMAG.2019.2950406.*</li></ul><p>本文设计了一种尺寸为 23.2 mm × 16.5 mm × 7.2 mm 的新型差分式超小型磁传感器。该传感器基于隧道磁阻 (TMR)，放置在母线的上表面边缘。电源电压为 5 V，额定电流测量范围为 ±150 A，峰值电流测量范围为 ±250 A，对应于 ±250 A dc 峰值电流下的 2.5 ± 2 V 输出。相对精度在 25 °C 时小于 ±1%，在 -40 °C 至 105 °C 的整个温度范围内小于 ±2%</p><p><img src="/img/Er3YbtnLKo8zthxlUEYcpKTcnpd.png"></p><p><img src="/img/Pdq5bWIz5oGG5uxOIFNchoTmnLh.png"></p><h3 id="调理电路、信号处理算法"><a href="#调理电路、信号处理算法" class="headerlink" title="调理电路、信号处理算法"></a>调理电路、信号处理算法</h3><p>提出了一种交流调制方法和阻抗补偿方法来提高传感器的性能。文章中还介绍了传感器的直流和交流特性，并且指出了外部磁场对传感器等效电阻和电容的影响。</p><p><em>Wenlei Zhao, Xinchen Tao, Chaofeng Ye and Yu Tao, “Tunnel Magnetoresistance Sensor with AC Modulation and Impedance Compensation for Ultra-Weak Magnetic Field Measurement,” Sensors, vol. 22, no. 3, p. 1021, <strong>Jan</strong>. 2022, <strong>doi</strong>: 10.3390&#x2F;s22031021.</em></p><p>调制和阻抗补偿显著提高了低频范围内的传感器灵敏度。在 1 Hz 时，传感器的信噪比通过交流调制、阻抗补偿和梯度计测量装置提高了约 25.3 dB。此外，传感器的灵敏度从 165.2 提高到 222.1 mV&#x2F;V&#x2F;mT。在未屏蔽环境中，该传感器测量了两个人体的超弱磁信号，即心磁图信号（MCG），并且可以清晰地可视化 MCG 的 R 峰。</p><p><img src="/img/O7fBbf3Ypo6KBIxnAFGcTG7Knld.png"></p><p><img src="/img/Wul6brgDSoNPwGxSfW8c1PPRn3g.png"></p><p>提出了一种交流调制和阻抗补偿的方法，用于提高隧道磁阻（TMR）传感器在超弱和低频磁场测量中的性能。该方法通过在传感器两端加上交流电压，使传感器工作在交流状态，从而降低 1&#x2F;f 噪声的影响。同时，该方法还通过在传感器两端并联一个阻抗补偿电路，使传感器的输出电压与输入电压成正比，从而消除了阻抗不匹配对信号的影响。</p><p>文章的阻抗补偿电路是通过在传感器两端并联一个电阻和一个电容组成的 RC 电路来实现的。该 RC 电路的阻抗与传感器的阻抗相等，但相位相反。因此，当传感器和 RC 电路并联时，它们的总阻抗为零，从而消除了阻抗不匹配对信号的影响</p><p>由于 TMR 传感器由多个纳米层构成，因此 TMR 传感器的简化等效电路是并联连接的电阻器和电容器。如果在较高频率下工作，则应考虑传感器的阻抗，而不仅仅是电阻。因此，需要使用 LCR 表。测量 TMR 传感器的交流阻抗，即 TMR 传感器在不同驱动下的等效电阻和电容频率。 LCR 表的驱动电压为 2 V。LCR 表的频率从 20 Hz 变为 300 kHz。</p><p>TMR 传感器的等效电路包含并联连接的电阻器和电容器。 TMR 的电阻和电容都会受到外部磁场的影响。因此，推测可以通过并联一个电感来适当补偿 TMR 传感器的阻抗，从而提高传感器的灵敏度。</p><p><img src="/img/X6y4bVo1Uo6yuvxnuuica5HCnPe.png"></p><p><img src="/img/NKiIbJn0foiUcvxCusOciHaBnfg.png"></p><p>使用的传感器：MR1302</p><p>MEMS 器件的高精度磁编码器</p><p>B. Zhang, Y. Jiang, Y. Li, X. Chen and X. Wen, “Design and Development of High Precision Magnetic Encoder Based on TMR MEMS Device,” 2021 IEEE 16th International Conference on Nano&#x2F;Micro Engineered and Molecular Systems (NEMS), Xiamen, China, 2021, pp. <a href="https://ieeexplore.ieee.org/document/9451506/">169-173</a></p><p>会议文章</p><p>采用基于 TMR 原理的 MEMS 磁敏芯片作为磁性编码器的敏感元件。在硬件开发方面，经过磁路优化设计，开发精密旋转结构，设计稳压电源电路和低噪声信号调理电路，将模拟电压信号数字化转换为高信噪比比率通过模数转换，然后进入微处理器。在程序设计方面，针对敏感元器件的原始输出数据设计并编写了数据处理、校正和标定算法，并利用 MATLAB 软件对编码器计算出的角度数据进行仿真、计算和验证，进一步验证。</p><ul><li>作者通过实验验证了磁编码器的性能，结果表明其分辨率达到了 0.01°，重复性误差小于 0.02°，非线性误差小于 0.05°。</li></ul><p><img src="/img/EGkMbOd9GosXKkxkYaRcmVkxn1g.png"></p><p><img src="/img/QJh3bqqBloPSxKxjRR5cus99nbf.png"></p><p><img src="/img/WaW4bXPUCotVT3xq4T0cqZ3Snde.png"></p><p>两个电桥，测 sin cos</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>可能的研究方向很多，TMR 在磁传感器各个应用领域表现优越</p><p>基于“磁检测技术”应用的大方向，TMR 可以应用在很多场景（地址勘探、定位导航、缺陷检测、生物检测），或者和其他典型传感器结构结合（位移传感器、陀螺仪）。得益于 TMR 的高分辨率、灵敏度，作为磁传感器在价格、性能上都具有优势，最近基于 TMR 的特定应用领域的文章还是挺多的。但是 TMR 的加工制造仍然是难点。关于“如何制造更高性能的 TMR 传感器”以及“设计更高性能 TMR 原型”仍然是一个难点，相关的工程研究并不多。（可能关于制造的技术是各企业的商业机密）</p><p>适用于 MEMS 系统的新特性</p><p>偏原理、前沿的研究（凝聚态物理、量子力学），偏向的可能应用都是存储介质。TMR 作为存储单元，主要使用其饱和态，更加关注其存储效率和功耗，但是也有多 bit 的应用。关注前沿的研究，虽然不一定能看懂、理解，但知道某种材料、结构对磁-阻曲线的影响，也能迁移到传感器应用中。例如：van der Waals、加入抗铁磁层的间接交换；同时也需要基于仿真、理论计算和工艺能力，调整层厚和多层膜的选择、膜厚设计、MTJ 组网设计，通过仿真设计寻找在某个特定应用系统中性能更佳的传感器。主要是 TMR 结构尺寸的设计。</p><p>CMOS 的良好兼容性以及小型化</p><p>TMR 结构比较简单，和 COMS 工艺兼容有良好的兼容性。面向应用的研究，可以和 ADC、寄存器、通信接口等数字电路集成，制备更易用的数字传感器。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>[1]磁性隧道结的隧穿磁电阻研究_张佩佩[D].四川师范大学，2011</p><p>[2]李翔宇. 高性能隧穿磁阻传感器接口电路芯片集成技术研究_李翔宇[D]. 哈尔滨工业大学, 2018</p><p>[3]Yaodi Yang, Shaohua Yan, and Xiaobo Sharon Hu, “Developments and Applications of Tunneling Magnetoresistance Sensors,” Tsinghua Science and Technology, vol. 27, no. 3, pp. 443-454, June 2022.</p><p>[4]Efficient and Highly Reliable Spintronic Non-volatile Quaternary Memory Based on Carbon Nanotube FETs and Multi-TMR MTJs,” ECS Journal of Solid State Science and Technology, vol. 11, no. 6, p. 061007, 2022</p><p>[5]L. Šmejkal, A. Birk Hellenes, R. González-Hernández, J. Sinova, and T. Jungwirth, “Giant and Tunneling Magnetoresistance in Unconventional Collinear Antiferromagnets with Nonrelativistic Spin-Momentum Coupling,” Phys. Rev. X, vol. 12, no. 1, p. 011028, Feb. 2022.</p><p>[6]Yan, J., Zhang, Y., Zhang, Y., Wang, J., &amp; Zhang, X. (2018). Significant tunneling magnetoresistance and excellent spin filtering effect in CrI3-based van der Waals magnetic tunnel junctions. Science advances, 4(3), eaar4851.</p><p>[7]Y. Zhang, J. Wang, X. Li and Y. Liu, “Large Tunneling Magnetoresistance in van der Waals Ferromagnet&#x2F;Semiconductor Heterojunctions,” in Advanced Materials, vol. 34, no. 50, pp. 2104658, December 2022, doi: 10.1002&#x2F;adma.202104658.</p><p>[8]Y. Zhang, Y. Li, X. Zhang, Y. Li, Y. Wang and J. Wang, “Tunable Tunneling Magnetoresistance in van der Waals Magnetic Tunnel Junctions with 1T-CrTe2 Electrodes,” in IEEE Transactions on Magnetics, vol. 58, no. 4, pp. 1-5, April 2022, doi: 10.1109&#x2F;TMAG.2022.3172466.</p><p>[9]L. Zhang, Y. Zhang, J. Li, Y. Wang, and H. Zeng, “Transport properties of tunneling magnetoresistance sensors based on double indirect exchange coupling effect,” Journal of Magnetism and Magnetic Materials, vol. 500, p. 166382, 2020.</p><p>[10]C. Li, B. Yang, X. Guo and X. Chen, “Design, Analysis and Simulation of a MEMS-Based Gyroscope with Differential Tunneling Magnetoresistance Sensing Structure,” Sensors, vol. 20, no. 17, p. 4919, Aug. 2020, doi: 10.3390&#x2F;s20174919.</p><p>[11]L. Jin, S.-Y. Qin, R. Zhang, and M.-W. Li, “High-sensitivity tunneling magneto-resistive micro-gyroscope with immunity to external magnetic interference,” Scientific Reports, vol. 10, no. 1, p. 16441, Oct. 2020.</p><p>[12] C. Ye, Z. Zhou, Y. Yang, Q. Leng and W. Zhao, “Research on crack monitoring technology of flexible eddy current array sensor based on TMR sensors,” Measurement: Journal of the International Measurement Confederation, vol. 186, p. 109530, 2022.</p><p>[13]  X. Wang et al., “High-precision micro-displacement sensor based on tunnel magneto-resistance effect,” Sci Rep, vol. 12, no. 1, Art. no. 1, Feb. 2022, doi: 10.1038&#x2F;s41598-022-06965-3.</p><p>[14]Na Zhang, Chaofeng Ye, Lei Peng, and Yu Tao, “Eddy Current Probe With Three-Phase Excitation and Integrated Array Tunnel Magnetoresistance Sensors,” in IEEE Transactions on Industrial Electronics, vol. 68, no. 6, pp. 5325-5334, June 2021.</p><p>[15] Y. Zhang, J. Wang, X. Li and Y. Liu, “New Small-Volume High-Precision TMR Busbar DC Current Sensor,” in IEEE Transactions on Magnetics, vol. 56, no. 4, pp. 1-5, April 2020, doi: 10.1109&#x2F;TMAG.2019.2950406.</p><p>[16]Wenlei Zhao, Xinchen Tao, Chaofeng Ye and Yu Tao, “Tunnel Magnetoresistance Sensor with AC Modulation and Impedance Compensation for Ultra-Weak Magnetic Field Measurement,” Sensors, vol. 22, no. 3, p. 1021, Jan. 2022, doi: 10.3390&#x2F;s22031021.</p><p>[17] B. Zhang, Y. Jiang, Y. Li, X. Chen and X. Wen, “Design and Development of High Precision Magnetic Encoder Based on TMR MEMS Device,” 2021 IEEE 16th International Conference on Nano&#x2F;Micro Engineered and Molecular Systems (NEMS), Xiamen, China, 2021, pp. 169-173</p>]]></content>
    
    
    
    <tags>
      
      <tag>文献学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目总结】基于磁强计、IMU的组合导航算法</title>
    <link href="/2023/03/25/%E3%80%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91%E5%9F%BA%E4%BA%8E%E7%A3%81%E5%BC%BA%E8%AE%A1%E3%80%81IMU%E7%9A%84%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%AE%97%E6%B3%95/"/>
    <url>/2023/03/25/%E3%80%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91%E5%9F%BA%E4%BA%8E%E7%A3%81%E5%BC%BA%E8%AE%A1%E3%80%81IMU%E7%9A%84%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="基于卡尔曼滤波器的磁强计、IMU-组合导航算法研究"><a href="#基于卡尔曼滤波器的磁强计、IMU-组合导航算法研究" class="headerlink" title="基于卡尔曼滤波器的磁强计、IMU 组合导航算法研究"></a>基于卡尔曼滤波器的磁强计、IMU 组合导航算法研究</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>由三轴加速度计和三轴陀螺仪组成的惯性测量单元 (IMU) 广泛用于自主导航系统。然而，IMU 的漂移会导致位置和姿态测量存在显著的累积误差。IMU 测量的主要参数是加速度和角速率，其他参数例如速度、位移和旋转角度是通过对加速度或角速率随时间积分得到的。然而，漂移和积分误差导致长时间运动测量中存在大量累积误差，甚至导致结果发散。对于长时间稳定测量，需要额外的辅助传感器来补充 IMU 系统，以构建用于漂移补偿的组合系统。这些辅助传感器包括超声波传感器、激光测距传感器、相机、太阳传感器和磁强计。</p><p>磁导航系统和惯性导航系统的算法融合度较高，能够实现全态姿动态测量，同时运算量能够在微控制器平台实现，实现成本较低，是自主导航以及姿态检测方案中常用的组合系统。</p><p>在本项目中，将基于磁力计补偿惯性传感器的漂移和累积误差的方法来进行实时姿态估计。其工作主要包括卡尔曼滤波器的原理解释、组合导航应用仿真、结果分析与讨论。</p><h3 id="磁强计-IMU-导航简介"><a href="#磁强计-IMU-导航简介" class="headerlink" title="磁强计 +IMU 导航简介"></a>磁强计 +IMU 导航简介</h3><p>IMU 惯性导航系统是以陀螺仪和加速度计为敏感器件的导航参数解算系统。</p><p>地磁定位导航技术基于地磁场是一个矢量场, 其强度大小和方向是位置的函数。同时地磁场具有丰富的总强度、矢量强度、磁倾角、磁偏角和强度梯度等特征，为地磁匹配提供了充足的信息。因此，将地磁场作为一个天然的坐标系, 利用地磁场的测量信息实现定位导航。</p><p>该系统可以实现卫星的自主导航，不依靠外部信息，仅利用星上自备的测量设备实时地确定自身的位置和速度。</p><h3 id="导航坐标系"><a href="#导航坐标系" class="headerlink" title="导航坐标系"></a>导航坐标系</h3><p>地球：可简要分为：圆球体、大地面包围成的球体、椭球体 ；一般的做法会将地球等效成椭球体，不同维度下的曲率半径不同，重力加速度不同，但是有恒定的地球自转角速度。</p><p>惯性坐标系是无加速度的或者处于匀速直线运动状态。而宇宙空间中的所有物体都处在运动中，因此需要根据不同的导航对象来选取惯性坐标系。</p><p>地心惯性坐标系 ： 做匀速直线运动 忽略了行星公转 ；忽略太阳、月亮及其它星体的引力，以及由于这些引力而存在的地球轨道运动。</p><p>发射点惯性坐标系（简称 li 系）：发射时刻的发射点惯性坐标系作为测量该载体飞行位置的基准。</p><p>地球坐标系（简称 e 系）：地球坐标系是原点在地心，坐标轴固定在地球上的右手正交坐标系。近似认为它相对惯性坐标系固有转动角速率旋转。ＯＺ 轴指向北极，ＯＸ 和 ＯＹ 轴都在赤道平面内。</p><p>地理坐标系（简称 t 系）：相对于大地水准面定义的东北天坐标系。其中，东北天坐标系原点为载体质心在大地水准面上的投影。x 轴沿参考椭球卯酉圈方向指向东，y 轴沿参考椭球子无圈方向指向北。</p><p>载体坐标系（简称 b 系）固连在运载体的参考坐标系  坐标原点为运载体的重心，by 轴沿载体横轴指向右翼，bx 轴沿载体纵轴指向机头方向。</p><p>导航坐标系（简称 n 系）。导航坐标系是在根据导航的需要求解载体导航信息时选取的参考坐标系。对于捷联惯性导航系统来说，导航信息并不在载体坐标系内求解，但惯性传感器的测量姿态值是在载体坐标系内进行的。因此，必须将惯性传感器的输出值变换到导航坐标系中，再进行导航信息的计算。</p><h3 id="姿态角与四元数"><a href="#姿态角与四元数" class="headerlink" title="姿态角与四元数"></a>姿态角与四元数</h3><p>姿态角，也叫欧拉角，姿态角是载体坐标系和导航坐标系之间的三个夹角</p><p>航向角：载体纵轴 bx 与北向轴（N）之间的夹角，在水平面测量，顺时针为正；</p><p>俯仰角：载体纵轴 bx 与水平面之间的夹角，在垂直面中测量，抬头为正；</p><p>横滚角：载体横轴 by 与水平面之间的夹角，在横截面测量，左边抬头为正。</p><p><img src="/img/boxcnqCeBqY5a87xRcVBN0zf9Qc.png"></p><p>旋转矩阵：</p><p><img src="/img/boxcnOM54fnwSXJCbCRz5Ya02XU.png"></p><p>从 n 系到 b 系，坐标点可以通过三个姿态角相关的旋转矩阵得到。</p><p><img src="/img/boxcnFFov2cuynn5nknbMfx8Vwh.png"></p><p>姿态矩阵 – 捷联姿态测量系统中姿态的更新就是根据惯性传感器在载体坐标系中测得值实时的计算出姿态矩阵，然后从姿态矩阵中提取出所需的载体姿态信息。</p><p>四元数：</p><p>测量器件本身跟随着载体既有平移又有旋转运动，使得问题描述与求解变得非常困难。四元数的理论可将此类问题归为刚体绕定点的转动问题，从而有效地解决了这一问题。</p><p>不是从三个旋转角的分量描述，而是找到一个转轴 μ ，可以用 ijk 三个坐标轴表示 μ 的方向。一个坐标或一个矢量相对于某一坐标系的旋转，转角为 θ：</p><p><img src="/img/boxcnb69zPcepTMoDAxzerWY0qg.png"></p><p>q 是旋转四元数 ；R‘为旋转后的投影： R’ &#x3D;q’Rq</p><p><img src="/img/boxcnvn707yzGkdUCJmYeBvoTEg.png"></p><p>可以和方向余弦矩阵法 都是表示旋转后坐标系之间的转换，本质上是等价的。</p><p>利用四元数求解姿态的具体算法：</p><p>求解四元数姿态微分方程式：</p><p>$$<br>dq&#x2F;dt&#x3D; 1&#x2F;2  q × ω<br>$$</p><p><img src="/img/boxcnezOlwbNPre7cn6YR6DuTTh.png"></p><p>假设角速度的采样周期为 T，则四阶龙格-库塔法计算的形式如下：</p><p><img src="/img/boxcnVm2my58Ik2s6yqhO0TdVrd.png"></p><p>在利用四元数进行载体姿态解算中通常需要进行正交化处理，从而消除非正交误差对姿态解算精度的影响，其主要目的是使采用四元数方法获得的姿态转移矩阵随机漂移误差达到最小，可以由四元数的四个参数的平方和与四元数的模相比的方法进行归一化处理。</p><h2 id="卡尔曼滤波算法"><a href="#卡尔曼滤波算法" class="headerlink" title="卡尔曼滤波算法"></a>卡尔曼滤波算法</h2><p>卡尔曼滤波器的主要作用可以概括为在带有噪声的系统中寻找状态量的最优估计。</p><p><img src="/img/boxcnBmur9ItlTMWzenWfkLadTd.png"></p><p><img src="/img/boxcncrHaCyxgBQat1zqnYpGOle.png"></p><p>在设计滤波器时，可以选择估计值的权重和观测值的权重，来对结果进行修正。</p><p>经典的卡尔曼滤波器仅适用于线性系统，要求信号满足叠加性和齐次性，噪声满足正态分布。</p><p>状态空间表达式：状态方程和观测方程。</p><p><img src="/img/boxcnwOv8TrHz6tpMy6SCJt5Nac.png"></p><p>我们最关心的是 Xk，当前的所测量实际物理量。每一个状态和之前的状态以及过程噪声息息相关。观测就是说对当前状态好会有一个转移，然后会有一个误差。我们可以使用状态方程得到当前的估计值，然后再结合观测值，加权得到当前的最优估计值。</p><p>我们的噪声序列，假设是满足正态分布。</p><p>一维方差-噪声的方差，QK RK； 状态的方差 估计方差 Xt</p><p>如果状态是多维，则会有不同的噪声，需要用到协方差矩阵(协方差用来描述随机变量的相关性)</p><p>在实现过程中需要定义超参数：类似于 PID，一个模型很难算出来 PID，需要人工训练；超参数，需要人工训练，很难一开始就确定。在 kalman 滤波器中 Q R 的噪声方差也需要自己训练。</p><h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><p><img src="/img/boxcnSlHOtti5etcz8tiVKD7Odf.png"></p><p>使用上一次的结果预测当前值，同时使用观测值修正</p><p>上图中，上面是预测，下面是更新。Kt 是 kalman 增益，量测更新 Kt 是观测值的权重。Pt 是协方差矩阵在不断更新</p><p>主要的公式 or 过程：</p><ol><li>先验估计 Xk 估&#x3D;A Xk-1 估 +μ Bk，其中 A 决定了是不是线性系统</li><li>先验估计协方差 最优估计的协方差，会是上一个估计的协方差矩阵左乘右乘状态转移矩阵<br>cov(Ax,Ax)&#x3D;Acov(x,x)A^T</li><li>修正估计 右下角的公式，得到 kalman 滤波在最终值的值  Kk kalman 增益，决定了观测值的权</li><li>更新增益 Kk 左三公式。和 Q 和 R 都有关，性质就是 Q+R 作分母，那个方差小权重就高</li></ol><p>整体过程就是不断地预测、然后修正、更新值再给到下一次作预测、如此循环迭代。</p><h3 id="关键参数的选择"><a href="#关键参数的选择" class="headerlink" title="关键参数的选择"></a>关键参数的选择</h3><p>Q&amp;R  过程噪声方差矩阵 Q 模型理想与否   观测噪声 R 取决于传感器性能</p><p>由于 X0  P0 会迭代，可以取 X0&#x3D;0，P 小一点，方便收敛。</p><p>使用 kalman 滤波时的注意事项</p><ol><li>选择状态量、观测量</li><li>构建迭代方程、</li><li>初始化参数</li><li>带入公式、进行迭代</li><li>适当调节超参数</li></ol><h3 id="kf-在惯性导航应用"><a href="#kf-在惯性导航应用" class="headerlink" title="kf 在惯性导航应用"></a>kf 在惯性导航应用</h3><p>IMU 信号输出：</p><ol><li>选择状态量<br>陀螺仪噪声协方差  Q_angle<br>陀螺仪漂移噪声协方差  Q_bias<br>角度测量噪声协方差 R_angle<br>测量得的角速度 Newguro<br>采样周期 Dt</li><li>方程构建<br>先验估计：明确当前的角度值、漂移值的预测模型<br>预测误差协方差矩阵：P&#x3D;APA^T+Q ;多维协方差矩阵；注意不同噪声 大多数时候是独立的，cov &#x3D;0<br>测量方程： Z&#x3D;CX+V  在实际应用的 C 代码中不用模拟噪声 V，本省的输出就是带噪的<br>计算 kalman 增益：K&#x3D;PC (CPC+R)^-1<br>最优估计方程：X&#x3D;X+K(Z-CX)<br>更新协方差阵：P&#x3D;[I-KC]P</li></ol><p>有了数学方程，而且还是时域的，代码只是数学的简单延续。</p><h2 id="SIN-仿真"><a href="#SIN-仿真" class="headerlink" title="SIN 仿真"></a>SIN 仿真</h2><h3 id="四元数计算、欧拉角、位置速度参数转换"><a href="#四元数计算、欧拉角、位置速度参数转换" class="headerlink" title="四元数计算、欧拉角、位置速度参数转换"></a>四元数计算、欧拉角、位置速度参数转换</h3><p>首先是基于上面坐标系、四元数等基础知识的数学函数，主要是四元数与方向向量、欧拉角、旋转矩阵之间的转换，四元数与向量的乘积，归一化等基础操作。</p><p>例如下面是从四元数到旋转矩阵的转换函数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">function</span> Cnb = q2mat(qnb)<br> <span class="hljs-attribute">q11</span> = qnb(<span class="hljs-number">1</span>)*qnb(<span class="hljs-number">1</span>); q12 = qnb(<span class="hljs-number">1</span>)*qnb(<span class="hljs-number">2</span>); q13 = qnb(<span class="hljs-number">1</span>)*qnb(<span class="hljs-number">3</span>); q14 = qnb(<span class="hljs-number">1</span>)*qnb(<span class="hljs-number">4</span>); <br> <span class="hljs-attribute">q22</span> = qnb(<span class="hljs-number">2</span>)*qnb(<span class="hljs-number">2</span>); q23 = qnb(<span class="hljs-number">2</span>)*qnb(<span class="hljs-number">3</span>); q24 = qnb(<span class="hljs-number">2</span>)*qnb(<span class="hljs-number">4</span>); <br> <span class="hljs-attribute">q33</span> = qnb(<span class="hljs-number">3</span>)*qnb(<span class="hljs-number">3</span>); q34 = qnb(<span class="hljs-number">3</span>)*qnb(<span class="hljs-number">4</span>); <br> <span class="hljs-attribute">q44</span> = qnb(<span class="hljs-number">4</span>)*qnb(<span class="hljs-number">4</span>);<br> <span class="hljs-attribute">Cnb</span> =<span class="hljs-meta"> [ q11+q22-q33-q44, 2*(q23-q14), 2*(q24+q13);</span><br><span class="hljs-meta"> 2*(q23+q14), q11-q22+q33-q44, 2*(q34-q12);</span><br><span class="hljs-meta"> 2*(q24-q13), 2*(q34+q12), q11-q22-q33+q44 ];</span><br><span class="hljs-meta"></span><br></code></pre></td></tr></table></figure><p>其余的基础函数实现不在这里给出，详情可以参考：</p><p><img src="/img/boxcnIpApVINYHWvgil9kC1VJPf.png"></p><h3 id="误差导入："><a href="#误差导入：" class="headerlink" title="误差导入："></a>误差导入：</h3><p>实际地球重力场中如果垂线偏差较大而又不能精确补偿，将会带来不利影响，它等效于加速度计偏值误差或者水平失准角误差。姿态需要初始化，对于 IMU 是根据测地球自转角速度以及重力加速度进行姿态初始化。而磁强计可以靠地磁场对姿态进行初始化。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">phi</span> <span class="hljs-operator">=</span> [<span class="hljs-number">0.1</span><span class="hljs-comment">; 0.2; 3]*arcmin; qnb = qaddphi(qnb, phi); % 失准角</span><br><br></code></pre></td></tr></table></figure><p><img src="/img/boxcndkItdVAgUYckaE5fSA6Kib.png"></p><p>圆锥误差和划船误差是理论推导时存在的误差形式，学界已有较多补偿方式。这里采用的是最经典的基于泰勒展开的多子样补偿算法。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% cnscl.m 圆锥误差和划船误差补偿</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[phim, dvbm]</span> = <span class="hljs-title">cnscl</span><span class="hljs-params">(wm, vm)</span></span><br> cs = [ [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ]/<span class="hljs-number">3</span><br> [<span class="hljs-number">9</span>, <span class="hljs-number">27</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ]/<span class="hljs-number">20</span><br> [<span class="hljs-number">54</span>, <span class="hljs-number">92</span>, <span class="hljs-number">214</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ]/<span class="hljs-number">105</span><br> [<span class="hljs-number">250</span>, <span class="hljs-number">525</span>, <span class="hljs-number">650</span>, <span class="hljs-number">1375</span>, <span class="hljs-number">0</span> ]/<span class="hljs-number">504</span><br> [<span class="hljs-number">2315</span>, <span class="hljs-number">4558</span>, <span class="hljs-number">7296</span>, <span class="hljs-number">7834</span>, <span class="hljs-number">15797</span>]/<span class="hljs-number">4620</span> ]; <span class="hljs-comment">% 2-6 子样补偿系数</span><br> wmm = sum(wm,<span class="hljs-number">1</span>); vmm = sum(vm,<span class="hljs-number">1</span>); dphim = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>); scullm = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br> n = <span class="hljs-built_in">size</span>(wm, <span class="hljs-number">1</span>); <span class="hljs-comment">% 子样数</span><br><span class="hljs-keyword">if</span> n&gt;<span class="hljs-number">1</span><br> csw = cs(n<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>:n<span class="hljs-number">-1</span>)*wm(<span class="hljs-number">1</span>:n<span class="hljs-number">-1</span>,:); csv = cs(n<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>:n<span class="hljs-number">-1</span>)*vm(<span class="hljs-number">1</span>:n<span class="hljs-number">-1</span>,:);<br> dphim = <span class="hljs-built_in">cross</span>(csw,wm(n,:)); <span class="hljs-comment">% 圆锥补偿量</span><br> scullm = <span class="hljs-built_in">cross</span>(csw,vm(n,:))+<span class="hljs-built_in">cross</span>(csv,wm(n,:)); <span class="hljs-comment">% 划船补偿量</span><br> <span class="hljs-keyword">end</span><br>phim = (wmm+dphim)&#x27;;<br>dvbm = (vmm+<span class="hljs-number">0.5</span>*<span class="hljs-built_in">cross</span>(wmm,vmm)+scullm)&#x27;;<br><br></code></pre></td></tr></table></figure><p>IMU 的误差系统为无阻尼振荡系统，这里直接给出了一组精度较好的近似解析解，它全面包括了陀螺常值漂移误差、加速度计常值偏值误差、角度随机游走误差、速度随机游走误差。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[wm, vm]</span> = <span class="hljs-title">imuadderr</span><span class="hljs-params">(wm, vm, eb, web, db, wdb, ts)</span></span><br> m = <span class="hljs-built_in">size</span>(wm,<span class="hljs-number">1</span>); sts = <span class="hljs-built_in">sqrt</span>(ts);<br> wm = wm + [ ts*eb(<span class="hljs-number">1</span>) + sts*web(<span class="hljs-number">1</span>)*<span class="hljs-built_in">randn</span>(m,<span class="hljs-number">1</span>), ...<br> ts*eb(<span class="hljs-number">2</span>) + sts*web(<span class="hljs-number">2</span>)*<span class="hljs-built_in">randn</span>(m,<span class="hljs-number">1</span>), ...<br> ts*eb(<span class="hljs-number">3</span>) + sts*web(<span class="hljs-number">3</span>)*<span class="hljs-built_in">randn</span>(m,<span class="hljs-number">1</span>) ];<br> vm = vm + [ ts*db(<span class="hljs-number">1</span>) + sts*wdb(<span class="hljs-number">1</span>)*<span class="hljs-built_in">randn</span>(m,<span class="hljs-number">1</span>), ...<br> ts*db(<span class="hljs-number">2</span>) + sts*wdb(<span class="hljs-number">2</span>)*<span class="hljs-built_in">randn</span>(m,<span class="hljs-number">1</span>), ...<br> ts*db(<span class="hljs-number">3</span>) + sts*wdb(<span class="hljs-number">3</span>)*<span class="hljs-built_in">randn</span>(m,<span class="hljs-number">1</span>) ];<br><br><span class="hljs-comment">%在这里考虑了陀螺随机常值漂移误差 eb、角度随机游走误差 web，</span><br><span class="hljs-comment">%以及加速度计随机常值偏值误差 db、速度随机游走误差 wdb。</span><br><br></code></pre></td></tr></table></figure><h3 id="SINS-参数更新："><a href="#SINS-参数更新：" class="headerlink" title="SINS 参数更新："></a>SINS 参数更新：</h3><p>ins 的参数更新主要是基于角速度四元数微分方程的姿态更新算法；从 g 系变换到 n 系，在进行一次积分的速度更新算法；再积分一次得到的位置更新算法。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl">function [qnb, vn, <span class="hljs-keyword">pos</span>, eth] = insupdate(qnb, vn, <span class="hljs-keyword">pos</span>, wm, vm, ts)<br> nn = size(wm,<span class="hljs-number">1</span>); nts = nn*ts;<br> [phim, dvbm] = cnscl(wm, vm); % 圆锥误差/划船误差补偿<br> eth = earth(<span class="hljs-keyword">pos</span>, vn); % 地球相关参数计算<br> vn1 = vn + rv2m(-eth.wnin*nts/<span class="hljs-number">2</span>)*qmulv(qnb,dvbm) + eth.gcc*nts; % 速度更新<br> vn = (vn+vn1)/<span class="hljs-number">2</span>;<br> <span class="hljs-keyword">pos</span> = <span class="hljs-keyword">pos</span> + [vn(<span class="hljs-number">2</span>)/eth.RMh;vn(<span class="hljs-number">1</span>)/eth.clRNh;vn(<span class="hljs-number">3</span>)]*nts; % 位置更新<br> vn = vn1; <br> qnb = qmul(rv2<span class="hljs-string">q(-eth.wnin*nts)</span>, qmul(qnb, rv2<span class="hljs-string">q(phim)</span>)); % 姿态更新<br> qnb = qnormlz(qnb);<br><br></code></pre></td></tr></table></figure><h3 id="kalman-滤波器实现："><a href="#kalman-滤波器实现：" class="headerlink" title="kalman 滤波器实现："></a>kalman 滤波器实现：</h3><p><img src="/img/boxcnEfetsFyZkFI26r7EkoPYOb.png"></p><ol><li>先验估计 Xk 估&#x3D;A Xk-1 估 +μ Bk，其中状态转移矩阵决定了是不是线性系统</li><li>先验估计协方差 最优估计的协方差，会是上一个估计的协方差矩阵左乘右乘状态转移矩阵<br>cov(Ax,Ax)&#x3D;Acov(x,x)A^T</li><li>修正估计 右下角的公式，得到 kalman 滤波在最终值的值  Kk kalman 增益，决定了观测值的权</li><li>更新增益 Kk 左三公式。和 Q 和 R 都有关，性质就是 Q+R 作分母，那个方差小权重就高</li></ol><p>整体过程就是不断地预测、然后修正、更新值再给到下一次作预测、如此循环迭代。Q&amp;R  过程噪声方差矩阵 Q 模型理想与否   观测噪声 R 取决于传感器性能。由于 X0  P0 会迭代，可以取 X0&#x3D;0，P 小一点，方便收敛。</p><p>使用 kalman 滤波时的注意事项</p><ol><li>选择状态量、观测量</li><li>构建迭代方程</li><li>初始化参数</li><li>带入公式、进行迭代</li><li>适当调节超参数</li></ol><p>初始化：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">kf</span> = <span class="hljs-title">kfinit</span><span class="hljs-params">(Qk, Rk, P0, Phikk_1, Hk, Tauk)</span></span><br> [kf.m, kf.n] = <span class="hljs-built_in">size</span>(Hk);<br> kf.Qk = Qk; kf.Rk = Rk; kf.Pk = P0; kf.Xk = <span class="hljs-built_in">zeros</span>(kf.n,<span class="hljs-number">1</span>);<br> kf.Phikk_1 = Phikk_1; kf.Hk = Hk;<br> <span class="hljs-keyword">if</span> nargin&lt;<span class="hljs-number">6</span>, kf.Tauk = <span class="hljs-built_in">eye</span>(kf.n);<br> <span class="hljs-keyword">else</span> kf.Tauk = Tauk; <br> <span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><p>更新：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs routeros">function kf = kfupdate(kf, Zk, TimeMeasBoth)<br> <span class="hljs-keyword">if</span> <span class="hljs-attribute">nargin</span>==1, TimeMeasBoth = <span class="hljs-string">&#x27;T&#x27;</span>;<br> elseif <span class="hljs-attribute">nargin</span>==2, TimeMeasBoth = <span class="hljs-string">&#x27;B&#x27;</span>; end<br> <span class="hljs-keyword">if</span> <span class="hljs-attribute">TimeMeasBoth</span>==&#x27;T&#x27; || <span class="hljs-attribute">TimeMeasBoth</span>==&#x27;B&#x27; % 时间更新<br> kf.Xkk_1 = kf.Phikk_1*kf.Xk;<br> kf.Pkk_1 = kf.Phikk_1*kf.Pk*kf.Phikk_1<span class="hljs-string">&#x27; + kf.Tauk*kf.Qk*kf.Tauk&#x27;</span>;<br> <span class="hljs-keyword">else</span> % <span class="hljs-attribute">TimeMeasBoth</span>==&#x27;M&#x27;<br> kf.Xkk_1 = kf.Xk;<br> kf.Pkk_1 = kf.Pk; <br> end<br> <span class="hljs-keyword">if</span> <span class="hljs-attribute">TimeMeasBoth</span>==&#x27;M&#x27; || <span class="hljs-attribute">TimeMeasBoth</span>==&#x27;B&#x27; % 量测更新<br> kf.PXZkk_1 = kf.Pkk_1*kf.Hk<span class="hljs-string">&#x27;;</span><br><span class="hljs-string"> kf.PZkk_1 = kf.Hk*kf.PXZkk_1 + kf.Rk;</span><br><span class="hljs-string"> kf.Kk = kf.PXZkk_1/kf.PZkk_1;</span><br><span class="hljs-string"> kf.Xk = kf.Xkk_1 + kf.Kk*(Zk-kf.Hk*kf.Xkk_1);</span><br><span class="hljs-string"> kf.Pk = kf.Pkk_1 - kf.Kk*kf.PZkk_1*kf.Kk&#x27;</span>;<br> <span class="hljs-keyword">else</span> % <span class="hljs-attribute">TimeMeasBoth</span>==&#x27;T&#x27;<br> kf.Xk = kf.Xkk_1;<br> kf.Pk = kf.Pkk_1; <br> end<br> kf.Pk = (kf.Pk+kf.Pk<span class="hljs-string">&#x27;)/2; % P阵对称化</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h3 id="SINS-仿真主程序："><a href="#SINS-仿真主程序：" class="headerlink" title="SINS 仿真主程序："></a>SINS 仿真主程序：</h3><p>首先是初始化采样时间、初始导航参数，然后引入误差，并进行一定时长的导航参数仿真。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">nn</span> = <span class="hljs-number">2</span><span class="hljs-comment">; ts = 0.1; nts = nn*ts; % 子样数和采样时间</span><br><span class="hljs-attr">att</span> = [<span class="hljs-number">0</span><span class="hljs-comment">; 0; 30]*arcdeg; </span><br>vn = [<span class="hljs-number">0</span><span class="hljs-comment">;0;0]; </span><br>pos = [<span class="hljs-number">40</span>*arcdeg<span class="hljs-comment">; 116*arcdeg; 100];</span><br>qnb = a2qua(att)<span class="hljs-comment">; % 姿态、速度和位置初始化</span><br><br>eth = earth(pos, vn)<span class="hljs-comment">;</span><br>wm = qmulv(qconj(qnb),eth.wnie)*ts<span class="hljs-comment">; vm = qmulv(qconj(qnb),-eth.gn)*ts;</span><br>wm = repmat(wm<span class="hljs-string">&#x27;, nn, 1); vm = repmat(vm&#x27;</span>, nn, <span class="hljs-number">1</span>)<span class="hljs-comment">; </span><br>phi = [<span class="hljs-number">0.1</span><span class="hljs-comment">; 0.2; 3]*arcmin; qnb = qaddphi(qnb, phi); % 失准角</span><br>eb = [<span class="hljs-number">0.01</span><span class="hljs-comment">;0.015;0.02]*dph; web = [0.001;0.001;0.001]*dpsh; % 陀螺常值零偏，角度随机游走系数</span><br>db = [<span class="hljs-number">80</span><span class="hljs-comment">;90;100]*ug; wdb = [1;1;1]*ugpsHz; % 加速度计常值偏值，速度随机游走系数</span><br>qnb = qaddphi(qnb, phi)<span class="hljs-comment">;% 仿真静态IMU数据</span><br><br>len = fix(<span class="hljs-number">3600</span>/ts)<span class="hljs-comment">; % 仿真时长</span><br>avp = zeros(len, <span class="hljs-number">10</span>)<span class="hljs-comment">; kk = 1; t = 0; % 记录导航结果 [att, vn, pos, t]</span><br>for k=<span class="hljs-number">1</span>:nn:len<br> t = t + nts<span class="hljs-comment">;</span><br> [wm, vm] = imuadderr(wm, vm, eb, web, db, wdb, ts)<span class="hljs-comment">;</span><br> [qnb, vn, pos] = insupdate(qnb, vn, pos, wm, vm, ts)<span class="hljs-comment">; </span><br> vn(<span class="hljs-number">3</span>) = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>avp(kk,:) = [q2att(qnb)<span class="hljs-comment">; vn; pos; t]&#x27;; </span><br>kk = kk+<span class="hljs-number">1</span><span class="hljs-comment">;</span><br>end<br><br></code></pre></td></tr></table></figure><p>加入磁强计定位和卡拉曼滤波：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs matlab">nn = <span class="hljs-number">2</span>; ts = <span class="hljs-number">0.1</span>; nts = nn*ts; <span class="hljs-comment">% 子样数和采样时间</span><br>att0 = [<span class="hljs-number">0</span>; <span class="hljs-number">0</span>; <span class="hljs-number">30</span>]*arcdeg; qnb0 = a2qua(att0); vn0 = [<span class="hljs-number">0</span>;<span class="hljs-number">0</span>;<span class="hljs-number">0</span>]; pos0 = [<span class="hljs-number">34</span>*arcdeg; <span class="hljs-number">108</span>*arcdeg; <span class="hljs-number">100</span>];<br>qnb = qnb0; vn = vn0; pos = pos0; <span class="hljs-comment">% 姿态、速度和位置初始化</span><br>eth = earth(pos, vn);<br>wm = qmulv(qconj(qnb),eth.wnie)*ts; vm = qmulv(qconj(qnb),-eth.gn)*ts;<br>wm = <span class="hljs-built_in">repmat</span>(wm&#x27;, nn, <span class="hljs-number">1</span>); vm = <span class="hljs-built_in">repmat</span>(vm&#x27;, nn, <span class="hljs-number">1</span>); <span class="hljs-comment">% 静态IMU数据</span><br><br><span class="hljs-comment">%phi = [0.1; 0.2; 3]*arcmin; qnb = qaddphi(qnb, phi); % 失准角</span><br>eb = [<span class="hljs-number">0.01</span>;<span class="hljs-number">0.015</span>;<span class="hljs-number">0.02</span>]*dph; web = [<span class="hljs-number">0.001</span>;<span class="hljs-number">0.001</span>;<span class="hljs-number">0.001</span>]*dpsh; <span class="hljs-comment">% 陀螺常值零偏，角度随机游走系数</span><br>db = [<span class="hljs-number">80</span>;<span class="hljs-number">90</span>;<span class="hljs-number">100</span>]*ug; wdb = [<span class="hljs-number">1</span>;<span class="hljs-number">1</span>;<span class="hljs-number">1</span>]*ugpsHz; <span class="hljs-comment">% 加速度计常值偏值，速度随机游走系数</span><br><br>Qk = <span class="hljs-built_in">diag</span>([web; wdb; <span class="hljs-built_in">zeros</span>(<span class="hljs-number">9</span>,<span class="hljs-number">1</span>)])^<span class="hljs-number">2</span>*nts;<br>rk = [[<span class="hljs-number">0.1</span>;<span class="hljs-number">0.1</span>;<span class="hljs-number">0.1</span>];[[<span class="hljs-number">10</span>;<span class="hljs-number">10</span>]/Re;<span class="hljs-number">10</span>]]; Rk = <span class="hljs-built_in">diag</span>(rk)^<span class="hljs-number">2</span>;<span class="hljs-comment">%kalman 误差矩阵</span><br>P0 = <span class="hljs-built_in">diag</span>([[<span class="hljs-number">0.1</span>;<span class="hljs-number">0.1</span>;<span class="hljs-number">10</span>]*arcdeg; [<span class="hljs-number">1</span>;<span class="hljs-number">1</span>;<span class="hljs-number">1</span>]; [[<span class="hljs-number">10</span>;<span class="hljs-number">10</span>]/Re;<span class="hljs-number">10</span>]; [<span class="hljs-number">0.1</span>;<span class="hljs-number">0.1</span>;<span class="hljs-number">0.1</span>]*dph; [<span class="hljs-number">100</span>;<span class="hljs-number">100</span>;<span class="hljs-number">100</span>]*ug])^<span class="hljs-number">2</span>;<br>Hk = [<span class="hljs-built_in">zeros</span>(<span class="hljs-number">6</span>,<span class="hljs-number">3</span>),<span class="hljs-built_in">eye</span>(<span class="hljs-number">6</span>),<span class="hljs-built_in">zeros</span>(<span class="hljs-number">6</span>)];<span class="hljs-comment">%初始增益矩阵</span><br>kf = kfinit(Qk, Rk, P0, <span class="hljs-built_in">zeros</span>(<span class="hljs-number">15</span>), Hk); <span class="hljs-comment">% kf滤波器初始化</span><br><br>len = <span class="hljs-built_in">fix</span>(<span class="hljs-number">3600</span>/ts); <span class="hljs-comment">% 仿真时长</span><br>avp = <span class="hljs-built_in">zeros</span>(len, <span class="hljs-number">10</span>); xkpk = <span class="hljs-built_in">zeros</span>(len, <span class="hljs-number">2</span>*kf.n+<span class="hljs-number">1</span>); kk = <span class="hljs-number">1</span>; t = <span class="hljs-number">0</span>; <span class="hljs-comment">% 记录导航结果</span><br><span class="hljs-keyword">for</span> k=<span class="hljs-number">1</span>:nn:len<br> t = t + nts;<br> [wm1, vm1] = imuadderr(wm, vm, eb, web, db, wdb, ts);<br> [qnb, vn, pos, eth] = insupdate(qnb, vn, pos, wm1, vm1, ts);<br> kf.Phikk_1 = <span class="hljs-built_in">eye</span>(<span class="hljs-number">15</span>) + kfft15(eth, q2mat(qnb), sum(vm1,<span class="hljs-number">1</span>)&#x27;/nts)*nts;<br> kf = kfupdate(kf);<br> <span class="hljs-keyword">if</span> <span class="hljs-built_in">mod</span>(t,<span class="hljs-number">1</span>)&lt;nts<br> mag = [vn0; pos0] + rk.*<span class="hljs-built_in">randn</span>(<span class="hljs-number">6</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">% 速度位置仿真</span><br> kf = kfupdate(kf, [vn;pos]-mag, <span class="hljs-string">&#x27;M&#x27;</span>);<br> vn(<span class="hljs-number">3</span>) = vn(<span class="hljs-number">3</span>) - kf.Xk(<span class="hljs-number">6</span>); kf.Xk(<span class="hljs-number">6</span>) = <span class="hljs-number">0</span>; <span class="hljs-comment">% ·反馈</span><br> <span class="hljs-keyword">end</span><br> avp(kk,:) = [qq2phi(qnb,qnb0); vn; pos; t]&#x27;;<br> xkpk(kk,:) = [kf.Xk; <span class="hljs-built_in">diag</span>(kf.Pk); t]; kk = kk+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><h2 id="结果讨论"><a href="#结果讨论" class="headerlink" title="结果讨论"></a>结果讨论</h2><h3 id="kalman-滤波效果"><a href="#kalman-滤波效果" class="headerlink" title="kalman 滤波效果"></a>kalman 滤波效果</h3><p>未使用 kalman 滤波时的导航结果：</p><p><img src="/img/boxcn6XiLGgzwy2m8ncFPeKqDed.png"></p><p>可以看到无论是方向角还是速度、位置参数，都是发散较大的，结果几乎无法使用。</p><p>在引入磁强计信号定期更新观测矩阵的 kalman 滤波器后，可以看到导航的结果有较好的收敛：误差量级比之前小了几个量级。</p><p><img src="/img/boxcnZvDyRriQcD8tr5GKlMEkPf.png"></p><h3 id="修正参数精度对估计影响"><a href="#修正参数精度对估计影响" class="headerlink" title="修正参数精度对估计影响"></a><strong>修正参数精度对估计影响</strong></h3><p>用于修正累积误差的磁强计传感器不同的精度，会导致修正结果的不同。主要结论是：修正的结果都能收敛，但是稳定后的误差限以及收敛速度不同。磁强计精度越高，收敛越快，收敛后误差越小。</p><p><img src="/img/boxcnSaet0xzVI0nYdveCDVNGSe.png"></p><h3 id="误差矩阵更新度对结果的影响"><a href="#误差矩阵更新度对结果的影响" class="headerlink" title="误差矩阵更新度对结果的影响"></a>误差矩阵更新度对结果的影响</h3><p>在实际的计算过程中，实时更新误差矩阵能带来更好的估计。在仿真代码中不进行 QR 矩阵更新，也能收敛，但是收敛效果不好。</p><p><img src="/img/boxcnv3Y9yLd6880JXTckf4ZqAb.png"></p><p><img src="/img/boxcnO54ViMuRdejfO52wnAOnzf.png"></p><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ol><li>没有基于磁强计参数计算初始姿态以及实时航向角信息。<br>在仿真过程中，磁强计的修正结果直接以精确值 + 随机误差的形式给出，而不是通过三轴磁强参数通过一定的计算方法给出，距离实际应用的算法还有待改进。</li><li>由于没有计算磁强计的组合系统，系统仍是线性的，没有用到 EKF、UKF 等算法。</li></ol><p>实际组合导航系统的量测矩阵会是非线性的，目前也有很多关于非线性卡尔曼滤波器的研究。但是目前的仿真系统作了一定的简化，没有用到扩展卡尔曼滤波器等方法。</p><ol><li>误差都是理论的正态分布随机误差，是仿真模型，没有获得实际传感器信号输入。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>课程学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【课程学习】信号分析处理</title>
    <link href="/2022/11/17/%E3%80%90%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86/"/>
    <url>/2022/11/17/%E3%80%90%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>测试信号分析与处理课程笔记</p><h2 id="WEEK3-DFS"><a href="#WEEK3-DFS" class="headerlink" title="WEEK3 DFS"></a>WEEK3 DFS</h2><p>一些简单的性质：线性、奇偶虚实 - 实信号 频域幅值偶对称相位奇对称</p><p>对于一个 δ 信号，频谱是一个 A&#x3D;1 横线 ；直流信号的频谱是 2pi δ</p><p>时域乘 exp(jωt) 频域频移 -ω  ；时移 to 频 AXexp(jωto) 相位变化</p><p>时域拉伸  频域 f 变窄 ，同时幅值 a 压缩</p><p>时域卷积 等于 频域相乘</p><p>相关： 频谱  X*Y</p><p>离散信号的频谱是周期函数  DTFT Discrete-time Fourier Transform</p><p>所有有限长的信号 可以看作无限长加矩形窗  窗会导致频谱出现失真</p><p>所以在时域内对信号截断时，窗长会影响频谱分辨率  窗长太短会导致频谱分辨率过低</p><p><img src="/img/boxcnqVhVYo9hzLmBtz82R0PNQe.png"></p><p><img src="/img/boxcngCYTtALcBGuFa5oUjzgctg.png"></p><h2 id="WEEK5-DFT"><a href="#WEEK5-DFT" class="headerlink" title="WEEK5 DFT"></a>WEEK5 DFT</h2><p>FS 连续周期信号的傅里叶级数</p><p>FT  DTFT</p><p>DFS 离散周期信号的离散 Fourier</p><p><img src="/img/boxcniOAQLEg2AxE3reTCxSn1eg.png"></p><p>DFT：在做 DFS 时  取一个周期表征信号</p><p>DFT 是 DFS 简化的表达；这是表征的周期信号的一个运算。</p><p>计算机的数组（时域 or 频域）只有 离散、有限长   计算机的处理结果 需要周期延拓</p><p>离散傅里叶变换，实质上是用来表征离散傅里叶级数的。。</p><p>工程信号：截取、采样离散化；本质上是采样到一段连续有限长的信号，然后离散、作 DTFT  ，然后频域周期延拓并离散化，相当于时域卷积频域采样脉冲。最后就是 DFS 离散周期 -》离散周期。最后再取一个周期，计算机中的 DFT</p><p>DFT 后的坐标轴 0~fs 间隔是 fs&#x2F;N；</p><p>实信号 幅值谱关于频率 N&#x2F;2 偶对称  幅值谱奇对称</p><p>移位：相位变化 ； 卷积：循环卷积  离散卷积的矩阵 对角线上也有内容。y(n)&#x3D;x(n)卷积 h(n)</p><p>DFT 对应的是循环卷积；可以通过一定的变换计算线性卷积 ，线性卷积的原序列 x(n) h(m) 都补 0 到 n+m-1 的长度，再作 DFT 频域相乘再 IDFT</p><p>DFT 的分辨率？</p><p>分辨率和哪些因素有关？仅仅是采样点数 N 和采样频率 fs 吗？需要考虑频率分辨率和时间分辨率。</p><p>频谱分析的算法也会影响分辨率。</p><p>FT 的频域分辨率，由截断长度决定，矩形窗第一个过零点 2pi&#x2F;T。DTFT 会多出一个采样，2pi&#x2F;N。主瓣宽度-分辨率，也是由采样点数 N 决定。都是时域长度越长，频域分辨率越高。分辨率不够会导致谱泄露。</p><p>对于 DFT，也是由采样频率和采样点数确定。 fs&#x2F;N&lt;&#x3D;Δf</p><p>当截图的时间长度不变，增加采样点能提高分辨率。-？ 有用，但不明显</p><p>补 0–？通过补 0 能增加采样点数。但是只能提高计算分辨率，但是实际没啥用。但是当数据过短，可以起到一定的“插值”作用，计算间隔会变密集，减小栅栏效应。看起来更舒服，但本质分辨率不够补 0 也没办法解决的。</p><p>此外，补 0 到 2 的整数次幂，有利于 FFT 的计算。</p><p>进行 DFT 时，先确定 fs。一般会高于 10fc。</p><p>对周期信号进行截取要尽量整周期截取。不能补 0。采样点数最好是 2 的整数次幂。</p><p>FFT  W&#x3D;e-j 2pi&#x2F;N  利用周期性和对称性</p><h2 id="WEEK6-随机系统-线性系统"><a href="#WEEK6-随机系统-线性系统" class="headerlink" title="WEEK6 随机系统&amp;线性系统"></a>WEEK6 随机系统&amp;线性系统</h2><p>随机信号的某些数学特征值可能是不变的  需要统计特性</p><p>平稳随机过程：随机过程的统计特征不随时间变化</p><p>平稳随机过程判据：均值与 t 无关，Rxx 与时间起点无关</p><p>严格的平稳随机过程：概率密度函数不随采样时刻变化；平稳随机过程的统计特征不依赖于采样时刻</p><p>数学特征：均值、均方值、方差、相关函数、协方差；功率谱密度函数</p><p>遍历：一定是平稳的随机信号，各态历经，可以用任意一个样本的全部时间历程数学特征描述</p><p>概率密度函数  Px  概率分布函数 Fx  Px&#x3D;dFx&#x2F;dx</p><p>均值：m ； m_x&#x3D;E(X(n))&#x3D;∫ xp(x,n)dx</p><p>均方值： ψ^2_x (t) &#x3D; E(x(t)^2)</p><p>方差： σ^2_x (t) &#x3D; E((X-u)^2)&#x3D;ψ^2-u^2</p><p>自相关函数：Rxx&#x3D;E(X(n)X(n+m))  性质：偶函数，极大值在 0 取得，R(0)&#x3D;ψ^2  R(∞)&#x3D;u^2 ;</p><p>互相关函数：Rxy&#x3D;E(X(n)Y(n+m))  实 平稳信号的互相关：Rxy(τ)&#x3D;Ryx(-τ)</p><p>协方差函数：可以描述两个随机变量的线性独立关系、正交关系及相关系数。</p><p>随机信号在频域的特性：</p><p><img src="/img/boxcn7BAiij4Ix64Ws0zhsLbCSd.png"></p><p>频域 功率谱</p><p>线性系统</p><p><img src="/img/boxcnYHRimLV7LBN0ClOYpb8QVe.png"></p><p><img src="/img/boxcn23klKItgvmQISiZuxhEG2c.png"></p><p>输入过程与输出过程的互相关函数等 于系统的冲激响应函数与输入过程的 自相关函数之卷积积分</p><p>平稳随机信号– 自功率谱密度函数 《&#x3D;》 自相关函数  傅里叶变换对</p><p><img src="/img/boxcnkZItfOwbXFoHvEf4Ic2XLf.png"></p><p>预测 辨识  诊断；</p><h2 id="功率谱经典估计法"><a href="#功率谱经典估计法" class="headerlink" title="功率谱经典估计法"></a>功率谱经典估计法</h2><p>用数字特征判断平稳；估计-计算方法 ；用偏差和方差进行估计</p><p>平稳随机过程-用数字特征表示，与时间起点无关；各态历经–</p><p>相关函数的估计：</p><p><img src="/img/boxcnw3dFaCP8fjrqCF9GCycR7c.png"></p><p>上面这张图展示的是 FFT 作快速自相关估计</p><p>注意补 0 – 线性卷积 补到 2n</p><p><img src="/img/boxcnR7ipeuN50NzuqjmolBSEJg.png"></p><p>自相关函数  Rxx 保留同频的周期性</p><p>xcorr MATLAB 求相关函数的函数</p><p>应用：信号分析</p><p>心电信号的检查-自相关函数估计信噪比-人体运动检测-</p><p>对信号采样时，理想情况当然是频谱 δ 函数（时域 C），但大多数时候都是 sinc 函数，即时域窗函数采样。</p><p>加窗： 实际就是如何安排时间窗内的权值 ； 使信号在窗的边缘为 0 ，以减少由于截取所产生的波形不连续效应 ；我们希望信号经过窗函数加权后，不要丢失太多信息</p><p>对平稳随机信号，功率谱密度函数 与 相关函数 互为傅立叶变换对</p><p>周期图法 (Periodogram) 直接建立在功 率谱的定义式上。(直接法) ；作 FFT 后求模平方&#x2F;N</p><p>自相关法：功率谱密度函数 与 相关函数 互为傅立叶变换对 ；对信号补 0、求线性卷积、求模平方 ÷N</p><p>两种方法原理本质上是相同的。渐进无偏的非一致估计，方差不为 0</p><p>自相关函数-时域中的卷积-DFT-频域中的乘积-IDFT-自相关函数</p><p><img src="/img/boxcnZa17nq6FK2oYRWemvWOgpd.png"></p><p>功率谱估计：样本在单位频带内的平均功率</p><p>功率谱密度和自相关函数是傅里叶变化对</p><p>为什么要估计功率谱？这是一个频域分析的重要方法，做频谱分析的 FFT 要求是能量有限的信号，但很多周期信号往往不是；但大多数信号都是功率有限的，适用情况更广；功率谱有平方环节，能够加大主要信号和干扰的数值差；用偏差和方差评估质量。</p><p>谱估计的周期图法</p><p>直接法  频谱功率谱定义式</p><p>间接法 维纳辛钦公式 求自相关谱再 DFT</p><p>改进：</p><p>method1：加窗平滑法 ：先作自相关估计 Rxx，再选取合适的窗截取 vm，最后作 DFT</p><p>偏差会变大，但是会渐进无偏 方差性能有明显提升，是有效估计。方差的减小是以牺牲分辨率为代价的！</p><p>方法 2：平均周期图法，K 个独立同分布的随机变量的均值方差，等于单个变量方差的 1&#x2F;K</p><p>长数据 N 分成 K 段，每段 M &#x3D; N &#x2F; K，每 段用周期图法求谱 ，然后求平均</p><p>独立性不是很好满足；渐进一致估计，改善了方差性能</p><p>功率谱，隐含的就是用一组数据遍历，所以分析的数据会有一些震荡。</p><p>K↑, M↓, 偏差大, 方差小,  谱曲线平滑；反之，曲线起伏激烈，谱线的尖 峰保留。</p><p>几种求功率谱的方法及其改进；主要目的是让谱方差趋于零，有效估计</p><p>welch 普估计法：</p><p>把 N 个数据分成 N 段，每段相互独立，也可以互相交叠； 再把每段数据乘上窗函数 ，作 IDFT 后求平均</p><p>直接计算的谱估计方差不趋于零，无效估计；计算量也比较大，可以用自相关函数变换；基本的出发点是分更多段使方差减小，同时选择窗优化。</p><p><img src="/img/boxcn3wBeYbJpfjUREgT6qlff9g.png"></p><p>评价：渐近无偏一致估计</p><p>周期图法和自相关法等效，渐近无偏非一致估计</p><p><img src="/img/boxcn4xGer0VmS5JsDcgca0wXGh.png"></p><h2 id="现代功率谱估计方法"><a href="#现代功率谱估计方法" class="headerlink" title="现代功率谱估计方法"></a>现代功率谱估计方法</h2><p>经典功率谱的估计，方差与分辨率之间存在矛盾。</p><p>现代功率谱估计，主要是通过一个系统建模的方法，保证分辨率的同时减小方差</p><p>白噪声输入，经过线性系统，由输出得到功率谱</p><p>构造线性系统模型；用的最多的是 AR 模型，全极点、</p><p>用白噪声 u 激励线性系统产生信号 x，得到线性系统的参数；进而 可以估计功率谱</p><p>对应的算法，需要由实际的应用背景，了解算法的数学原理与基本概念</p><p>谱分析能干嘛</p><p>判断、识别；故障检测；生物电信号解析</p><h2 id="仿真实验-1"><a href="#仿真实验-1" class="headerlink" title="仿真实验 1"></a>仿真实验 1</h2><p>主要功能：利用 FFT 作相关估计</p><p>基本原理：</p><p><img src="/img/boxcnf8Xwpg44Ux317zzczyfvxf.png"></p><p>算法步骤：</p><p>1.对原序列补 N 个零，得到新序列</p><p>2.对 补零后的 X2N 作 FFT 得到 频谱</p><p>3,求模后除以 N，得到自相关频谱</p><p>4.对 1&#x2F;N |X2N(k)| 作 IFFT 得到 估计的自相关谱</p><p>5.变换位置得到 Rxx</p><h2 id="仿真实验-2"><a href="#仿真实验-2" class="headerlink" title="仿真实验 2"></a>仿真实验 2</h2><h2 id="滤波器设计"><a href="#滤波器设计" class="headerlink" title="滤波器设计"></a>滤波器设计</h2><p>主要是学了滤波器的重要参数，巴特沃夫 切比雪夫 模拟低通滤波器的设计过程；中间需要归一化传递函数；通过一些简单的变换可以把低通滤波器的传递函数转化为高通或者带通滤波器。</p><p><img src="/img/boxcnN5P52yLqs1DnWwjyVFl5Xf.png"></p><p>在数字滤波器的实现方法上，分为无限冲激响应（IIR）滤波器和有限冲激响应（FIR） 滤波器。这两种滤波器在性能上和设计方法上都存在很大区别</p><p><img src="/img/boxcnwEuqIEa7Hz7S50ZwhsjRvb.png"></p><p>指标参数确定后，模拟滤波器设计的任务就是设法构建一个 传输函数 H s，使其传输特性满足给定的技术指标</p><p><img src="/img/boxcnTHxSkd5fqSqJ040Ih02tvb.png"></p><p>滤波器的设计一般先设计出原型低通滤 波器，再经过频率变换法转换成所需要的其它类型滤波器</p><p>一般设计上要求 αp&#x3D;3dB，代入上式得 A&#x3D;1</p><p><img src="/img/boxcnmrOtiushvLIhy7Mr11FUVd.png"></p><p>将模拟滤波器变换成数字滤波器，实际上是按照模拟滤波器的设计，在保留满足要求的 模拟频率响应的主要特性前提下，设法得到数字滤波器的系统函数 H z( ) 或冲激响应序列 h n( ) 。或者说，要求把 s 平面上的虚轴映射成 z 平面上的单位圆，为了保证数字滤波器也 是稳定的，若模拟系统只在 s 左半平面有极点，则数字滤波器也必须仅在单位圆内有极点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>课程学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【IOT开发】ESP-IDF&amp;ADF 音频开发</title>
    <link href="/2022/11/17/%E3%80%90IOT%E5%BC%80%E5%8F%91%E3%80%91ESP-IDF&amp;ADF%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/11/17/%E3%80%90IOT%E5%BC%80%E5%8F%91%E3%80%91ESP-IDF&amp;ADF%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>ESP32 的音频应用开发框架。主要了解 ADF 的架构、使用、以及注意事项。</p><p>适用 MCU：ESP32, ESP32-S2, and ESP32-S3</p><p>ESP-ADF 是 IDF(Espressif IoT Development Framework)在音频应用方面的一系列扩展组件。所以得先搭好 IDF 环境，再搭建 ADF 环境。</p><h1 id="ADF-框架："><a href="#ADF-框架：" class="headerlink" title="ADF 框架："></a>ADF 框架：</h1><p><img src="/img/boxcnelXuci48oqORdK7xtv1qbd.png"></p><p><img src="/img/boxcnA4WrZljxiFkeDNlKpL1qSc.png"></p><p>几个重要的 element：streams，codecs，audio processing。这是在构建音频应用时主要考虑的功能元素。而一个功能应用需要一个 pipeline 把各个元素串起来，上图就是把 MP3decoder 和 I2S stream 结合，实现一个从 mp3 文件读数据并播放的功能。</p><p>The basic building block for the application programmer developing with ADF is the audio element object. 都被封装成了对象，对象会提供对应的 API。</p><p>元素的一般功能是接受一些数据的输入，对其进行处理，并输出到下一个程序。每个元素都能够单独运行。为了能够控制数据生命周期的特定阶段，从输入、处理到输出的过程中，element 对象提供了在每个阶段触发回调的接口。</p><p>例如一个蓝牙耳机的程序，会用到 bt_stream，从 A2DP 协议读数据；再使用 I2S_STREAM 把数据输给解码芯片：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">...<br>  audio_element_handle_t bt_stream_reader, i2s_stream_writer;<span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span><span class="hljs-comment">//配置a2dp_config  用以初始化 bt_stream_reader element</span><br>  a2dp_stream_config_t a2dp_config = &#123;<br>      .<span class="hljs-keyword">type</span> = AUDIO_STREAM_READER,<br>      .user_callback = &#123;<span class="hljs-number">0</span>&#125;,<br>  &#125;;<br>  bt_stream_reader = a2dp<span class="hljs-constructor">_stream_init(&amp;<span class="hljs-params">a2dp_config</span>)</span>;<br>  <br>  ...<span class="hljs-comment">//然后调用element接口，把从BT来的A2DP数据给element data</span><br>  audio<span class="hljs-constructor">_pipeline_register(<span class="hljs-params">pipeline</span>, <span class="hljs-params">bt_stream_reader</span>, <span class="hljs-string">&quot;bt&quot;</span>)</span>;<br>  <br>  <span class="hljs-comment">//之后再把 bt stream 元素作为audioinfo输入</span><br>  audio<span class="hljs-constructor">_element_getinfo(<span class="hljs-params">bt_stream_reader</span>, &amp;<span class="hljs-params">music_info</span>)</span>;<br>  <br>  <span class="hljs-comment">//i2s_stream_writer 元素也是类似的流程</span><br>  i2s_stream_cfg_t i2s_cfg = <span class="hljs-constructor">I2S_STREAM_CFG_DEFAULT()</span>;<br>  i2s_cfg.<span class="hljs-keyword">type</span> = AUDIO_STREAM_WRITER;<br>  i2s_stream_writer = i2s<span class="hljs-constructor">_stream_init(&amp;<span class="hljs-params">i2s_cfg</span>)</span>;<br>  <br>  audio<span class="hljs-constructor">_pipeline_register(<span class="hljs-params">pipeline</span>, <span class="hljs-params">i2s_stream_writer</span>, <span class="hljs-string">&quot;i2s&quot;</span>)</span>;<br>  i2s<span class="hljs-constructor">_stream_set_clk(<span class="hljs-params">i2s_stream_writer</span>, 48000, 16, 2)</span>;<br>  audio<span class="hljs-constructor">_element_setinfo(<span class="hljs-params">i2s_stream_writer</span>, &amp;<span class="hljs-params">music_info</span>)</span>;<br><br></code></pre></td></tr></table></figure><p>过程中会有一个步骤： audio_pipeline_register，把元素绑定到 pipeline 上。pipeline 上的元素是动态的，例如上面的例程就没有 decoder 元素。</p><p>之所以叫做 pipeline，管道内流通的是 data，而把元素 register 上去，类似于提供 data 水流的出入口。</p><p>在注册好各种元素后，就可以 audio_pipeline_run(pipeline)，让数据流起来，输出端也就能 work 了。此外，pipeline 还提供了 pause，resume，stop 等接口控制播放。</p><p>使用 ADF 最重要就是要有数据流的概念。</p><p>数据流支持的来源有：</p><ul><li><a href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/api-reference/streams/index.html#api-reference-stream-algorithm">算法流</a></li><li><a href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/api-reference/streams/index.html#fatfs">FatFs 流</a></li><li><a href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/api-reference/streams/index.html#http">HTTP 流</a></li><li><a href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/api-reference/streams/index.html#i2s">I2S 流</a></li><li><a href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/api-reference/streams/index.html#pwm">PWM 流</a></li><li><a href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/api-reference/streams/index.html#api-reference-stream-raw">原始流</a></li><li><a href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/api-reference/streams/index.html#spiffs">SPIFFS 流</a></li><li><a href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/api-reference/streams/index.html#tcp">TCP 客户端流</a></li><li><a href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/api-reference/streams/index.html#api-reference-stream-tone">提示音流</a></li><li><a href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/api-reference/streams/index.html#api-reference-embed-flash">嵌入式二进制文件流</a></li><li><a href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/api-reference/streams/index.html#api-reference-stream-tts">语音合成流</a></li></ul><p>只需要关注各个流的初始化方法和读写方法。</p><p>编解码器</p><p>编码器，把采集的 PCM 编码，ADF 只支持 AMR 和 WAV 编码。</p><p>支持 AAC AMR FLAC MP3 OGG OPUS WAV 解码。</p><p>这个也封装的很好，使用解码器时候只要调用相应的初始化函数，生成 element，再绑定到 pipeline 上就好了。</p><p>audio 操作</p><p>可以对音频流进行一些额外操作，例如混音、均衡器、更改采样通道、</p><ul><li>Combine contents of two audio streams using <a href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/api-reference/audio-processing/downmix.html">Downmix</a></li><li>Apply ten band <a href="https://docs.espressif.com/projects/esp-adf/zh_CN/latest/api-reference/audio-processing/equalizer.html">Equalizer</a></li></ul><p>例如配置混音，需要先建立两个 pipeline，然后作为 downmix 的输入</p><p><img src="/img/boxcnfpzxU9ZGEA2ULDl0zmBMrf.png"></p><p>服务</p><p>服务 (service) 是具体产品功能在软件层面上的实现，如输入按键、网络配置管理、电池检测等功能。例如，想要在做的蓝牙耳机上加按键 调整音量、切歌的功能，就得使用蓝牙 service 配置。更具体的是 Bluetooth service 中的音视频远程控制规范 (Audio Video Remote Control Profile, AVRCP)。</p><p>在 ADF 框架中 AVRCP 是和 A2DP stream 封装在一起的。触发相应的服务控制，直接调用 api 即可。当然也可调用 <a href="https://github.com/espressif/esp-adf/blob/3914444/components/bluetooth_service/include/bluetooth_service.h">bluetooth_service.h</a> 中的 api 去实现 AVRCP 服务。</p><p>在实际应用中需要一定的外部事件来触发 bt service，例如 <a href="https://github.com/espressif/esp-adf/blob/3914444/components/input_key_service/include/input_key_service.h">input_key_service.h</a> 中关于按键输入的服务，其实就是把 GPIO 电位中断 ADC 时间中断等封装了一下，做成 periph 外设的功能服务。</p><h2 id="工程设计："><a href="#工程设计：" class="headerlink" title="工程设计："></a>工程设计：</h2><p>使用 ESP-ADF 开发音频应用工程，大致的思路是：紧跟音频数据流。</p><p>数据输入可以从麦克风、本地存储、wifi、bt、I2S 输入、flash；数据输出也可以是以上通道。</p><p>如果可接受 8 位的数据输出，我们可使用两个板载 DAC 实现；如果需要更好的音频质量和更多的接口选项，可使用外部 I2S 编解码器来完成所有模拟输入和输出信号的处理。</p><p><a href="http://iot-bits.com/wp-content/uploads/2017/06/I2SBUS.pdf">I2S</a> 是音频编解码器芯片接口的行业标准，通常用于高速、连续传输音频数据。为了优化音频数据处理的性能，可能需要额外的内存。对于这种情况，请考虑使用 8 MB PSRAM 。开发板与软件之间的交互由音频 HAL 和驱动程序完成。</p><p>不同的编码格式-WAV, MP3 or FLAC 和采样率位深需要不同的内存需求。</p><p>可以使用 SPI RAM 作为扩展，需要在组件配置 &gt;SPI RAM 配置下的 menucofig 中启用它。</p><p>同时：Bluetooth and Wi-Fi can not coexist without PSRAM because it will not leave enough memory for an audio application.</p><h2 id="UART-数据流作为输入-pipeline-element"><a href="#UART-数据流作为输入-pipeline-element" class="headerlink" title="UART 数据流作为输入 pipeline element"></a>UART 数据流作为输入 pipeline element</h2><p>参考 element 的结构体 构建自定义 PCM 数据输入流的 element<br>还在开发中。</p><h1 id="esp-idf-component搭建"><a href="#esp-idf-component搭建" class="headerlink" title="esp-idf_component搭建"></a>esp-idf_component搭建</h1><p>ESP-IDF搭建自己的工程组件，需要了解sdkconfig文件、cmakelist文件的配置，系统驱动的过程。<br>具体见<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v4.1/api-guides/build-system.html#cmake">官方文档</a></p><h2 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h2><p>本文将会介绍 ESP32 从上电到运行 <code>app_main</code> 函数中间所经历的步骤（即启动流程）。</p><p>宏观上，该启动流程可以分为如下 3 个步骤：</p><ol><li>一级引导程序 被固化在了 ESP32 内部的 ROM 中，它会从 flash 的 0x1000 偏移地址处加载二级引导程序至 RAM (IRAM &amp; DRAM) 中。</li><li>二级引导程序 从 flash 中加载分区表和主程序镜像至内存中，主程序中包含了 RAM 段和通过 flash 高速缓存映射的只读段。</li><li>应用程序启动阶段 运行，这时第二个 CPU 和 RTOS 的调度器启动。</li></ol><p>硬件和基本 C 语言运行环境的端口初始化。</p><p>软件服务和 FreeRTOS 的系统初始化。</p><p>运行主任务并调用 <code>app_main</code>。</p><p>与普通的 FreeRTOS 任务（或嵌入式 C 的 <code>main</code> 函数）不同，<code>app_main</code> 任务可以返回。如果 <code>app_main</code> 函数返回，那么主任务将会被删除。系统将继续运行其他的 RTOS 任务。因此可以将 <code>app_main</code> 实现为一个创建其他应用任务然后返回的函数，或主应用任务本身。</p><p>OTA:<br>OTA（空中升级）更新可以在现场烧录新的应用程序，但不能烧录一个新的引导加载程序。因此，引导加载程序支持引导从 ESP-IDF 新版本中构建的应用程序。之后会尝试OTA功能进行物联网应用升级。</p><h2 id="component-搭建"><a href="#component-搭建" class="headerlink" title="component 搭建"></a>component 搭建</h2><p>ESP-IDF 可以显式地指定和配置每个组件。在构建项目的时候，构建系统会前往 ESP-IDF 目录、项目目录和用户自定义组件目录（可选）中查找所有组件，允许用户通过文本菜单系统配置 ESP-IDF 项目中用到的每个组件。在所有组件配置结束后，构建系统开始编译整个项目。</p><ul><li><code>项目</code> 特指一个目录，其中包含了构建可执行应用程序所需的全部文件和配置，以及其他支持型文件，例如分区表、数据&#x2F;文件系统分区和引导程序。</li><li><code>项目配置</code> 保存在项目根目录下名为 <code>sdkconfig</code> 的文件中，可以通过 <code>idf.py menuconfig</code> 进行修改，且一个项目只能包含一个项目配置。</li><li><code>应用程序</code> 是由 ESP-IDF 构建得到的可执行文件。一个项目通常会构建两个应用程序：项目应用程序（可执行的主文件，即用户自定义的固件）和引导程序（启动并初始化项目应用程序）。</li><li><code>组件</code> 是模块化且独立的代码，会被编译成静态库（.a 文件）并链接到应用程序。部分组件由 ESP-IDF 官方提供，其他组件则来源于其它开源项目。</li><li><code>目标</code> 特指运行构建后应用程序的硬件设备。运行 idf.py –list-targets 可以查看当前 ESP-IDF 版本中支持目标的完整列表。</li></ul><p>！！！！！！一下午的 debug  新添加 component 后，要删除原有的 build rebuild，不然已有的 build 目录会找不到 cmakelist 文件。 。。 一整个无语。  component 以及 main 里面的 Kconfig.projbuild  ESP 配置目录更改，也需要重编译才会出现在 configuration UI 里面。</p><p>ESP-IDF 在搜索所有待构建的组件时，会按照 <code>COMPONENT_DIRS</code> 指定的顺序依次进行，这意味着在默认情况下，首先搜索 ESP-IDF 内部组件（<code>IDF_PATH/components</code>），然后是 <code>EXTRA_COMPONENT_DIRS</code> 中的组件，最后是项目组件（<code>PROJECT_DIR/components</code>）。如果这些目录中的两个或者多个包含具有相同名字的组件，则使用搜索到的最后一个位置的组件。这就允许将组件复制到项目目录中再修改以覆盖 ESP-IDF 组件，如果使用这种方式，ESP-IDF 目录本身可以保持不变。</p><p>每个组件都可以包含一个 <code>Kconfig</code> 文件，和 <code>CMakeLists.txt</code> 放在同一目录下。<code>Kconfig</code> 文件中包含要添加到该组件配置菜单中的一些配置设置信息。</p><p>运行 menuconfig 时，可以在 <code>Component Settings</code> 菜单栏下找到这些设置。</p><p>创建一个组件的 Kconfig 文件，最简单的方法就是使用 ESP-IDF 中现有的 Kconfig 文件作为模板，在这基础上进行修改。</p><p>有关示例请参阅 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-guides/build-system.html#add-conditional-config">添加条件配置</a>。</p><p><strong>KConfig.projbuild</strong> 与 <code>project_include.cmake</code> 类似，也可以为组件定义一个 KConfig 文件以实现全局的 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-guides/build-system.html#component-configuration">组件配置</a>。如果要在 menuconfig 的顶层添加配置选项，而不是在 “Component Configuration” 子菜单中，则可以在 <code>CMakeLists.txt</code> 文件所在目录的 KConfig.projbuild 文件中定义这些选项。</p><p>经典的组件 kconfig 和 cmakelist 配置：</p><p>在设置 UI 中启用了组件，才会把相应的文件选入 cmake 编译 list</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">config</span> FOO_ENABLE_BAR<br>    <span class="hljs-keyword">bool </span><span class="hljs-string">&quot;Enable the BAR feature.&quot;</span><br>    help<br>        This enables the <span class="hljs-keyword">BAR </span>feature of the FOO component.<br><br></code></pre></td></tr></table></figure><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs isbl"> <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-variable">srcs</span> <span class="hljs-string">&quot;foo.c&quot;</span> <span class="hljs-string">&quot;more_foo.c&quot;</span>)</span><br><br> <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-variable">CONFIG_FOO_ENABLE_BAR</span>)</span><br>     <span class="hljs-function"><span class="hljs-title">list</span>(<span class="hljs-variable">APPEND</span> <span class="hljs-variable">srcs</span> <span class="hljs-string">&quot;bar.c&quot;</span>)</span><br> <span class="hljs-function"><span class="hljs-title">endif</span>()</span><br><br><span class="hljs-function"><span class="hljs-title">idf_component_register</span>(<span class="hljs-variable">SRCS</span> <span class="hljs-string">&quot;$&#123;srcs&#125;&quot;</span></span><br><span class="hljs-function">                     ...)</span><br><br></code></pre></td></tr></table></figure><h2 id="嵌入二进制数据"><a href="#嵌入二进制数据" class="headerlink" title="嵌入二进制数据"></a>嵌入二进制数据</h2><p>&#x2F;&#x2F;嵌入二进制文件-PCM  MP3</p><p>有时组件中希望使用一个二进制文件或者文本文件，但是您又不希望将它们重新格式化为 C 源文件。（例如提示音.mp3）</p><p>这时，可以在组件注册中指定 <code>EMBED_FILES</code> 参数，用空格分隔要嵌入的文件名称:</p><p>idf_component_register(…                       EMBED_FILES server_root_cert.der)</p><p>或者，如果文件是字符串，则可以使用 <code>EMBED_TXTFILES</code> 变量，把文件的内容转成以 null 结尾的字符串嵌入:</p><p>idf_component_register(…                       EMBED_TXTFILES server_root_cert.pem)</p><p>文件的内容会被添加到 Flash 的 .rodata 段，用户可以通过符号名来访问，如下所示:</p><p><strong>extern</strong> <strong>const</strong> uint8_t server_root_cert_pem_start[] <strong>asm</strong>(“_binary_server_root_cert_pem_start”);<strong>extern</strong> <strong>const</strong> uint8_t server_root_cert_pem_end[]   <strong>asm</strong>(“_binary_server_root_cert_pem_end”);</p><p>符号名会根据文件全名生成，如 <code>EMBED_FILES</code> 中所示，字符 <code>/</code>、<code>.</code> 等都会被下划线替代。符号名称中的 _binary 前缀由 objcopy 命令添加，对文本文件和二进制文件都是如此。</p><h1 id="A2DP-自动连接"><a href="#A2DP-自动连接" class="headerlink" title="A2DP 自动连接"></a>A2DP 自动连接</h1><p>ESP32官方例程，A2DP无法做到开机即连。这在蓝牙而集中是一个“理所当然”的功能。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>查找相关例程、issue，没有找到类似的问题。</p><p>查看官方文档，在 A2DP 协议中找到了相应的 API：</p><p><strong>esp_err_t**<strong>esp_a2d_sink_connect</strong></strong>(<strong><strong>esp_bd_addr_t</strong></strong> <strong><strong>remote_bda</strong></strong>)**</p><p>Connect to remote bluetooth A2DP source device. This API must be called after esp_a2d_sink_init() and before esp_a2d_sink_deinit().</p><p><strong>Return</strong></p><ul><li>ESP_OK: connect request is sent to lower layer successfully</li><li>ESP_INVALID_STATE: if bluetooth stack is not yet enabled</li><li>ESP_FAIL: others</li></ul><p>查看 PC 的地址：</p><p>f0:9e:4a:80:5c:db</p><p>在初始化时调用 API，可以在开机时实现自动连接。</p><p>修改 APP 功能，使其能自动连接设备。现在需要知道上一次连接设备的地址，并自动连接最近所连接的设备。</p><p>地址 structure 以队列存储，存储上限为 6 。自动连接 list[0] 的地址，如果连接错误会连 list[1]。以此类推。</p><h2 id="地址记忆实现"><a href="#地址记忆实现" class="headerlink" title="地址记忆实现"></a>地址记忆实现</h2><p>第一步需要获取所连接设备的 MAC 地址</p><p>找到可以给出所连接设备地址的结构体：</p><p>A2DP 协议， esp_a2d_cb_param_t * a2d ，一个回调函数指针的成员：a2d-&gt;conn_stat.remote_bda</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief  ESP_A2D_CONNECTION_STATE_EVT</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">a2d_conn_stat_param</span> &#123;<br>    <span class="hljs-type">esp_a2d_connection_state_t</span> state;      <span class="hljs-comment">/*!&lt; one of values from esp_a2d_connection_state_t */</span><br>    <span class="hljs-type">esp_bd_addr_t</span> remote_bda;              <span class="hljs-comment">/*!&lt; remote bluetooth device address */</span><br>    <span class="hljs-type">esp_a2d_disc_rsn_t</span> disc_rsn;           <span class="hljs-comment">/*!&lt; reason of disconnection for &quot;DISCONNECTED&quot; */</span><br>&#125; conn_stat; <br><br></code></pre></td></tr></table></figure><p>尝试在 APP 层修改代码，不修改 firmware 代码，以保证程序的可移植性。但是能给出地址的指针都在驱动车封装，相应的对象都做了 static 修饰，无法在 c 文件外部调用。</p><p>实在没有找到调用某个接口得 remote_bda 的方法，最后选择修改官方的底层代码。</p><p>最后修改了 ADF 的 a2dp_stream 驱动代码：</p><p>…\esp\esp-adf\components\bluetooth_service\a2dp_stream.c</p><p>添加：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><span class="hljs-built_in">char</span> my_remote_bd_addr<span class="hljs-literal">[<span class="hljs-number">6</span>]</span>;<br>static uint8_t remote_add_index = <span class="hljs-number">0</span>;<br>static const <span class="hljs-built_in">char</span>* remote_key_id<span class="hljs-literal">[<span class="hljs-number">6</span>]</span> = &#123; <span class="hljs-string">&quot;ra_key1&quot;</span>, <span class="hljs-string">&quot;ra_key2&quot;</span>, <span class="hljs-string">&quot;ra_key3&quot;</span>, <span class="hljs-string">&quot;ra_key4&quot;</span>, <span class="hljs-string">&quot;ra_key5&quot;</span>, <span class="hljs-string">&quot;ra_key6&quot;</span> &#125;;<br><br>static void nvs<span class="hljs-constructor">_write_add_to_flash( )</span><br>&#123;<br>    nvs_handle handle;<br>    static const <span class="hljs-built_in">char</span> *NVS_CUSTOMER = <span class="hljs-string">&quot;a2dp_add_data&quot;</span>;<br>    static const <span class="hljs-built_in">char</span> *KEY = <span class="hljs-string">&quot;key&quot;</span>;<br>    <span class="hljs-built_in">char</span> *INDEX_KEY = remote_key_id<span class="hljs-literal">[<span class="hljs-identifier">remote_add_index</span>]</span> ;<br><br>    <span class="hljs-constructor">ESP_ERROR_CHECK( <span class="hljs-params">nvs_open</span>( NVS_CUSTOMER, NVS_READWRITE, &amp;<span class="hljs-params">handle</span>)</span> );<br>    <span class="hljs-constructor">ESP_ERROR_CHECK( <span class="hljs-params">nvs_set_blob</span>( <span class="hljs-params">handle</span>, INDEX_KEY, &amp;<span class="hljs-params">my_remote_bd_addr</span>, <span class="hljs-params">sizeof</span>(<span class="hljs-params">my_remote_bd_addr</span>)</span>) );<br>    <span class="hljs-constructor">ESP_ERROR_CHECK( <span class="hljs-params">nvs_set_i8</span>( <span class="hljs-params">handle</span>, KEY, <span class="hljs-params">remote_add_index</span>)</span> );<br>    <span class="hljs-constructor">ESP_ERROR_CHECK( <span class="hljs-params">nvs_commit</span>(<span class="hljs-params">handle</span>)</span> );<br>    nvs<span class="hljs-constructor">_close(<span class="hljs-params">handle</span>)</span>;<br><br>&#125;<br><br>void nvs<span class="hljs-constructor">_read_add_from_flash(<span class="hljs-params">void</span>)</span><br>&#123;<br>    nvs_handle handle;<br>    static const <span class="hljs-built_in">char</span> *NVS_CUSTOMER = <span class="hljs-string">&quot;a2dp_add_data&quot;</span>;<br>    static const <span class="hljs-built_in">char</span> *KEY = <span class="hljs-string">&quot;key&quot;</span>;<br>    uint32_t str_length = <span class="hljs-number">32</span>;<br>    int8_t  value;<br><br>    <span class="hljs-constructor">ESP_ERROR_CHECK( <span class="hljs-params">nvs_open</span>(NVS_CUSTOMER, NVS_READWRITE, &amp;<span class="hljs-params">handle</span>)</span> );<br>    ESP_ERROR_CHECK ( nvs<span class="hljs-constructor">_get_i8(<span class="hljs-params">handle</span>, KEY, &amp;<span class="hljs-params">value</span>)</span> );<br>    remote_add_index=value;<br><br>    <span class="hljs-built_in">char</span> *INDEX_KEY = remote_key_id<span class="hljs-literal">[<span class="hljs-identifier">remote_add_index</span>]</span> ;<br>    ESP_ERROR_CHECK ( nvs<span class="hljs-constructor">_get_blob(<span class="hljs-params">handle</span>, INDEX_KEY, &amp;<span class="hljs-params">my_remote_bd_addr</span>, &amp;<span class="hljs-params">str_length</span>)</span> );<br>    <span class="hljs-built_in">char</span> *bda = my_remote_bd_addr;<br><br>    <span class="hljs-comment">// ESP_LOGI(TAG, &quot;[add_index:]%d\r\n&quot; ,remote_add_index);</span><br>    <span class="hljs-comment">// ESP_LOGI(TAG, &quot;[add:] [%02x:%02x:%02x:%02x:%02x:%02x]&quot;,</span><br>    <span class="hljs-comment">//         bda[0], bda[1], bda[2], bda[3], bda[4], bda[5]);</span><br><br>    nvs<span class="hljs-constructor">_close(<span class="hljs-params">handle</span>)</span>;<br>&#125;<br><br>static void my<span class="hljs-constructor">_a2d_sink_cb(<span class="hljs-params">esp_a2d_cb_event_t</span> <span class="hljs-params">event</span>, <span class="hljs-params">esp_a2d_cb_param_t</span> <span class="hljs-operator">*</span><span class="hljs-params">param</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(event<span class="hljs-operator"> == </span>ESP_A2D_CONNECTION_STATE_EVT<span class="hljs-operator"> &amp;&amp; </span>param-&gt;conn_stat.state<span class="hljs-operator"> == </span>ESP_A2D_CONNECTION_STATE_CONNECTED)<br>    &#123;<br>        <span class="hljs-constructor">ESP_LOGI(TAG, <span class="hljs-string">&quot;my_a2d_sink_cb is run!\n&quot;</span> )</span>;<br>        nvs<span class="hljs-constructor">_read_add_from_flash()</span>; <span class="hljs-comment">//读取index值，然后再读取地址值</span><br><br>        esp_a2d_cb_param_t *a2d = (esp_a2d_cb_param_t *)(param);<br>        uint8_t<span class="hljs-operator"> * </span>addr = a2d-&gt;conn_stat.remote_bda;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++) my_remote_bd_addr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=addr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>        remote_add_index++; <span class="hljs-keyword">if</span>(remote_add_index<span class="hljs-operator"> == </span><span class="hljs-number">6</span>) remote_add_index =<span class="hljs-number">0</span> ; <span class="hljs-comment">//更新 index 状态，在0~6循环</span><br>        nvs<span class="hljs-constructor">_write_add_to_flash()</span>;  <span class="hljs-comment">// 把index值和 add值 写入对应的地址</span><br>    &#125;<br>&#125;<br>         <br>esp_bd_addr_t* get<span class="hljs-constructor">_remote_ba_addr_last( <span class="hljs-params">void</span> )</span><br>&#123;<br>    nvs<span class="hljs-constructor">_read_add_from_flash()</span>; <span class="hljs-comment">//读取index值，然后再读取地址值</span><br>    return &amp;my_remote_bd_addr;<br>&#125;<br><br>esp_bd_addr_t* get<span class="hljs-constructor">_remote_ba_addr_before(<span class="hljs-params">uint8_t</span> <span class="hljs-params">before_index</span>)</span><br>&#123;<br>    uint8_t index = ( remote_add_index  +<span class="hljs-number">6</span> - before_index ) %<span class="hljs-number">6</span>;<br>    <span class="hljs-built_in">char</span> *INDEX_KEY = remote_key_id<span class="hljs-literal">[<span class="hljs-identifier">index</span>]</span> ;<br><br>    nvs_handle handle;<br>    static const <span class="hljs-built_in">char</span> *NVS_CUSTOMER = <span class="hljs-string">&quot;a2dp_add_data&quot;</span>;<br>    uint32_t str_length = <span class="hljs-number">32</span>;<br>    <span class="hljs-constructor">ESP_ERROR_CHECK( <span class="hljs-params">nvs_open</span>(NVS_CUSTOMER, NVS_READWRITE, &amp;<span class="hljs-params">handle</span>)</span> );<br>    ESP_ERROR_CHECK ( nvs<span class="hljs-constructor">_get_blob(<span class="hljs-params">handle</span>, INDEX_KEY, &amp;<span class="hljs-params">my_remote_bd_addr</span>, &amp;<span class="hljs-params">str_length</span>)</span> );<br>    nvs<span class="hljs-constructor">_close(<span class="hljs-params">handle</span>)</span>;<br>    return &amp;my_remote_bd_addr;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>修改回调函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bt_a2d_sink_cb</span>(<span class="hljs-params">esp_a2d_cb_event_t <span class="hljs-keyword">event</span>, esp_a2d_cb_param_t *param</span>)</span><br>&#123;<br>...<br><br>    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">event</span>) &#123;<br>        <span class="hljs-keyword">case</span> ESP_A2D_CONNECTION_STATE_EVT:<br>            my_a2d_sink_cb(<span class="hljs-keyword">event</span>, param); <span class="hljs-comment">// the callback added to change the bd_add.</span><br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对应的 a2dp_stream.h 文件添加以下接口的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief      return the mac address of the last connected device.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">esp_bd_addr_t</span>* <span class="hljs-title">get_remote_ba_addr_last</span><span class="hljs-params">( <span class="hljs-type">void</span> )</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief      return the mac address of remembered devices. The maximum number of devices is 6.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param[in]  before_index The before_index of the address. </span><br><span class="hljs-comment"> *              For example, if the last index is 5 and the before_index is 1, it will return the address of index-4.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">esp_bd_addr_t</span>* <span class="hljs-title">get_remote_ba_addr_before</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> before_index)</span></span>;<br><br></code></pre></td></tr></table></figure><p>经测试，用多台手机和 PC 分别连接 ESP-HAP，可以正确记忆地址并存储。可以掉电记忆。</p><h2 id="自动连接实现"><a href="#自动连接实现" class="headerlink" title="自动连接实现"></a>自动连接实现</h2><p>在 APP 层的对应任务函数中添加 “读取之前所连接的地址，然后连接对应地址” 的功能：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">uint8_t *<span class="hljs-keyword">bda </span>= *get_remote_ba_addr_last();<br>uint8_t <span class="hljs-keyword">add_index_before </span>= <span class="hljs-number">0</span>;<br>ESP_LOGI(TAG, <span class="hljs-string">&quot;a2dp last-connected bd address:, [%02x:%02x:%02x:%02x:%02x:%02x]&quot;</span>,<br>        <span class="hljs-keyword">bda[0], </span><span class="hljs-keyword">bda[1], </span><span class="hljs-keyword">bda[2], </span><span class="hljs-keyword">bda[3], </span><span class="hljs-keyword">bda[4], </span><span class="hljs-keyword">bda[5]);</span><br><span class="hljs-keyword"></span><br>while(<span class="hljs-number">1</span>)<br>&#123;<br>    for(int i=<span class="hljs-number">0</span><span class="hljs-comment">;i&lt;6;i++) my_device_bd_addr[i]=bda[i];</span><br>    esp_err_t err = esp_a2d_sink_connect(my_device_bd_addr);<br><br>    if(err == ESP_OK) <span class="hljs-keyword">break;</span><br><span class="hljs-keyword"></span>    else &#123; <br>        <span class="hljs-keyword">add_index_before++;</span><br><span class="hljs-keyword"></span>        <span class="hljs-keyword">bda </span>= *get_remote_ba_addr_before(<span class="hljs-keyword">add_index_before);</span><br><span class="hljs-keyword"></span>        ESP_LOGI(TAG, <span class="hljs-string">&quot;a2dp reconnect failed&quot;</span>); <br>        vTaskDelay(<span class="hljs-number">200</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>现在开机后会自动找以前连接过的设备，直到连接成功。</p><h2 id="其他可能的方法"><a href="#其他可能的方法" class="headerlink" title="其他可能的方法"></a>其他可能的方法</h2><p>连接所记忆的地址，在蓝牙协议中应该是一个“理所当然的”事情，自己想方设法用 flash 存储地址，再主动调接口连接就显得很不优雅。连接是 GATT 协议层的事情，而手机和 PC 明显有记录之前连接过设备的地址和服务。</p><p><a href="https://github.com/espressif/esp-idf/issues/10107">https://github.com/espressif/esp-idf/issues/10107</a></p><p>“The ESP32 HID device set the SDP attribute <code>HIDReconnectInitiate</code> to <code>True</code>, it indicates that the HID device will be primarily responsible for connection re-establishment.”</p><p><a href="https://www.esp32.com/viewtopic.php?t=11468#p46410">https://www.esp32.com/viewtopic.php?t=11468#p46410</a></p><p>“It seems this is not done in the ESP firmware, it is done in the phone application code instead. I’m not sure if this is the correct way to do it or if there are more optimal ways, but here’s what I did. In your Android phone application, in the line of code that starts the GATT connection from the Android side (Android Studio or whatever you’re using) set it to auto-connect.”</p><p>windows 是有蓝牙自动连接设置的，一些业余的解决蓝牙自动连接的答案也都是依靠 PC 端来做的：</p><p><img src="/img/boxcnd4QpXZS8tVrGRsRpdWUpkg.png"></p><p>而之前在 ESP32 跑的一些蓝牙例程，例如 SPP BLE_SPP  HID THROUGHPUT 都是需要“手动点一下连接”</p><p>如果能修改类似 <code>HIDReconnectInitiate</code> 的参数，让出重建连接任务的控制权，是否可以不用改记忆地址、调用连接接口这些步骤，然 PC Windows 来负责 reconnect.</p><p>目前还没找到 A2DP 类似的宏定义。</p><h2 id="BUG-记录："><a href="#BUG-记录：" class="headerlink" title="BUG 记录："></a>BUG 记录：</h2><p>falsh 读写报错：</p><p>ESP_ERROR_CHECK failed: esp_err_t 0x110c (ESP_ERR_NVS_INVALID_LENGTH) at 0x40091a80</p><p>0x40091a80: _esp_error_check_failed at D:&#x2F;Users&#x2F;chery&#x2F;esp&#x2F;Espressif&#x2F;frameworks&#x2F;esp-idf-v4.4.3&#x2F;components&#x2F;esp_system&#x2F;esp_err.c:42</p><p>func: nvs_read_add_from_flash</p><p>expression: nvs_get_str(handle, INDEX_KEY, my_remote_bd_addr, &amp;str_length)</p><p>ESP_ERR_NVS_INVALID_LENGTH 错误是读取的空间不够。很玄学，&amp;str_length 照大了给，可能是类似于 str 要读取末尾的&#x2F;0。<a href="https://www.esp32.com/viewtopic.php?p=36770">https://www.esp32.com/viewtopic.php?p=36770</a></p><p>最后是用 nvs_get_blob 接口代替了 nvs_get_str</p><h1 id="ES8388-驱动-component"><a href="#ES8388-驱动-component" class="headerlink" title="ES8388 驱动 &amp;component"></a>ES8388 驱动 &amp;component</h1><p>之前使用的 I2S 解码芯片功能比较单一，直接在 I2S 信号引脚输入相应的脉冲量即可工作，通过一些外接引脚的拉高拉低控制数据格式、功放类型等。但是 ES8388 数字化集成较好，有双声道输入输出，集成 I2C 通信模块以及内部控制寄存器，需要通过 I2C 更改内部寄存器的值来调整工作模式。</p><p>ES8388 需要 I2C 通信，command 初始化 DAC 状态，而之前用的外置解码器直接输入 I2S 信号就可以工作了。<br><a href="https://item.szlcsc.com/339918.html">数据手册</a></p><p>ES8388 支持 SPI 模式和 I2C 模式，通过 CE 引脚来控制。SPI 需要三线，片选信号下降沿有效；在原理图中直接把 CE 拉低，默认 I2C 模式。400 kbps</p><p>The first byte transferred  is  the  slave  address.  It  is  a  seven-bit  chip  address  followed  by  a  RW bit. The chip address must be 001000x, where x equals AD0.</p><p>设备地址 0010001&#x2F;0 AD0，也就是 CE 模拟的。在画图时该引脚拉低，所以地址是 0010000；0x20</p><p><img src="/img/boxcnkW09oK4eUdJwPZQPlFTcYe.png"></p><p>首个 bute，读写位 置 0 写，置 1 读，I2C 通信格式。</p><p><img src="/img/boxcnivHPa99dCOKz8uI1KtRB5c.png"></p><p><img src="/img/boxcn1sSbOHHl8iE2Inbgy2fBdf.png"></p><h2 id="主要控制的寄存器："><a href="#主要控制的寄存器：" class="headerlink" title="主要控制的寄存器："></a>主要控制的寄存器：</h2><p>Register 23 ~52    DAC Control，控制DAC输出开启、时钟配置等。</p><p>Register 0 ~1   Chip Control，总时钟、电源控制。</p><p>具体如何修改寄存器值来指定工作模式，得看 table1</p><h2 id="音频输出连接错误"><a href="#音频输出连接错误" class="headerlink" title="音频输出连接错误"></a>音频输出连接错误</h2><p>在某给版本的电路图中犯了一个致命的错误：差分输出直接当单端输出接了。</p><p>ES8388 的模块图：<br><img src="/img/boxcnCqPlD5IGcJ4JG9HZ65bYNh.png"></p><p>这里的音频输出是 mix 差分输出，而在我的原理图中：<br><img src="/img/boxcnol6wgQ8kcVgQ81glyejEBb.png"></p><p>因为选用的功放是 NS4105，音频信号单端输入，做法是直接去 OUT1 输出接到功放，然后另一个 OUT2 直接接地。</p><p>当时这样想当然的原因是：同时在看功放芯片 NS4105 的数据手册，选择单端输出时直接把一个 OUT 接地，另一个当输出用即可。</p><p>现在想想确实有些想当然了，NS4105 是通过某个引脚拉高拉低来确认是单端还是差分输出了。而且也没有 ES8388 模块产品，没有使用开发板 + 模块进行原理验证。</p><p>差分信号转单端需要一个减法电路。之后注意qwq</p><h2 id="初始化代码"><a href="#初始化代码" class="headerlink" title="初始化代码"></a>初始化代码</h2><p>ESP-ADF 中的驱动程序：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">*<span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Initialize audio board</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return The audio board handle</span><br><span class="hljs-comment"> */</span><br>*audio_board_handle_t audio<span class="hljs-constructor">_board_init(<span class="hljs-params">void</span>)</span>;<br> &#123;<span class="hljs-operator"></span><br><span class="hljs-operator"> ...</span><br><span class="hljs-operator"> </span>board_handle-&gt;audio_hal = audio<span class="hljs-constructor">_board_dac_init()</span>;<span class="hljs-operator"></span><br><span class="hljs-operator"> ...</span><br><span class="hljs-operator"> </span><br><span class="hljs-operator"> </span>&#125;<br> <br>*<span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Start/stop codec driver</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param audio_hal reference function pointer for selected audio codec</span><br><span class="hljs-comment"> * @param mode select media hal codec mode either encode/decode/or both to start from audio_hal_codec_mode_t</span><br><span class="hljs-comment"> * @param audio_hal_ctrl select start stop state for specific mode</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @return     int, 0--success, others--fail</span><br><span class="hljs-comment"> */</span><br>*esp_err_t audio<span class="hljs-constructor">_hal_ctrl_codec(<span class="hljs-params">audio_hal_handle_t</span> <span class="hljs-operator">*</span><span class="hljs-params">audio_hal</span><span class="hljs-operator">*</span>, <span class="hljs-params">audio_hal_codec_mode_t</span> <span class="hljs-operator">*</span><span class="hljs-params">mode</span><span class="hljs-operator">*</span>, <span class="hljs-params">audio_hal_ctrl_t</span> <span class="hljs-operator">*</span><span class="hljs-params">audio_hal_ctrl</span><span class="hljs-operator">*</span>)</span>;<br><br></code></pre></td></tr></table></figure><p>初始化 DAC：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">    dac_hal = audio_hal_init<span class="hljs-params">(&amp;audio_codec_cfg, &amp;AUDIO_CODEC_ES7148_DEFAULT_HANDLE)</span>;<br>    i2s_mclk_gpio_select<span class="hljs-params">(I2S_NUM_0, GPIO_NUM_0)</span>;<br>    <br>    <br> */*<br> * Operate fuction of PA<br> */<br>*audio_hal_func_t AUDIO_CODEC_TAS5805M_DEFAULT_HANDLE = &#123;<br>    <span class="hljs-string">.audio_codec_initialize</span> = tas5805m_init,<br>    <span class="hljs-string">.audio_codec_deinitialize</span> = tas5805m_deinit,<br>    <span class="hljs-string">.audio_codec_ctrl</span> = tas5805m_ctrl,<br>    <span class="hljs-string">.audio_codec_config_iface</span> = tas5805m_conig_iface,<br>    <span class="hljs-string">.audio_codec_set_mute</span> = tas5805m_<span class="hljs-keyword">set</span>_mute,<br>    <span class="hljs-string">.audio_codec_set_volume</span> = tas5805m_<span class="hljs-keyword">set</span>_volume,<br>    <span class="hljs-string">.audio_codec_get_volume</span> = tas5805m_get_volume,<br>    <span class="hljs-string">.audio_hal_lock</span> = NULL,<br>    <span class="hljs-string">.handle</span> = NULL,<br>&#125;;<br><br><span class="hljs-comment">#define AUDIO_CODEC_DEFAULT_CONFIG()&#123;                   \</span><br>        <span class="hljs-string">.adc_input</span>  = AUDIO_HAL_ADC_INPUT_LINE1,        \<br>        <span class="hljs-string">.dac_output</span> = AUDIO_HAL_DAC_OUTPUT_ALL,         \<br>        <span class="hljs-string">.codec_mode</span> = AUDIO_HAL_CODEC_MODE_BOTH,        \<br>        <span class="hljs-string">.i2s_iface</span> = &#123;                                  \<br>            <span class="hljs-string">.mode</span> = AUDIO_HAL_MODE_SLAVE,               \<br>            <span class="hljs-string">.fmt</span> = AUDIO_HAL_I2S_NORMAL,                \<br>            <span class="hljs-string">.samples</span> = AUDIO_HAL_48K_SAMPLES,           \<br>            <span class="hljs-string">.bits</span> = AUDIO_HAL_BIT_LENGTH_16BITS,        \<br>        &#125;,                                              \<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><p>f12 追溯不到关于 I2C 写入寄存器的函数。orz</p><p>从 ADF 源码修改 ES8388 驱动困难太大</p><p>github 上有关于 3S8388 初始化的开源库&#x2F;&#x2F; <a href="https://github.com/maditnerd/es8388">https://github.com/maditnerd/es8388</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> ES8388::write<span class="hljs-constructor">_reg(<span class="hljs-params">uint8_t</span> <span class="hljs-params">slave_add</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-params">reg_add</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-params">data</span>)</span><br>&#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Wire</span>.</span></span><span class="hljs-keyword">begin</span><span class="hljs-constructor">Transmission(<span class="hljs-params">slave_add</span>)</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Wire</span>.</span></span>write(reg_add);<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Wire</span>.</span></span>write(data);<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Wire</span>.</span></span><span class="hljs-keyword">end</span><span class="hljs-constructor">Transmission()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-built_in">bool</span> ES8388::read<span class="hljs-constructor">_reg(<span class="hljs-params">uint8_t</span> <span class="hljs-params">slave_add</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-params">reg_add</span>, <span class="hljs-params">uint8_t</span> &amp;<span class="hljs-params">data</span>)</span><br>&#123;<br>    <span class="hljs-built_in">bool</span> retval = <span class="hljs-literal">false</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Wire</span>.</span></span><span class="hljs-keyword">begin</span><span class="hljs-constructor">Transmission(<span class="hljs-params">slave_add</span>)</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Wire</span>.</span></span>write(reg_add);<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Wire</span>.</span></span><span class="hljs-keyword">end</span><span class="hljs-constructor">Transmission(<span class="hljs-params">false</span>)</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Wire</span>.</span></span>request<span class="hljs-constructor">From((<span class="hljs-params">uint16_t</span>)</span>slave_add, (uint8_t)<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Wire</span>.</span></span>available<span class="hljs-literal">()</span> &gt;= <span class="hljs-number">1</span>)<br>    &#123;<br>        data = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Wire</span>.</span></span>read<span class="hljs-literal">()</span>;<br>        retval = <span class="hljs-literal">true</span>;<br>    &#125;<br>    return retval;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>ES8388 初始化：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> ES8388::<span class="hljs-keyword">begin</span>(es8388_handle_t *dev*, const es8388_clock_config_t *const *clk_cfg*)<br>&#123;<br>    <span class="hljs-built_in">bool</span> res = identify(sda, scl, frequency);<br>    <span class="hljs-built_in">char</span> ES8388_ADDR = *dev-&gt;addr;*<br>    <br>    <span class="hljs-keyword">if</span> (res<span class="hljs-operator"> == </span><span class="hljs-literal">true</span>)<br>    &#123;<br><br>        <span class="hljs-comment">/* mute DAC during setup, power up all systems, slave mode */</span><br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL3, 0x04)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_CONTROL2, 0x50)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_CHIPPOWER, 0x00)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_MASTERMODE, 0x00)</span>;<br><br>        <span class="hljs-comment">/* power up DAC and enable LOUT1+2 / ROUT1+2, ADC sample rate = DAC sample rate */</span><br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACPOWER, 0x3e)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_CONTROL1, 0x12)</span>;<br><br>        <span class="hljs-comment">/* DAC I2S setup: 16 bit word length, I2S format; MCLK / Fs = 256*/</span><br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL1, 0x18)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL2, 0x02)</span>;<br><br>        <span class="hljs-comment">/* DAC to output route mixer configuration: ADC MIX TO OUTPUT */</span><br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL16, 0x1B)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL17, 0x90)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL20, 0x90)</span>;<br><br>        <span class="hljs-comment">/* DAC and ADC use same LRCK, enable MCLK input; output resistance setup */</span><br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL21, 0x80)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL23, 0x00)</span>;<br><br>        <span class="hljs-comment">/* DAC volume control: 0dB (maximum, unattenuated)  */</span><br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL5, 0x00)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL4, 0x00)</span>;<br><br>        <span class="hljs-comment">/* power down ADC while configuring; volume: +9dB for both channels */</span><br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_ADCPOWER, 0xff)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_ADCCONTROL1, 0x88)</span>; <span class="hljs-comment">// +24db</span><br><br>        <span class="hljs-comment">/* select LINPUT2 / RINPUT2 as ADC input; stereo; 16 bit word length, format right-justified, MCLK / Fs = 256 */</span><br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_ADCCONTROL2, 0xf0)</span>; <span class="hljs-comment">// 50</span><br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_ADCCONTROL3, 0x80)</span>; <span class="hljs-comment">// 00</span><br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_ADCCONTROL4, 0x0e)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_ADCCONTROL5, 0x02)</span>;<br><br>        <span class="hljs-comment">/* set ADC volume */</span><br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_ADCCONTROL8, 0x20)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_ADCCONTROL9, 0x20)</span>;<br><br>        <span class="hljs-comment">/* set LOUT1 / ROUT1 volume: 0dB (unattenuated) */</span><br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL24, 0x1e)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL25, 0x1e)</span>;<br><br>        <span class="hljs-comment">/* set LOUT2 / ROUT2 volume: 0dB (unattenuated) */</span><br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL26, 0x1e)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL27, 0x1e)</span>;<br><br>        <span class="hljs-comment">/* power up and enable DAC; power up ADC (no MIC bias) */</span><br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACPOWER, 0x3c)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_DACCONTROL3, 0x00)</span>;<br>        res &amp;= write<span class="hljs-constructor">_reg(ES8388_ADDR, ES8388_ADCPOWER, 0x00)</span>;<br>        <br>        <span class="hljs-comment">/* set up MCLK) */</span><br>        <span class="hljs-constructor">PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO0_U, FUNC_GPIO0_CLK_OUT1)</span>;<br>        <span class="hljs-constructor">WRITE_PERI_REG(PIN_CTRL, 0xFFF0)</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief Test if device with I2C address for ES8388 is connected to the I2C bus </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param sda which pin to use for I2C SDA</span><br><span class="hljs-comment"> * @param scl which pin to use for I2C SCL</span><br><span class="hljs-comment"> * @param frequency which frequency to use as I2C bus frequency</span><br><span class="hljs-comment"> * @return true device was found</span><br><span class="hljs-comment"> * @return false device was not found</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">bool</span> ES8388::identify(<span class="hljs-built_in">int</span> sda, <span class="hljs-built_in">int</span> scl, uint32_t frequency)<br>&#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Wire</span>.</span></span><span class="hljs-keyword">begin</span>(sda, scl, frequency);<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Wire</span>.</span></span><span class="hljs-keyword">begin</span><span class="hljs-constructor">Transmission(ES8388_ADDR)</span>;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Wire</span>.</span></span><span class="hljs-keyword">end</span><span class="hljs-constructor">Transmission()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>IDF 中有 ES8311 对应的驱动，根据 arduino 的文件，修改地址、 写入寄存器的地址及值等即可。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs awk">esp_err_t es8388_init(es8388_handle_t *dev*, const es8388_clock_config_t *const *clk_cfg*)<br>&#123;<br>    int res = <span class="hljs-number">0</span>;<br><br>    res = i2c_init();* <span class="hljs-regexp">//</span> ESP32 <span class="hljs-keyword">in</span> master mode<br>*    <br>    char ES8388_ADDR = *dev-&gt;addr;*<br>    <br>    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL3, <span class="hljs-number">0</span>x04);*  <span class="hljs-regexp">//</span> <span class="hljs-number">0</span>x04 mute/<span class="hljs-number">0</span>x00 unmute&amp;ramp;DAC unmute and  disabled digital volume control soft ramp<br>    <span class="hljs-regexp">/* Chip Control and Power Management */</span><br>*    res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL2, <span class="hljs-number">0</span>x50);<br>    res |= es_write_reg(ES8388_ADDR, ES8388_CHIPPOWER, <span class="hljs-number">0</span>x00);* <span class="hljs-regexp">//</span>normal all and power up all<br>*<br>    *<span class="hljs-regexp">//</span> Disable the internal DLL to improve <span class="hljs-number">8</span>K sample rate<br>*    res |= es_write_reg(ES8388_ADDR, <span class="hljs-number">0</span>x35, <span class="hljs-number">0</span>xA0);<br>    res |= es_write_reg(ES8388_ADDR, <span class="hljs-number">0</span>x37, <span class="hljs-number">0</span>xD0);<br>    res |= es_write_reg(ES8388_ADDR, <span class="hljs-number">0</span>x39, <span class="hljs-number">0</span>xD0);<br><br>    res |= es_write_reg(ES8388_ADDR, ES8388_MASTERMODE, cfg-&gt;i2s_iface.mode);* <span class="hljs-regexp">//</span>CODEC IN I2S SLAVE MODE<br>*<br>*    <span class="hljs-regexp">/* dac */</span><br>*    res |= es_write_reg(ES8388_ADDR, ES8388_DACPOWER, <span class="hljs-number">0</span>xC0);*  <span class="hljs-regexp">//</span>disable DAC and disable Lout<span class="hljs-regexp">/Rout/</span><span class="hljs-number">1</span>/<span class="hljs-number">2</span><br>*    res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL1, <span class="hljs-number">0</span>x12);*  <span class="hljs-regexp">//</span>Enfr=<span class="hljs-number">0</span>,Play&amp;Record Mode,(<span class="hljs-number">0</span>x17-both of mic&amp;paly)<br><span class="hljs-regexp">//</span>    res |= es_write_reg(ES8388_ADDR, ES8388_CONTROL2, <span class="hljs-number">0</span>);  <span class="hljs-regexp">//</span>LPVrefBuf=<span class="hljs-number">0</span>,Pdn_ana=<span class="hljs-number">0</span><br>*    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL1, <span class="hljs-number">0</span>x18);*<span class="hljs-regexp">//</span><span class="hljs-number">1</span>a <span class="hljs-number">0</span>x18:<span class="hljs-number">16</span>bit iis , <span class="hljs-number">0</span>x00:<span class="hljs-number">24</span><br>*    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL2, <span class="hljs-number">0</span>x02);*  <span class="hljs-regexp">//</span>DACFsMode,SINGLE SPEED; DACFsRatio,<span class="hljs-number">256</span><br>*    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL16, <span class="hljs-number">0</span>x00);* <span class="hljs-regexp">//</span> <span class="hljs-number">0</span>x00 audio on LIN1&amp;RIN1,  <span class="hljs-number">0</span>x09 LIN2&amp;RIN2<br>*    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL17, <span class="hljs-number">0</span>x90);* <span class="hljs-regexp">//</span> only left DAC to left mixer enable <span class="hljs-number">0</span>db<br>*    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL20, <span class="hljs-number">0</span>x90);* <span class="hljs-regexp">//</span> only right DAC to right mixer enable <span class="hljs-number">0</span>db<br>*    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL21, <span class="hljs-number">0</span>x80);* <span class="hljs-regexp">//</span>set internal ADC and DAC use the same LRCK clock, ADC LRCK as internal LRCK<br>*    res |= es_write_reg(ES8388_ADDR, ES8388_DACCONTROL23, <span class="hljs-number">0</span>x00);*   <span class="hljs-regexp">//</span>vroi=<span class="hljs-number">0</span><br>*    res |= es8388_set_adc_dac_volume(ES_MODULE_DAC, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);*          <span class="hljs-regexp">//</span> <span class="hljs-number">0</span>db<br>*<br>    res |= es_write_reg(ES8388_ADDR, ES8388_DACPOWER, tmp);*  <span class="hljs-regexp">//</span><span class="hljs-number">0</span>x3c Enable DAC and Enable Lout<span class="hljs-regexp">/Rout/</span><span class="hljs-number">1</span>/<span class="hljs-number">2</span><br>    <span class="hljs-regexp">/* adc */</span><br>*    res |= es_write_reg(ES8388_ADDR, ES8388_ADCPOWER, <span class="hljs-number">0</span>xFF);<br>    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL1, <span class="hljs-number">0</span>xbb);* <span class="hljs-regexp">//</span> MIC Left and Right channel PGA gain<br>*<br>    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL2, tmp);*  <span class="hljs-regexp">//</span><span class="hljs-number">0</span>x00 LINSEL &amp; RINSEL, LIN1/RIN1 as ADC Input; DSSEL,use one DS Reg11; DSR, LINPUT1-RINPUT1<br>*    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL3, <span class="hljs-number">0</span>x02);<br>    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL4, <span class="hljs-number">0</span>x0c);* <span class="hljs-regexp">//</span> <span class="hljs-number">16</span> Bits length and I2S serial audio data format<br>*    res |= es_write_reg(ES8388_ADDR, ES8388_ADCCONTROL5, <span class="hljs-number">0</span>x02);*  <span class="hljs-regexp">//</span>ADCFsMode,singel SPEED,RATIO=<span class="hljs-number">256</span><br>*    *<span class="hljs-regexp">//</span>ALC <span class="hljs-keyword">for</span> Microphone<br>*    res |= es8388_set_adc_dac_volume(ES_MODULE_ADC, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);*      <span class="hljs-regexp">//</span> <span class="hljs-number">0</span>db<br>*    res |= es_write_reg(ES8388_ADDR, ES8388_ADCPOWER, <span class="hljs-number">0</span>x09);* <span class="hljs-regexp">//</span>Power on ADC, Enable LIN&amp;RIN, Power off MICBIAS, set int1lp to low power mode<br>*<br>    return res;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>IOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【文献学习】磁强计的应用</title>
    <link href="/2022/09/24/%E3%80%90%E6%96%87%E7%8C%AE%E5%AD%A6%E4%B9%A0%E3%80%91%E7%A3%81%E5%BC%BA%E8%AE%A1%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2022/09/24/%E3%80%90%E6%96%87%E7%8C%AE%E5%AD%A6%E4%B9%A0%E3%80%91%E7%A3%81%E5%BC%BA%E8%AE%A1%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>给磁强计做一个应用系统，调研一下磁强计原理、大致有哪些应用方向。<br>任务路线：理解磁强计的工作原理、找一个具体的应用方向、规划系统构成-软硬件方案、开发实现、迭代改进</p><h2 id="1-磁强计的原理大体有哪些、弱磁场-中磁场-强磁场-的区别、如何测弱磁和强磁"><a href="#1-磁强计的原理大体有哪些、弱磁场-中磁场-强磁场-的区别、如何测弱磁和强磁" class="headerlink" title="1.磁强计的原理大体有哪些、弱磁场-中磁场-强磁场 的区别、如何测弱磁和强磁"></a>1.磁强计的原理大体有哪些、弱磁场-中磁场-强磁场 的区别、如何测弱磁和强磁</h2><p>从应用的观点出发，根据磁场感应范围将磁场传感器分为：中低强度磁场、高强度磁场传感器。中低强度磁场传感器通常检测 10G 以下的磁场；高强度磁场传感器检测范围通常在 10G 以上</p><p>低强度磁场传感器多用于医学及军事领域，和其他传感器相比，结构复杂成本较高。中强度主要就是地磁场（0.5～0.6G）。高强度磁场传感器又称为偏置磁场传感器，该磁场传感器大多探测比地磁场大的磁场，例如电流的突变。</p><h3 id="超导量子干涉器件法"><a href="#超导量子干涉器件法" class="headerlink" title="超导量子干涉器件法"></a>超导量子干涉器件法</h3><p>超导结的临界电流随磁场周期起伏，临界电流的振荡次数乘以磁通量子就可反映磁场变化的大小。</p><p>这种方法根据约瑟夫森效应，利用超导结的临界电流随磁场周期性变化的特点来测量磁场的。</p><p>具有灵敏度高、分辨率高的特点，但是它的结构比较复杂，需要额外的液氮冷却系统进行恒温控制，较多地使用在医学领域和材料磁性研究领域。不能探测静态或缓慢变化的磁场，低频响应差，大部分应用在邻近和距离探测。</p><h3 id="感应线圈"><a href="#感应线圈" class="headerlink" title="感应线圈"></a>感应线圈</h3><p>法拉第电磁感应定律，即线圈中感应电压和线圈中磁场的变化率成比例。</p><p>感应线圈的灵敏度依赖于铁心的磁导率、线圈面积和匝数。为使线圈工作，线圈必须处于变化的磁场中或在磁场中运动。感应线圈多用于邻近和距离探测。感应线圈磁力计不能探测静态或缓慢变化的磁场</p><h3 id="核子自旋进动测磁"><a href="#核子自旋进动测磁" class="headerlink" title="核子自旋进动测磁"></a>核子自旋进动测磁</h3><p>在一定的磁场中，核子产生进动，其进动的频率与该磁场的强度成正比，利用这一原理也可进行测磁。放置一个固定线圈，则由于与此交链的磁通发生周期性的变化，在线圈中就会感应产生一个交变电压，其频率与进动频率一致。当切断线圈电流，突然去掉人工磁场，使自旋核子绕外磁场方向旋进后进行电路切换，测出此线圈的感应电势的频率就测出了外磁场。</p><p>这种方法利用了核磁共振原理，这种方法的准确度好，误差低，是当前的磁场强度测量方法中精度相对较高的。但其在测试过程中，需要不断更换不同共振频率的探头，因此不便于连续测量</p><h3 id="光泵法"><a href="#光泵法" class="headerlink" title="光泵法"></a>光泵法</h3><p>利用原子的塞曼效应，加热的后的碱蒸汽或者氦气等物质在磁场中会吸收或者发射光谱，这种方法制成的磁强计测量范围可达到 10-8~10G，可以测试直流和交流磁场。</p><h3 id="磁通门"><a href="#磁通门" class="headerlink" title="磁通门"></a>磁通门</h3><p>磁通门磁力计在导航系统中运用最为广泛</p><p>利用在交变磁场的饱和激励下处在被测磁场中磁芯的磁感应强度与被测磁场的磁场强度间呈非线性关系来测量磁场。利用在交流直流磁场同时作用下磁心具有饱和特性的原理制成的一种磁场测量装置。</p><p><img src="/img/boxcnQA8QDWkgFgQI39XOMqORoc.png"></p><p>运行时，主线圈中加有频率为 f0 的激励电流 Iexc，其大小足以使具有磁导率 μ 的铁心饱和。我们称这种装置为磁通门的原因非常明显，当铁心不饱和时，因其磁导率 μ 高给外部磁场 B0 的磁力线提供低磁阻通路，当铁心饱和时铁心磁阻增加，磁力线溢出铁心</p><p>可通过二次谐波原理、脉冲定位原理或脉冲高度原理从输出信号中提取外磁场 B0</p><p>磁通门大都用在闭环直流磁力计中，其分辨率可达 0.1nT。增加传感器频带会引起直流特性下降，还有可能引起稳定性问题</p><p>磁通门磁力计具有高分辨率和良好的鲁棒性，这使得它得到较广应用。与霍尔传感器和磁阻传感器相比，其价格较高</p><p>磁饱和法分为谐波选择法和谐波非选择法两类。谐波选择法就是只考虑探头感应电动势的偶次谐波,而滤去其它谐波。谐波非选择法是不经滤波而直接测量探头感应电动势的全部频谱。</p><p>磁饱和磁强计可靠、简易、耐用且价廉,能够直接测量磁场在空间上的三个分量,并适于在高速运动系统中使用,因此,它广泛应用在如地磁研究、地质勘探、武器侦察、材料无损探伤、空间磁场测量等领域。结合 MEMS 技术，可以制成微型磁强计，能应用在微小卫星、无人机、导弹等众多领域，发展前景广阔。</p><h3 id="各向异性磁阻传感器"><a href="#各向异性磁阻传感器" class="headerlink" title="各向异性磁阻传感器"></a>各向异性磁阻传感器</h3><p>各向异性磁阻传感器由铁磁金属或合金构成，在磁场中电阻率表现为各向异性。</p><p>外加足够大磁场后，可使磁矩向指定方向排列，称为定向磁化。该指定方向被称为易磁化轴或非敏感轴，与易磁化轴垂直的方向称为难磁化轴或敏感轴。</p><p>该结构一般具有二次函数特性的缺点，对低磁场灵敏度不高，并且不能探测外部磁场的方向，因此必须对传感器进行线性化。</p><h3 id="簧片开关"><a href="#簧片开关" class="headerlink" title="簧片开关"></a>簧片开关</h3><p>有可能是用于工业控制最简单的磁场传感器。它包括一对韧性很好的铁磁触点，触点密封在充满惰性气体的容器中，通常是玻璃。沿触点长轴方向的磁场磁化触点，吸引另一触点接通电路。在开、关场之间有较大磁滞，使开关对小扰动磁场不敏感。</p><h3 id="洛仑兹力装置"><a href="#洛仑兹力装置" class="headerlink" title="洛仑兹力装置"></a>洛仑兹力装置</h3><p>最简单的洛仑兹力传感器是半导体磁阻传感器。沿半导体薄片长度方向加上电压，薄片上有电流流过，可以测量出电阻，此时如加上与薄片长度方向垂直的磁场，洛仑兹力使电荷发生偏转。如果半导体薄片的宽度比长度大，电荷将穿过薄片，沿侧面积累的电荷不多。磁场变化增加了电荷运动路径的长度，从而增加了电阻。在强磁场情况，电阻的增加可达数倍。</p><h3 id="霍尔传感器"><a href="#霍尔传感器" class="headerlink" title="霍尔传感器"></a>霍尔传感器</h3><p>霍尔传感器电压方向的长度远比宽度长，载流子偏移到侧面产生霍尔电压，建立和洛仑兹力大小相等、方向相反的电场力。在平衡点上，载流子大约沿长度方向作直线运动，另外的电荷不再聚集在侧面上。在磁场作用下，两端电阻几乎没有变化。两侧面中部电极上所测霍尔差分电压和垂直于半导体片的磁场成正比，其符号随外加磁场方向的改变而改变。</p><p>霍尔磁场传感器的基本特性好，运行原理及结构简单，和微电子电路兼容。由于其良好的基本特性，霍尔元件已广泛应用于磁场传感器。简单化使其在不同应用中易于优化及小型化，并且对灵敏度影响不大。和微电子电路的兼容使它可利用微电子工业中的先进校正方法和高质量材料，促进了自身的持续发展。霍尔元件和更好的接口及信号处理电子电路的集成将会导致性价比高的新型传感器系统的发展。在电流传感及无刷电机控制中占有绝对优势.</p><h3 id="巨磁电阻磁场传感器（GMR）"><a href="#巨磁电阻磁场传感器（GMR）" class="headerlink" title="巨磁电阻磁场传感器（GMR）"></a>巨磁电阻磁场传感器（GMR）</h3><p>巨磁电阻（GMR）效应，是指某些磁性或合金材料的磁电阻在一定磁场作用下急剧减小，而电阻变化率 Δρ &#x2F;ρ 急剧增大的特性，一般增大的幅度比通常的磁性合金材料的磁电阻约高 10 倍。巨磁电阻效应只有在纳米尺度的薄膜中才能观测到，因此纳米材料以及超薄膜制备技术的发展使巨磁电阻传感器芯片得以实现。利用磁性材料的电阻率在有无外加磁场时有着很大的改变的特点来测量磁场强度。GMR 传感器具有体积小、线性范围宽，使用温度高、成本低等优点。</p><p><img src="/img/boxcng73joKy3yAL1VznFOt9eVh.png"></p><h2 id="2-典型的应用场景有哪些"><a href="#2-典型的应用场景有哪些" class="headerlink" title="2.典型的应用场景有哪些"></a>2.典型的应用场景有哪些</h2><p>勘测领域:测量压力、地下石油管道探伤、海上石油钻井平台等</p><p>医疗领域：磁场治疗各种各样的疾病、通过磁场迅速检测人体有没有癌变细胞、通过测量心脏跳动引起的磁场变化和大脑磁场变化而画出的“心磁图”、“脑磁图”，起到替换过去的“心电图”，“脑电图”</p><p>微小卫星&amp;无人机：导航与姿态检测</p><p>大体从以上三个方向内挑一个。评估目前应用技术的成熟度及实现难点。</p><h3 id="心磁"><a href="#心磁" class="headerlink" title="心磁"></a>心磁</h3><p>心磁信号比较弱 大多是用超导量子干涉仪测</p><p>弱信号提取最大的难点就去去噪、重建 提取有用信息。</p><p>主要用处：CHD 的检测 文献[4-5]  心磁图在心电图正常或非特异性异常患者诊断中有独特的诊断价值，可用于此类患者的初步筛查</p><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p>磁导航主要用到自主导航  关键词：地磁导航</p><p>自主导航：IMU 惯性导航系统是以陀螺仪和加速度计为敏感器件的导航参数解算系统。</p><p>地磁定位导航技术基于地磁场是一个矢量场, 其强度大小和方向是位置的函数。同时地磁场具有丰富的总强度、矢量强度、磁倾角、磁偏角和强度梯度等特征，为地磁匹配提供了充足的信息。因此，将地磁场作为一个天然的坐标系, 利用地磁场的测量信息实现定位导航。</p><p>基于扩展卡尔曼滤波器的地磁导航算法  卫星在当前时刻的位置和速度</p><p>星自主导航即是指卫星不依赖地面支持 而利用星上自备的测量设备实时地确定自己的位置和速度。</p><p>磁场已有相当好的磁场模型而它的强度和方向是位置的函数所以可以利用磁强计对地磁场的测量来进行卫星自主定轨。</p><p>组合导航 大多是：  SINS&#x2F;GNSS</p><p>全球导航卫星系统(GNSS)</p><p>捷联惯性导航系统(SINS) 惯性导航 IMU  INS</p><p>全球定位系统 GPS</p><h3 id="姿态检测"><a href="#姿态检测" class="headerlink" title="姿态检测"></a>姿态检测</h3><p>通过控制星体转动使卫星实现对日定向,保证卫星的能源供应,便于捕获地球。在这个阶段中的姿态确定精度要求不高,但是要求测量部件的可靠性高、功耗低。</p><p>利用三轴磁强计作为测量部件进行姿态确定</p><p>组合解算 卡尔曼滤波</p><p>姿态四元数微分方程和 MEMS 陀螺误差方程</p><p>文献 6： 微处理器 AT91SAM7S256  微惯性测量组合 ADIS16350  磁强计 HMC1043</p><p>就这？这都能毕业？  做了一个电路 让单片机定时读传感器数据，内部跑一下相应的算法，然后通过 UART 输给上位机。</p><p>算法都是现成的。就验证了一下 纯捷联解算、加上磁强计后的解算、加上卡尔曼滤波后的姿态解算。尝试说明加卡尔曼滤波，并且组合数据后的结果更平滑。</p><p>只测了不动时候的姿态。在转台上的姿态变化测试呢？很难有实用价值啊。</p><p>通用的方法：计算加速度计信任度 利用卡尔曼滤波的方法和四元数据算法对传感器测量值进行融合</p><p>文献[7] 纯算法研究  买已有的硬件平台作调试、研究。</p><p><img src="/img/boxcntlQfs2HeIwNurkplHxKMub.png"></p><p>尝试解决姿态测量系统不够准确、陀螺仪积分误差问题。做了磁强计组合测量系统，利用卡尔曼滤波实现数据融合。</p><p>磁强计不出意外就是测地磁和心磁的磁通门式的了。</p><p>比较感兴趣导航 or 姿态检测。可以公费买无人机做测试。</p><p>其他的应用场景还需要找一下文献，看看目前的趋势、前景、应用是否落地。</p><h2 id="3-磁通门磁强计的原理和性能参数"><a href="#3-磁通门磁强计的原理和性能参数" class="headerlink" title="3.磁通门磁强计的原理和性能参数"></a>3.磁通门磁强计的原理和性能参数</h2><p>信号处理方法</p><p>感应信号的处理方法主要有：二次谐波法、高次谐波法、脉冲间隔法</p><p>二次谐波法在磁通门磁强计的后续信号处理中具有最广泛的应用，采用差分形式的探头结构能够抵消变压器效应产生的感应电势，同时磁通门信号能叠加。但是实际中由于探头结构不可能做到完全对称，因此变压器效应产生的感应电势仍会存在，二次谐波法能提取出感应信号中磁通门信号最大的二次谐波，从而得到最终与待测磁场相关的输出信号。目前调研的大部分文献中均采用二次谐波法作为磁通门磁强计的测试方法。二次谐波法电路的主要环节包括相敏解调器与带通滤波电路。</p><p><img src="/img/boxcnv62YYNMXAJ8WfCCYgT0E6e.png"></p><p>激励线圈让磁心产生磁导率，这会影响外部磁场通过感应线圈的磁通量。磁通量变化会在线圈两端产生感应电动势</p><p><img src="/img/boxcn9bSAbLt6VWdSg2dhSO8oYd.png"></p><p>需要注意的是，Ht 是外部磁场和激励线圈磁场的叠加</p><p><img src="/img/boxcnYsK0GPE0dRhVNx6fO5kkWg.png"></p><p>一般环境磁场 H0 的变化比 Hm 的要小很多</p><p><img src="/img/boxcnhttJLTTGJTbXEoiKt7UZPd.png"></p><p>所以电势的变化含有两个分量，我们需要提取的是 ε2</p><p>但是从输出电压中提取出这里量是个技术活。所以就像之前介绍时候说的：</p><p>谐波选择法就是只考虑探头感应电动势的偶次谐波,而滤去其它谐波；谐波非选择法是不经滤波而直接测量探头感应电动势的全部频谱,它又可细分为幅度比例输出法和时间比例输出法。</p><p>铁心磁导率 u(t)没有正和负区别，因此得到的值为偶函数，且频率为之前的两倍：</p><p><img src="/img/boxcn4exz4wQvpoTzKG2N0yABYc.png"></p><p>带入上面的式子可以得到：</p><p><img src="/img/boxcnFybbXmMS1c5NPtw8Z2pegf.png"></p><p>也就是说：ε1(t)中包含基波信号与其奇次谐波分量，且只和励磁交变磁场有关；ε2(t)中包含基波信号的偶次谐波分量，且只和待测的环境磁场 0H 有关。当磁芯的轴向方向有环境磁场 H0 用时，感应电动势中将同时包含基波的奇次谐波分量和偶次谐波分量，而且偶次分量很大程度上和 H0 呈正比关系。</p><p>文献[2]中做的磁通门应用系统：</p><p>磁强计系统主要包括磁探头、激励电路、测试电路组成。其中磁探头是磁通门磁强计的核心部件，其主要结构包括磁芯、激励线圈和检测线圈</p><p><img src="/img/boxcnqqB6yumiZOAGCt5z4s278g.png"></p><p>使用锁相放大器和乘法器</p><p><img src="/img/boxcniDFs7dgHUM7NEg2f3LS7B5.png"></p><p>使用九十度相移，乘法器后、低通滤波 得到的信号作内积。</p><p><img src="/img/boxcn47nr5kV93JvI5AyhPcxpGd.png"></p><p>模拟集成电路的设计 大致也就是 乘法器（倍频）、波形发生器、放大、滤波、运放相移电路</p><p>优化接口电路板的设计，通过对元器件的布局、走线优化以及选择噪声更小的运放器件降低接口电路的噪声，并研究接口电路板上的磁芯材料对磁强计输出信号的影响，选用合适的屏蔽方法降低电路板上磁芯元器件对磁强计输出的影响。</p><p>所以还需要做信号调理模拟电路吗？</p><p>必须的电路模块： AD 转换、MCU、显示模块、电源管理、typeC-烧录-通讯、无线通信-数据上传服务器</p><h2 id="4-磁导航-姿态检测的算法实现"><a href="#4-磁导航-姿态检测的算法实现" class="headerlink" title="4.磁导航&amp;姿态检测的算法实现"></a>4.磁导航&amp;姿态检测的算法实现</h2><p>经过信号处理模块的磁强计输出信号 可以标定为 uT-mV ，即电压值解算</p><p>地球：圆球体、大地面包围成的球体、椭球体 ；一般会看出椭球体，不同维度下的曲率半径不同</p><p>有不同的重力加速度</p><p>恒定的地球自转角</p><p>惯性坐标系是无加速度的或者处于匀速直线运动状态。而宇宙空间中的所有物体都处在运动中，因此需要根据不同的导航对象来选取惯性坐标系。坐标系：</p><p>地心惯性坐标系 ： 做匀速直线运动 忽略了行星公转 ；忽略太阳、月亮及其它星体的引力，以及由于这些引力而存在的地球轨道运动</p><p><img src="/img/boxcn0PSyfRweHSq2qf5GJkbwNd.png"></p><p>发射点惯性坐标系（简称 li 系）：发射时刻的发射点惯性坐标系作为测量该载体飞行位置的基准</p><p>非惯性坐标系：</p><p>地球坐标系（简称 e 系）</p><p>地球坐标系是原点在地心，坐标轴固定在地球上的右手正交坐标系。近似认为它相对惯性坐标系的转动角速率 iew 旋转。ＯＺ 轴指向北极，ＯＸ 和 ＯＹ 轴都在赤道平面内</p><p>地理坐标系（简称 t 系）相对于大地水准面定义的东北天坐标系。其中，东北天坐标系原点为载体质心在大地水准面上的投影。x 轴沿参考椭球卯酉圈方向指向东，y 轴沿参考椭球子无圈方向指向北</p><p>载体坐标系（简称 b 系）固连在运载体的参考坐标系  坐标原点为运载体的重心，by 轴沿载体横轴指向右翼，bx 轴沿载体纵轴指向机头方向</p><p>平台坐标系（简称 p 系）</p><p>平台坐标系是与平台固连，描述平台指向的坐标系，其坐标原点可以位于平台台体导航的任意一点，通常定义为平台质心。若该坐标系与导航坐标系没有误差角，两者重合</p><p>导航坐标系（简称 n 系）</p><p>导航坐标系是在根据导航的需要求解载体导航信息时选取的参考坐标系。对于捷联惯性导航系统来说，导航信息并不在载体坐标系内求解，但惯性传感器的测量姿态值是在载体坐标系内进行的。因此，必须将惯性传感器的输出值变换到导航坐标系中，再进行导航信息的计算。</p><p>姿态角，也叫欧拉角，姿态角是载体坐标系和导航坐标系之间的三个夹角</p><p>航向角：载体纵轴 bx 与北向轴（N）之间的夹角，在水平面测量，顺时针为正；</p><p>俯仰角：载体纵轴 bx 与水平面之间的夹角，在垂直面中测量，抬头为正；</p><p>横滚角：载体横轴 by 与水平面之间的夹角，在横截面测量，左边抬头为正。</p><p><img src="/img/boxcnPAZZc6tBcPwfzrJhtnic7b.png"></p><p><img src="/img/boxcnU4vj03nxYOakxsBFct7M2d.png"></p><p><img src="/img/boxcnZOYajuCZ4vZseNQG10WRCd.png"></p><p>旋转矩阵-坐标变换  正交矩阵  沿 tra 翻转</p><p>姿态矩阵 – 捷联姿态测量系统中姿态的更新就是根据惯性传感器在载体坐标系中测得值实时的计算出姿态矩阵，然后从姿态矩阵中提取出所需的载体姿态信息</p><p>四元数：</p><p>测量器件本身跟随着载体既有平移又有旋转运动，使得问题描述与求解变得非常困难。四元数的理论可将此类问题归为刚体绕定点的转动问题，从而有效地解决了这一问题。</p><p>不是从三个旋转角的分量描述，而是找到一个转轴 μ  ，可以用 ijk 三个坐标轴表示 μ 的方向</p><p>一个坐标或一个矢量相对于某一坐标系的旋转，转角为 θ：</p><p><img src="/img/boxcnp1CPGQQKes7aueLML6XsBe.png"></p><p>q 是旋转四元数</p><p>R‘为旋转后的投影： R’ &#x3D;q’Rq</p><p><img src="/img/boxcnaO8nq9L6I8m18zc4sC3jNb.png"></p><p>可以和方向余弦矩阵法 都是表示旋转后坐标系之间的转换，本质上是等价的</p><p>具体算法：</p><p>求解四元数姿态微分方程式： dq&#x2F;dt&#x3D; 1&#x2F;2 q × ω</p><p><img src="/img/boxcnsIegluOtGkfuQ9DHVPYyQh.png"></p><p>假设角速度的采样周期为 T，则四阶龙格-库塔法计算的形式如下：</p><p><img src="/img/boxcnuTVx6RADgSLmAfxXVZNrCb.png"></p><p>在利用四元数进行载体姿态解算中通常需要进行正交化处理，从而消除非正交误差对姿态解算精度的影响，其主要目的是使采用四元数方法获得的姿态转移矩阵随机漂移误差达到最小，可以由四元数的四个参数的平方和与四元数的模相比的方法进行归一化处理</p><p>参考文献：<br>入门-综述-已有的研究<br>磁场测量方法的发展及应用  潘启军 2005<br>刘幂 2017 清华硕士学位论文</p>]]></content>
    
    
    
    <tags>
      
      <tag>文献学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数值分析】课程学习_上</title>
    <link href="/2022/09/23/%E3%80%90%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/"/>
    <url>/2022/09/23/%E3%80%90%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E3%80%91%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>Hi，这是数值分析课程中的笔记。<br><a href="https://fuaqwpa97c.feishu.cn/docs/doccnU0HETzfRwippru7U4Js6Rb">原文档</a></p><h2 id="基础概念-线代复习"><a href="#基础概念-线代复习" class="headerlink" title="基础概念&amp;线代复习"></a>基础概念&amp;线代复习</h2><p>计算机中的浮点数计算：</p><p>表示：</p><p>x &#x3D; (−1)^s ·(0.a_1a2 ···at ) ·β^e &#x3D; (−1)s ·m ·β ^e−t</p><p>符号位、有效位数、字长 ~ 在存储中为符号位、阶码、尾数位</p><p>类似于科学计数法</p><p>和之前学的二级制浮点数表示有点相似，但又不完全相同</p><p>Matlab 默认的数据类型是 double</p><p>向前误差分析 f(x∗) &#x3D; (x)2(1 + 2δ)   ;f(x)&#x3D;x^2</p><p>向后误差分析[f (x)]∗ &#x3D; f (x(1 +  ̃δ))”</p><p>条件数：|f (x + δx) −f (x)| &#x2F;|f (x)| ≤ κ(x)|δx|&#x2F;|x|</p><p>κ(x) 自变量变化引起函数值的变化  类似于灵敏度  太大是病态的</p><p>κ(x)&#x3D; |xf ‘(x) &#x2F;f (x)   |</p><p>避免相近的数相减  会严重损失有效数字</p><p>避免和绝对值大的数相乘、和绝对值小的数相除</p><p>减少运算次数：  x3 −6.1x2 + 3.2x + 1.5 -&gt;  ((x −6.1)x + 3.2)x + 1.5</p><p>选公式： ln(1+x)  ln(1+x&#x2F;1-x)  的 Taylor 展开算 ln2 后者强</p><p>MATLBA - norm  求范数</p><p>矩阵的 1 范数是列向量绝对值和的最大值；</p><p>无穷范数  是  行向量绝对值和的最大值</p><p><img src="/img/boxcn8pK2ehbz4Fv4HT0915vTKe.png"></p><p><img src="/img/boxcnfYRXAQip6FeW8U0DKb31Hf.png"></p><p><img src="/img/boxcngKMMV3UScej79kMfYRQFkc.png"></p><p><img src="/img/boxcnCj56vsx0pyKpzgiw1e8yPf.png"></p><h2 id="线性方程组的直接解法"><a href="#线性方程组的直接解法" class="headerlink" title="线性方程组的直接解法"></a>线性方程组的直接解法</h2><p>下三角方程的解法：</p><p><img src="/img/boxcnIwG0hKezC9VDkLFfAWOkoe.png"></p><p>向前迭代 复杂度 O(n^2)</p><p>上三角方程算法差不多，复杂度同样量级</p><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p>本质上是找到一个非奇异矩阵，使得 A&#x3D;LU  LU 分解</p><p>算法复杂度是 O(n^3)；迭代的过程 相当于每次左乘一个单位向量 l&#x3D;(0,0,…ak+1&#x2F;ak…an&#x2F;ak)。</p><p>A&#x3D;LU Ly&#x3D;b  Ux&#x3D;y</p><p>非奇异矩阵，若顺序主子式均不为 0.则存在唯一  LU&#x3D;A，分解唯一； 顺序主子式 det ！&#x3D;0 保证第 k 步的 akk！&#x3D;0.  如果遇到—选主元？</p><p>如何作 LU 分解？</p><p><img src="/img/boxcnJsiIKQNPfZi5dhxhA7qN5e.png"></p><p>A 的第一行 等于 L 的第一行 × U 的每一列  先让，A 的第一行和 U 的第一行是相等的。</p><p>然后  A 的第一列， &#x3D; L 的每一行 × U 的第一列。注意 u11 已知了，所以可以直接求解出 L 第一列</p><p>之后就如此往复，求 U 的 i 行、L 的 i 列</p><p>doolittle 分解算法：</p><p><img src="/img/boxcnJwWaTJMeMgPa4FvGceaT1f.png"></p><p>就是上面的，往复求  U 的第 k 行、L 的第 k 列。</p><p>[L,U]&#x3D;lu(A) MATLAB 分解</p><p>一些特殊矩阵的分解可以优化：例如三对角矩阵。</p><p>参考一维 poisson 方程的求解，使用数值解近似，就会需要求解一个三对角矩阵。</p><p><img src="/img/boxcnncXEaaIG0YBAZdAoJLrtec.png"></p><p>u1&#x3D;b1; li &#x3D; ai&#x2F;ui−1 ; ui &#x3D; bi − lici−1,</p><p>追赶法  复杂度 On； amtlab 接口 Thomas</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>如果是循环三对角方程，也有对应的计算方法。</p><p><img src="/img/boxcnDvpbKE3EtQE5tUpustRDJs.png"></p><p>Gauss 消去：对角元素等于 0 或非常小的情况。</p><p>选主元：在解到第 k 步时，选 akk–ank 中 最大模的元素与 akk 进行交换行。</p><p>在每次消去前，选主元，换行。是一种牺牲复杂度换取更高精度的方法。</p><p>即：存在排列阵 P ，使得：PA&#x3D;LU</p><p>[L,U,P]&#x3D;lu(A)  matlab 计算方法，会默认给你选主元。如果输出不带 P，会给你 × 进去。</p><h3 id="cholesky-分解"><a href="#cholesky-分解" class="headerlink" title="cholesky 分解"></a>cholesky 分解</h3><p>分解时，U 可以再分解成 DU* 对角阵 D 和单位上三角阵 U*</p><p>若 AT&#x3D;A 对称矩阵；则存在单位下三角矩阵： A&#x3D;LDLT    利用特殊矩阵的性质，尽可能减小计算量。</p><p>正定阵： A   存在唯一的 对角元素为正的 下三角阵 L A&#x3D;LLT   （L~&#x3D;LD^1&#x2F;2 不是单位下三角了）</p><p>在设计算法时，利用 U&#x3D;LT，可以进行一定的计算简化。</p><p><img src="/img/boxcnavEPbSbeJcmDNyAjRGvGCh.png"></p><p>cholesky 分解，也就是正定对称矩阵的分解，可以检验对称阵 A 是否正定。能做完这个算法就是正定的</p><p>MATLAB 函数 chol(A)，A&#x3D;R’R</p><p>可以通过线性方程组求解的方法求矩阵的逆。</p><p>X 是 A 的逆矩阵，则 AX&#x3D;I   Axi&#x3D;ei  ，A 乘上 X 的每一列，等于 I 的对应列</p><h3 id="条件数"><a href="#条件数" class="headerlink" title="条件数"></a>条件数</h3><p>在直接法求解线性方程组的过程中，由于舍入误差的存在，微小的扰动可能造成解很大的变化。</p><p><img src="/img/boxcn6FLXbdJD9ZE8KqyiVyMxEg.png"></p><p>所以定义了一个条件数，来描述解的变化随扰动的变化情况：</p><p><img src="/img/boxcnG8U8rBLZbhPd9YYCcWxZ4b.png"></p><p><img src="/img/boxcnlnvlNIXCUqDNswlrhlcpXe.png"></p><p>矩阵条件数-计算机计算数学中产生的问题，</p><p><img src="/img/boxcnaLpuZ4kPO2XUDEwzonnLtg.png"></p><p>具体如何通过 COND A ，还不太懂。。常用的是 2 - 1 -∞ 范数。</p><p>计算机总是存在舍入误差，所以算的是 (A+δA) * (x+δx)  &#x3D; (b&#x3D;δb)</p><p>b！&#x3D;0，且 δA 够小，使得 ||A-1||||δA||＜1              有：</p><p><img src="/img/boxcnhJQr2Fnq7dvAtozgvgMSYd.png"></p><p>性质：</p><p>condA&gt;&#x3D;1;condA&#x3D;condA-1 ,</p><p>condαA&#x3D;condA</p><p>若 A 为正交阵，ATA&#x3D;I  ||A2||&#x3D;1  cond2A&#x3D;1</p><p>若 U 为正交阵   cond2AU&#x3D;cond2UA&#x3D;cond2A</p><p><img src="/img/boxcnmZHxlxlACZgpxkV8q7u1ee.png"></p><p>condA&gt;&gt;1 则是病态的；条件数的值与范数的选取有关。</p><p>MATLAB 命令  cond</p><p><img src="/img/boxcnmmW1BtUZzrQJcGk2un2fsf.png"></p><p>可以使用可计算的 r，去衡量计算结果的精确度。残差的大小去衡量解的误差。</p><p>需要注意的是，使用 r 衡量解的 δx 时，需要 condA 不是病态的。</p><p>矩阵的条件数和行列式没有必然的联系，病态的出现主要是某些列向量近似线性相关了。</p><p>粗略地说，如果用主元素法或平方根法解方程组，设 A 和 b 的元素准确到 s 位数，且 condA&#x3D;10^t，t&lt;s，则计算的解向量大约有 s-t 为有效数字的准确度。</p><p>预处理</p><p>一般会做一些预处理，把 condA 降下去。</p><p>可以考虑矩阵的行列分别乘上不同的 const，即寻找可逆对角阵 D1 D2（左行右列），将方程组 Ax&#x3D;b 变成：</p><p>D1AD2y&#x3D;D1b  ，x&#x3D;D2y</p><p>理论最优： min  cond（D1AD2）； 通过计算量来优化精度。</p><h2 id="非线性方程组的迭代解法"><a href="#非线性方程组的迭代解法" class="headerlink" title="非线性方程组的迭代解法"></a>非线性方程组的迭代解法</h2><h3 id="迭代法思路"><a href="#迭代法思路" class="headerlink" title="迭代法思路"></a>迭代法思路</h3><p>45° 卷，卷也卷不动，躺也躺不平；</p><p>很多时候的数学问题都是优化问题-find min。常见的：如果能找到函数的下界，可以构造一个单调递减的序列，主要是迭代的函数，让序列逐渐逼近目标 min。所以迭代法的关键就是找到迭代的函数，让序列以一定方法逼近目标值。</p><p>如果带有约束，可以引入 lagrange 乘子把约束融入目标函数，变为无约束问题。</p><p>解方程组的更，采用不动点迭代。</p><p>ax&#x3D;b  &#x3D;&#x3D;&gt; ax-b&#x3D;0   &#x3D;&#x3D;&gt;     1&#x2F;c(ax-b)+x&#x3D;x,不动点代换 G（x）&#x3D;x+1&#x2F;c(ax-b)</p><p>通过一定的迭代方法， 使目标序列逐渐逼近不动点。</p><p>序列收敛：简单的求极限</p><p><img src="/img/boxcnTAx8DezIlBCAcGAZPUq5Re.png"></p><p>注意，Jacobi 矩阵 各偏导都存在，向量值函数不一定可导。</p><p><img src="/img/boxcnbzPewGgjBkKvyR7onwgOcd.png"></p><p><img src="/img/boxcnVNIB1gaQR6c6TH1DCoDqkg.png"></p><p>本课程基本都是使用的 线性 定常 单步迭代-即最简单的迭代公式。</p><p>收敛阶：形容方程组在多少阶次下的收敛性质</p><p><img src="/img/boxcnFgzMLFG7CiaGPnAiT67czb.png"></p><p>就是说收敛的阶次高低。本课程线性方程组基本都是 P&#x3D;1。有给结论：P&#x3D;1 线性方程组的迭代收敛性不依赖于初值的选取。而非线性方程组一般是没有全局收敛性的，所以一般要选取到充分靠近解 X*的初值。初值的选取不同是两种迭代方法最大的区别。</p><p><img src="/img/boxcnpXTZS0ScOnFQlStPE7Xd4f.png"></p><p>某个作业题用到了这个性质。</p><p>非线性迭代需要一个迭代终止条件：r^(k)&lt;ε (非病态) ; x(k+1)-x(k)&lt; ε （超线性收敛） ;max 次数 N</p><p>方程组求根问题，等价转化位映射不动点问题。</p><p>为什么一定要不动点迭代？不动点迭代的方法比零点迭代更加简单吗？在构造不动点迭代的时候，本身就有了一个迭代公式 G，只要再考察 G 是不是压缩的就可以了。</p><p><img src="/img/boxcnJUpKJLpIP30TsBXv3Yxg8d.png"></p><p>ax&#x3D;b  &#x3D;&#x3D;  ax-b&#x3D;0   &#x3D;&#x3D;     1&#x2F;c(ax-b)+x&#x3D;x,不动点代换 G（x）&#x3D;x+1&#x2F;c(ax-b)</p><p>压缩映射依赖于范数选取。那如何判断是不是压缩的呢？不懂 nie，所有的范数都满足压缩条件才，还是某个范数满足即可？</p><p>理论基石：压缩映射原理</p><p><img src="/img/boxcnsTxsBuT8HBbQPpCfESIYfd.png"></p><p>所以，有压缩映射-》找到不动点 -》迭代求解线性方程组</p><p>证明：构造 x（k+1）&#x3D;G（k）  ；证明 x（k）收敛，然后即可证明  lim x(k)&#x3D;G(x)  ,唯一性设俩不动点，他们相等即可。满足压缩映射即可收敛–</p><p>F（x）&#x3D;0  等价到一个映射问题，再构造一个不动点迭代，即可保证收敛。映射只需满足：压缩、内映射。局部收敛情况：找到的 G 在 D 的子域，x <em>的领域内 ，内映射 ，则可以在 S 内找到不动点，x</em> 称为 S 吸引点，S 为 x <em>吸引域。 –  x</em> 局部收敛。</p><p>在实际应用中需要考虑收敛域吗？好像没怎么考虑过-起始点都是题目给的，如果没给一般就取零向量</p><p><img src="/img/boxcnBUQAr2B8dRtbYLvJejmIYf.png"></p><p>意思是在判断不动点吸引域的时候， 计算 G‘x*的谱半径比计算压缩条件更简单，这个是可以严格证明的。所以谱半径怎么算？ λI-A&#x3D;0 ，求 max λ ，哪里简单了</p><p>也可用用缩放，谱半径小于无穷（1、2，any）范数  简化</p><p>上面只教了如何验证迭代矩阵函数 G 是收敛的，但是如何构造还是有说法的，凭空构造不太合理。接下来的介绍的一些方法就是讲如何构造 G</p><h3 id="Newton-迭代"><a href="#Newton-迭代" class="headerlink" title="Newton 迭代"></a>Newton 迭代</h3><p>不求逆 解方程  LUΔx&#x3D;-Fx</p><p><img src="/img/boxcn77q5yCQ7VoxIeqYE31UtHh.png"></p><p>基本原理：长得很像是 taylor 展开。然后 X*&#x3D;X(k+1)-最后一次迭代。</p><p>G&#x3D;x&#x3D;x-F’x^-1 Fx； 不动点等价于 Fx*&#x3D;0；</p><p>所以迭代过程：F’x(k) Δx&#x3D;-Fx(k)</p><p><img src="/img/boxcn6iShNLHlYfYjpczWr1rbcb.png"></p><p>收敛条件：</p><p><img src="/img/boxcnZskIJayXD4AQHZcYIF1r0g.png"></p><p>也记不住。主要就是说，至少是超线性收敛，满足–连续还平方收敛，收敛速度快。</p><p>Newton 迭代第一第二步计算量很大，</p><p>可以考虑用 F’(X0) 代替所有的 F’X – chord 方法；但是只能求解线性收敛的方程组。</p><p>一种折中的方法：m 次迭代更新一次 F‘x Jacobi   Shamanskii 方法 ；m+1 阶收敛，能保证超线性</p><p>在 F’x 非奇异或者病态时候使用的。遇到 F‘Xk 奇异或严重病态时 使用阻尼 Newton 法</p><p><img src="/img/boxcnt1uQFINxVBKodGIuPLoz3b.png"></p><p>这保证 F‘不理想的时候也能继续算的。引入一个阻尼参数，让其非病态奇异；阻尼的作用类似于往同一个方向慢一点迭代，以避免病态带来的过大误差。</p><p>离散 Newton，其实就是超短步长 h，数值逼近 Jacobi 矩阵。</p><p>需要注意的是，相较于一般的求微分方法，这里没有使用 1&#x2F;h[F(x+h)-F(x)] ,这是在避免两个相近数相减破坏有效位数</p><p><img src="/img/boxcnyaAXIFl1DjXnByK5X8ftfc.png"></p><p>取 hk&#x3D;Fxk 则收敛速度是二阶；在数值微分时，条件数和步长 h 成反比。</p><h2 id="线性方程组的迭代解法"><a href="#线性方程组的迭代解法" class="headerlink" title="线性方程组的迭代解法"></a>线性方程组的迭代解法</h2><h3 id="线性迭代思路"><a href="#线性迭代思路" class="headerlink" title="线性迭代思路"></a>线性迭代思路</h3><p>之前直接求解线性方程的方法是针对满矩阵设计的，但是实际问题中的 A 一般是大型稀疏矩阵，直接法并不适用。所以可以设计适合于稀疏版本的直接法，用迭代法（基于稀疏矩阵的）来求解。</p><p>稀疏矩阵 LU 分解后不一定稀疏。所以需要建构对应的算法</p><p>邻接矩阵 – 填充效应</p><p>MATLAB 函数 对称正定阵 pcg  preconditioned conjugate gradients method</p><p>bicgstab biconjugate gradients stabilized method</p><p>gmres_ generalized minimum residual method</p><p>colamd_ 线性方程直接解；重排可以减小填充效应，但是无法避免 ；</p><p>考虑直接迭代法</p><p>线性方程组的迭代解法，思路还是转换成某个方程的不动点求解问题。</p><p>为什么要有一个 Q 呢？为什么不是(A+I)x-b&#x3D;x 呢？  –  因为需要构造相应的迭代矩阵 B 是吗，Q 非奇异是构造的条件。Q&#x3D;I 就是最简单的迭代方法。</p><p><img src="/img/boxcnPTseBxMdsAIn6Es7hMRCrh.png"></p><p>线性方程迭代法，可以变换成 Bx+f&#x3D;x ； f 是线性映射。 (I-B)x&#x3D;f 有唯一解，I-B 可逆； 这仍然是一个不动点迭代问题。</p><p>收敛的条件：B 的范数小于 1，且 B 的范数越小收敛越快。</p><p><img src="/img/boxcnoFrHnIgWERw0F9PJwXiXQc.png"></p><p>实际应用时大多是求谱半径 &lt;1,收敛速度也与谱半径息息相关。</p><p><img src="/img/boxcnHbcSCAzKRRdNf7Uhdu63kf.png"></p><p>可以看到解的收敛速度是和矩阵范数相关的</p><p><img src="/img/boxcn89tzth3YYUJjrWhWXtvmpb.png"></p><p>最后用谱半径作计算，是因为：</p><p><img src="/img/boxcndItkvcbsYKSfA4t88folBy.png"></p><p>就是说，计算的收敛速度是 k 区域无穷时候的平均收敛速度。渐近收敛速度</p><h3 id="J-GS-方法"><a href="#J-GS-方法" class="headerlink" title="J-GS 方法"></a>J-GS 方法</h3><p>这几种方法主要区别在于迭代矩阵的构造。考虑矩阵的分裂：</p><p>A&#x3D;M-N  B&#x3D;M^-1N ， f&#x3D;M^-1b</p><p>常用的分裂方式：A&#x3D;D-L-U  分解成对角阵、严格下三角、严格上三角</p><p>jacobi 迭代方法中，M&#x3D;D，N&#x3D;L+U   ; Bj&#x3D; M^-1N&#x3D;D^-1(L+U)&#x3D;I-D^-1A  f&#x3D; D^-1b</p><p><img src="/img/boxcnPm58to9PSydQQtaPxOPe4c.png"></p><p>GS  gauss-seidel 方法：</p><p>和 Jacobi 方法不同的就是每迭代更新一行，下一行就用新的值迭代。表现在迭代矩阵上就是：</p><p>M&#x3D;D-L  N&#x3D;U</p><p>BG&#x3D; M^-1N&#x3D;(D-L)^-1U&#x3D;I - (D-L)^-1A</p><p><img src="/img/boxcnF29JUWlBDXnJCgVh9ZOgtg.png"></p><p>一些特殊矩阵的收敛：对角占优</p><p>对角占优矩阵：对角线上的元素绝对值比非对角线上的都大，&gt;&#x3D;；严格对角占优-都是严格大；弱占优-有一些可以取等，则非奇异</p><p>不可约若对角占优，非奇异  ；不可约是啥玩意—如果存在一个排列阵 P 使得 P’AP 为一个分块上三角阵，我们就称矩阵 A 是可约的，否则就称该矩阵是不可约的。</p><p>上面的两种矩阵，J 方法和 GS 方法收敛。</p><p>证明方法，想办法证明 ρ&lt;1</p><p>A 对称，对角元为正； Ax&#x3D;B</p><p>J 方法收敛的充分条件是 A 以及 2D-A 均正定</p><p>GS 方法收敛的条件是 A 对称正定</p><h3 id="SOR-方法"><a href="#SOR-方法" class="headerlink" title="SOR-方法"></a>SOR-方法</h3><p>使用系数 ω 加快收敛速度</p><p><img src="/img/boxcnyyPSMrDK7M45rdmo1FcYQd.png"></p><p>体现松弛因子思路的式子：x(k+1)&#x3D;ωX(k+1) +(1-ω)x(k) ，ω &gt;1 加速迭代；ω∈(0，2)</p><p><img src="/img/boxcn1edX12i9K6zfckt3rSFigb.png"></p><p>只需要背一个 M 的形式，由 GS 方法 D-L 变化而来：</p><p>$$<br>M&#x3D;1&#x2F;ω(D-ωL) ； N&#x3D;M-A&#x3D;1&#x2F;ω[(1-ω) D+ωU]<br>$$</p><p>迭代矩阵：B&#x3D;I-M^-1A</p><p>对阵正定阵-ω 在 0-2 收敛 证明过程：—- 利用对称、正定的性质，证明构造的任意对称正定阵的 SOR 迭代矩阵 λ&lt;1</p><p>最有松弛因子：</p><p><img src="/img/boxcn9s1ohdTtmCtlvR3jngyWHd.png"></p><p>构造迭代矩阵的过程，相当于在构造迭代思路中的 Q-1，预处理矩阵。</p><p><img src="/img/boxcnXsZgjyUWaqlURQtArMuUDg.png"></p><p>在计算迭代法时，一定要避免矩阵相乘和求逆；总之可以通过各种方法换算成矩阵 × 向量。</p><p>编程和手算时候，使用迭代法求解大型稀疏矩阵问题，要避免求逆、矩阵乘法等复杂操作。</p><h3 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h3><p><a href="https://zhuanlan.zhihu.com/p/98642663">共轭梯度法（一）：线性共轭梯度 - 知乎 (zhihu.com)</a></p><p>比经典方法更快的一种方法， 基于变分–求解方程组的问题等价转化成求解一个特殊的二次函数最小值问题。有一个很大的限制：要求 A 是对称正定。</p><p><img src="/img/boxcnqwTS9RMcLsIhJadWfcLKGh.png"></p><p>第一个性质是求下降梯度的关键，也是下降向量 r 的来源。第二个性质在推导最速下降和共轭梯度时中会用到。</p><p><img src="/img/boxcnX2KDATCvyp153UDW5G5GxH.png"></p><p>最速下降法只保证沿着一系列正交的方向寻找最快的下降方向，最快找到 φxmin</p><p><img src="/img/boxcnTg3PFK0SggjhYEFvFDWfJf.png"></p><p>寻找实数 αk 是由微分&#x3D;0 得到的。</p><p><img src="/img/boxcnZCZHeY4KvmNJMCqiNNQzof.png"></p><p>这个方法应该不考吧，由一些硬缺陷，也背不下来。。</p><p>性质：相邻两次的搜索方向是正交的；φx 存在极限；k 次迭代后误差的能量模会变小；</p><p><img src="/img/boxcnQBqO4BWAYnuX2LkIVcYxug.png"></p><p>上面的式子说明了最速下降法总是收敛的，但是当 λ1&gt;&gt;λn 时，收敛速度会非常慢；而且 rk 很小时，舍入误差太大，所以这个方法在实际计算时很少应用。作为共轭梯度法的启示–</p><p>共轭梯度法-conjugate gradient</p><p>思想和最速下降类似，还是一维极小值搜索，但是搜索的方向不再是 r 正交方向，而是选另一个方向 p；p 的选取有说法了：</p><p><img src="/img/boxcn9QX3GcNrqQXj7Cc6BrKoCd.png"></p><p>总之，结论就是 p 序列需要</p><p><img src="/img/boxcnd8JTjRmnK6etDrT13SWz9c.png"></p><p>满足 A 共轭</p><p><img src="/img/boxcnpvPzkzYCqF14c1tYKIzqQd.png"></p><p>在使用过程中确定 p(k+1)  基于 pk&#x3D;rk+β(k-1)p(k-1) ，即取 rk 和 pk-1 的线性组合。</p><p><img src="/img/boxcnvF6hQZCYz6wxbWtOxY4Gwd.png"></p><p>一些有用的性质，证明题可能用到：</p><p><img src="/img/boxcnyzyExeVm64xj0EsZ0rtwbc.png"></p><p><img src="/img/boxcnlnbkZG2d480eiNa01jLkYb.png"></p><p>具体的算法：</p><p><img src="/img/boxcnavLvty7jZPbGgJLeGCyKWh.png"></p><p>md，这么长怎么记得住啊</p><p>相较于其他线性方程组的迭代解法，CG 法最大的优势就是至多 n 步可以求解，一般情况下收敛速度都会很快的。例如在解二维大型泊松方程时</p><p>共轭梯度也有预处理：和直接法类似，把条件数弄小。不同的是，CG 方法的预处理中，需要处理后的矩阵还是对称正定的。体现在具体算法上就是</p><p><img src="/img/boxcnCExJUhvm2iHkHyHPCwV3pd.png"></p><p>更记不住了。。其中 M 是预处理矩阵，M&#x3D;LLT；z 是减少计算次数的中间变量。</p><p>matlab 函数 pcg</p><h2 id="代数特征值"><a href="#代数特征值" class="headerlink" title="代数特征值"></a>代数特征值</h2><p>一般不通过直接求解特征多项式的值来求特征值，（虽然我平时都是这么做的）</p><p>一般的方法是通过求友矩阵的特征值（他们特征值相等），而友矩阵的性质比较好 ；可以把一个高次代数的求根问题，转换成求一个稀疏矩阵特征值问题。</p><p><img src="/img/boxcnqVpdAth78TpaIQXiOpB3hB.png"></p><p>圆盘定理：估计特征值所在的范围，矩阵的 n 个特征值均落在 n 个圆盘上，n 个圆盘是复平面上以 a 对角元为中心每一行非对角元绝对值之和为半径的圆盘。这规定了特征值的取值范围，但是范围有些过大，即很多圆盘都可能没有落有特征值。</p><p><img src="/img/boxcnJ8KkSVHcfFAFNu0vT1rr1e.png"></p><p>就是说 λ 落点有对应的区分。最理想的情况当然是每个圆盘落有一个特征值；上面定理中 B 是对角阵，类似于左行右列的相似变换，即变换后有相同的特征值。变化的过程就相当于改变圆盘的半径，让他们互不相交，达到理想的情况。</p><h3 id="幂法"><a href="#幂法" class="headerlink" title="幂法"></a>幂法</h3><p>本质上是一种迭代方法。</p><p>A 的 n 个特征值，λ1&gt;λ2 &gt;&#x3D;…λn</p><p><img src="/img/boxcnAMULMgyhdHAPUfM0xF7Hce.png"></p><p>特征值-特征向量定义，当 k-&gt;∞，后面一项趋于零；但是前面的极限就一定存在吗？不一定的，无穷-0-or 1 。所以需要做一个归一化，让范数&#x3D;1。归一化的时候取一个向量的最大值，即无穷范数</p><p>幂迭代其实是求 λ1 的方法，主特征值；还能求主特征向量</p><p><img src="/img/boxcnqcqqg0AwByjw1bMGuBSCQf.png"></p><p>迭代方式：不断地左乘 A，然后归一化。</p><p>收敛性：mk 收敛于 λ1，vk 收敛于 xk 的归一化向量；收敛速度是线性收敛，收敛速度取决于 λ1&#x2F;λ2</p><p>逆幂迭代法</p><p>主要的思路就是求 A 逆的特征值，体现在迭代步骤中就是第二步 zk&#x3D;Avk-1  变成 Azk&#x3D;vk-1。这样求出 A 逆的主特征值，相当于 A 的最小特征值。</p><p>得到最大最小的特征值，则可以通过原点位移技巧来求中间的特征值，要求是中间特征值和其他特征值严格分离。</p><p>假设中间特征值和数值 q 最接近，则矩阵(A-qI)^-1 的主特征值为 1&#x2F;(λi-q) 。也就是求（A-qI^-1 的幂迭代。mk 会收敛到 1&#x2F;(λi-q)。确定 q 就是在确定圆盘，通过近似特征向量来确定。</p><p>幂法的优势是足够简单，循环迭代归一取极限，但是迭代多次才得到一个特征值，速度太慢了。总得有些一次性求出 n 个特征值的方法，QR 迭代。</p><h3 id="householder-变换"><a href="#householder-变换" class="headerlink" title="householder 变换"></a>householder 变换</h3><p>作 QR 分解的一种工具</p><p><img src="/img/boxcnZZRQLLpc3Vo5njCRpQs7Je.png"></p><p>w 定义了之后的 householder 变换，P u 相当于 u 与 w 垂直的平面镜像，初等反射。</p><p>性质：</p><p><img src="/img/boxcnqtJVrUEy3Gj50yQWZwiQ6g.png"></p><p>正交对称；正交变换不改变二范数；利用第五个性质可以构造 w</p><p><img src="/img/boxcnM4a3Gk5XJZBUwlrRDvQSdg.png"></p><p>e1 是只有第一个分离的方向向量，需要使 ke1 的二范数等于 x 的二范数，同时符号与 x1||x||2 相反（为了避免相近数相减）</p><p>W  P&#x3D;I-2wwT，Px&#x3D;ke1</p><p>上面构造的变换使得 x 变换后除了 x_1 都为零；类似的，可以构造使得 j+1~k 变换后为 0 的 P；子矩阵-</p><p>此时 u 的 j~k 分离不为 0：</p><p><img src="/img/boxcntvrv5WYWQHeC6iRzvyCrPd.png"></p><p><img src="/img/boxcnExhbARq1NLE3NR3ufkbzn6.png"></p><p>w&#x3D;u&#x2F;||u||2 变换后的 Px:</p><p><img src="/img/boxcn7BHA95ZkOCbcDfTkh4hRBd.png"></p><p>就像是从原来的 x 中取中间一截置 0.对应的变换矩阵，除了中间一截都是单位阵形式。中间的部分 P‘，类似于之前的整个变换。</p><p>givens 变换，在二维是一个旋转变换矩阵：</p><p><img src="/img/boxcnlRH1deaIevIQwuuNA2cPec.png"></p><p>Jx 等价于将 x 顺时针旋转 θ 角</p><p>推广到 n 维的情况，J(i，k，θ)相当于变换 i j 两行，左乘 J</p><p><img src="/img/boxcnWcTLI5oVVJqvdMcSwH1wzc.png"></p><p>具体的计算过程很像三角函数的公式。x，y，sqrt(x2+y2)</p><h3 id="QR-分解"><a href="#QR-分解" class="headerlink" title="QR 分解"></a>QR 分解</h3><p>一次性求出 n 个特征值的方法，QR 迭代。A1&#x3D;A;AK&#x3D;QKRK;AK+1&#x3D;RKQK</p><p><img src="/img/boxcnp4pC5RjGLnUiWyM0Xs9fNg.png"></p><p>ATA&#x3D;RTQTQR&#x3D;RTR，可以看成是 ATA 的 cholesky 分解。</p><p>用 householder 变换或 givens 变化把 P2P1R 变成上三角矩阵，然后 Q&#x3D;P2P1 T。R 对角线元素有非正，则中间分别左右乘对角阵 D。</p><p>变换好难啊-注意 householder 和 givens 的变换矩阵 P 都是正交阵，所以 Q 也是正交。</p><p>谱分解定理：</p><p>AX&#x3D;XD &lt; &#x3D;&#x3D;&gt; Axi&#x3D;λixi  ，只是 X 是 xi 特征向量组合成的矩阵，D 是 λi 对角阵 ；看上去很合理啊，</p><p>QR 迭代，希望迭代到一个对角阵。迭代的过程是在不断的相似变换。</p><p><img src="/img/boxcntuV5YIgPdmdfPmErLIATob.png"></p><p>H-共轭转置，是正交矩阵 QQT&#x3D;I 的推广；承酉矩阵相当于酉相似变换</p><p>雷姆了，第一次见到酉矩阵的用处。Schur 分解和 QR 分解很像，有一个很好的性质：</p><p><img src="/img/boxcntrJ5YgwWPrUnRMoyTHvkpd.png"></p><p>不放大误差；但是注意共轭是在复数域，所以计算 U 会很复杂。</p><p>Schur 分解：</p><p><img src="/img/boxcnpyqFYG66tdyRfcdWqoY2ab.png"></p><p>类似于上三角矩阵分解，注意正交阵变换不改变特征值，所以对角元素就是特征值。QR 迭代的目标就是得到最后的上三角形式。</p><p>A1&#x3D;A;AK&#x3D;QKRK;AK+1&#x3D;RKQK  &#x3D;&#x3D;&gt;R&#x3D;Q^TA&#x3D;A(K+1)Q^T  &#x3D;&#x3D;&gt; Q^TAQ&#x3D;A(K+1)</p><p>hessenberg 矩阵：</p><p><img src="/img/boxcnRQVRNyvNHHZ1OkKpNUPeOf.png"></p><p>这个就是 schur 分解的形式很相似，但是约束更弱。</p><p>变换过程：使用 householder 变换，对于第 j 列，a1j<del>ajj 不变，但是 aj+1j</del>anj 变为 0</p><p>注意左乘完 householder 变换阵 Pi 再右乘一个 Pi，作相似变换-不改变特征值；变成 hessenberg 矩阵而不是直接变成上三角阵，是因为在 hsh 变换的时候，如果按着上三角阵变，中间会把之前的 0 变回去。</p><p>n-2 次 hsh 相似变换就可以把 A 变成上 hessenberg 矩阵；注意，正交相似变换保证对称性，所以若 A 是对称阵，则变换完的矩阵是三对角阵。</p><h3 id="QR-迭代"><a href="#QR-迭代" class="headerlink" title="QR 迭代"></a>QR 迭代</h3><p><img src="/img/boxcnPJrMbNxn5wAgfOtcXp28Ag.png"></p><p><img src="/img/boxcn6kCIXneFECPwdxmBdMrnVM.png"></p><p>每次迭代都要错一次 QR 分解。</p><p>就讲到这了，晦气  差最后一步不讲完害我白复习那么久</p><p><img src="/img/boxcn4uqSxxcA2qDViwy5cpkROd.png"></p><p>迭代求解的思路</p><h2 id="期中题目"><a href="#期中题目" class="headerlink" title="期中题目"></a>期中题目</h2>]]></content>
    
    
    
    <tags>
      
      <tag>课程学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【调研学习】I2S音频驱动</title>
    <link href="/2022/09/15/%E3%80%90%E8%B0%83%E7%A0%94%E5%AD%A6%E4%B9%A0%E3%80%91I2S%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8/"/>
    <url>/2022/09/15/%E3%80%90%E8%B0%83%E7%A0%94%E5%AD%A6%E4%B9%A0%E3%80%91I2S%E9%9F%B3%E9%A2%91%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>学习使用IIS芯片驱动音频。<br>I2S(Inter-IC Sound)总线–集成电路内置音频总线，是由飞利浦半导体公司针对数字音频设备之间的音频数据传输而定制的一种音频总线标准。采用独立的时钟线和数据线，在主设备和从设备之间能够实现同步传输。I2S驱动需要硬件支持，所以之前使用的STM32都没有I2S功能，而ESP32支持音频开发，大多都搭载了I2S接口。<br>在此记录I2S驱动学习时考虑到的一些问题，并通过调研尝试给出解答。</p><h2 id="1-IIS各个引脚接口的作用是什么，如何使用IO口模拟IIS接口-初始化代码长啥样？"><a href="#1-IIS各个引脚接口的作用是什么，如何使用IO口模拟IIS接口-初始化代码长啥样？" class="headerlink" title="1.IIS各个引脚接口的作用是什么，如何使用IO口模拟IIS接口-初始化代码长啥样？"></a>1.IIS各个引脚接口的作用是什么，如何使用IO口模拟IIS接口-初始化代码长啥样？</h2><p>IIS总线，最简就是三条线：<br>BLCK-位时钟，bit clock，BCLK最低不低于采样频率*采样位数声道数<br>RLCK - 也叫WS，Word Select CLK ，左右声道选择时钟。0-左声道；1-右声道<br>SD serial data ，如果是MCU to I2Schip，在MCU是Dout，I2S芯片的Din</p><p>由MCU向I2S解码芯片传数据并播放，加上GND VCC一共五条线。<br>除此之外，一些I2S设备（ES8388）还需要主时钟，用于主从设备的同步，或者产生BCK；主时钟一般是MCU的主频，会高很多；如果是由声音采集的设备一般都需要主时钟和另一个Dout脚向MCU返回采集的PCM数据。<br>常用的数据传输标准由飞利浦标准、左对齐、短PCM格式。Philip FormatRLCK变化后第2个BCLK脉冲处变换声道数据，就是有一位延时。左对齐就是在WS电位变化时改变声道数据。PCM Short Format是每次变换WS都会有一个1周期的脉冲，动一次变换一次左右。<br><img src="/img/ESP-SPP/i2s-philipformat.png" alt="i2s-philipformat"></p><p>I2S在STM32中不适用，不过在ESP32中用到比较多。ESP32无论是基于ESP-IDF架构的工程还是基于arduino的工程，使用的I2S驱动头文件都是&lt;driver&#x2F;i2s.h&gt;<br>驱动的架构：<br><img src="/img/ESP-SPP/I2S_structure.PNG" alt="I2S_structure"><br>主要使用的是APP层接口，移植的话可能需要基于driver层修改。主要还是使用STD模式。</p><ul><li>i2s.h: The header file of legacy I2S APIs (for apps using legacy driver).</li><li>i2s_std.h: The header file that provides standard communication mode specific APIs (for apps using new driver with standard mode).</li><li>i2s_pdm.h: The header file that provides PDM communication mode specific APIs (for apps using new driver with PDM mode).</li><li>i2s_tdm.h: The header file that provides TDM communication mode specific APIs (for apps using new drivers with TDM mode).</li></ul><p>在<code>i2s.h</code>中使用的是最常见的总线协议初始化方式：封装好一个结构体，然后给出结构体参数配饰，再允许初始化函数；使用时会有类似于start者或write 函数运行。<br>引脚配置一般会在initial 结构体内。<br>在i2s.h 中，相关的配置结构体 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> mck_io_num;     <span class="hljs-comment">/*!&lt; MCK in out pin. Note that ESP32 supports setting MCK on GPIO0/GPIO1/GPIO3 only*/</span><br>    <span class="hljs-type">int</span> bck_io_num;     <span class="hljs-comment">/*!&lt; BCK in out pin*/</span><br>    <span class="hljs-type">int</span> ws_io_num;      <span class="hljs-comment">/*!&lt; WS in out pin*/</span><br>    <span class="hljs-type">int</span> data_out_num;   <span class="hljs-comment">/*!&lt; DATA out pin*/</span><br>    <span class="hljs-type">int</span> data_in_num;    <span class="hljs-comment">/*!&lt; DATA in pin*/</span><br>&#125; <span class="hljs-type">i2s_pin_config_t</span>;  <span class="hljs-comment">// 引脚配置 </span><br><br>...<br><span class="hljs-type">i2s_driver_config_t</span>;  <span class="hljs-comment">// 驱动配置 包括I2S的工作模式、采样率、位深、dma配置、数据格式等等。</span><br><br><span class="hljs-type">i2s_port_t</span>;<br><span class="hljs-comment">// 端口号，也就是一个MCU有几个I2S端口；</span><br><span class="hljs-comment">//sco_caps.h里面的SOC_I2S_NUM 决定最多有几个I2S口  一般是1</span><br></code></pre></td></tr></table></figure><p>一些最基础的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">esp_err_t</span> <span class="hljs-title">i2s_set_pin</span><span class="hljs-params">(<span class="hljs-type">i2s_port_t</span> i2s_num, <span class="hljs-type">const</span> <span class="hljs-type">i2s_pin_config_t</span> *pin)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">esp_err_t</span> <span class="hljs-title">i2s_driver_install</span><span class="hljs-params">(<span class="hljs-type">i2s_port_t</span> i2s_num, <span class="hljs-type">const</span> <span class="hljs-type">i2s_config_t</span> *i2s_config, <span class="hljs-type">int</span> queue_size, <span class="hljs-type">void</span> *i2s_queue)</span></span>;<br><span class="hljs-comment">//初始化函数。 端口号一般是0；配置结构体先初始化好，然后给出I2S事件队列。</span><br><br><span class="hljs-function"><span class="hljs-type">esp_err_t</span> <span class="hljs-title">i2s_driver_uninstall</span><span class="hljs-params">(<span class="hljs-type">i2s_port_t</span> i2s_num)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">esp_err_t</span> <span class="hljs-title">i2s_write</span><span class="hljs-params">(<span class="hljs-type">i2s_port_t</span> i2s_num, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> *bytes_written, TickType_t ticks_to_wait)</span></span>;<br><span class="hljs-function"><span class="hljs-type">esp_err_t</span> <span class="hljs-title">i2s_write_expand</span><span class="hljs-params">(<span class="hljs-type">i2s_port_t</span> i2s_num, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> src_bits, <span class="hljs-type">size_t</span> aim_bits, <span class="hljs-type">size_t</span> *bytes_written, TickType_t ticks_to_wait)</span></span>;<br><span class="hljs-comment">//主要用前者吧；expand增加数据量而不增加精度,主要是为了让数据格式适配总线配置</span><br><br><span class="hljs-function"><span class="hljs-type">esp_err_t</span> <span class="hljs-title">i2s_set_sample_rates</span><span class="hljs-params">(<span class="hljs-type">i2s_port_t</span> i2s_num, <span class="hljs-type">uint32_t</span> rate)</span></span>;<br><span class="hljs-function"><span class="hljs-type">esp_err_t</span> <span class="hljs-title">i2s_set_clk</span><span class="hljs-params">(<span class="hljs-type">i2s_port_t</span> i2s_num, <span class="hljs-type">uint32_t</span> rate, <span class="hljs-type">uint32_t</span> bits_cfg, <span class="hljs-type">i2s_channel_t</span> ch)</span></span>;<br><span class="hljs-comment">//  Similar to i2s_set_sample_rates(), but also sets bit width.</span><br><br><span class="hljs-function"><span class="hljs-type">esp_err_t</span> <span class="hljs-title">i2s_stop</span><span class="hljs-params">(<span class="hljs-type">i2s_port_t</span> i2s_num)</span></span>;<br><span class="hljs-function"><span class="hljs-type">esp_err_t</span> <span class="hljs-title">i2s_start</span><span class="hljs-params">(<span class="hljs-type">i2s_port_t</span> i2s_num)</span></span>;<br><span class="hljs-comment">/* It is not necessary to call this function after i2s_driver_install(),</span><br><span class="hljs-comment"> * however it is necessary to call it after i2s_stop().</span><br><span class="hljs-comment"> */</span><br> <br></code></pre></td></tr></table></figure><p>虽然官方的说明文档给到的应用层是i2s.h 也就是包含上面函数的头文件，但是在一些高级的应用中都额外封装了一层，例如 esp-adf中 i2s_stream.h 把I2S和audio_common，audio_pipeline 进行整合，让I2S流适应更多的音频数据传输模式。<br>在peripherals&#x2F;i2s 给出的最简化的I2S初始化例程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/i2s.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/queue.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> i2s_num = <span class="hljs-number">0</span>; <span class="hljs-comment">// i2s port number</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">i2s_config_t</span> i2s_config = &#123;<br>     .mode = I2S_MODE_MASTER | I2S_MODE_TX,<br>     .sample_rate = <span class="hljs-number">44100</span>,<br>     .bits_per_sample = <span class="hljs-number">16</span>,<br>     .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,<br>     .communication_format = I2S_COMM_FORMAT_I2S | I2S_COMM_FORMAT_I2S_MSB,<br>     .intr_alloc_flags = <span class="hljs-number">0</span>, <span class="hljs-comment">// default interrupt priority</span><br>     .dma_buf_count = <span class="hljs-number">8</span>,<br>     .dma_buf_len = <span class="hljs-number">64</span>,<br>     .use_apll = <span class="hljs-literal">false</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">i2s_pin_config_t</span> pin_config = &#123;<br>    .bck_io_num = <span class="hljs-number">26</span>,<br>    .ws_io_num = <span class="hljs-number">25</span>,<br>    .data_out_num = <span class="hljs-number">22</span>,<br>    .data_in_num = I2S_PIN_NO_CHANGE<br>&#125;;<br><br>...<br><br>    <span class="hljs-built_in">i2s_driver_install</span>(i2s_num, &amp;i2s_config, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);   <span class="hljs-comment">//install and start i2s driver</span><br><br>    <span class="hljs-built_in">i2s_set_pin</span>(i2s_num, &amp;pin_config);<br><br>    <span class="hljs-built_in">i2s_set_sample_rates</span>(i2s_num, <span class="hljs-number">22050</span>); <span class="hljs-comment">//set sample rates</span><br><br>    <span class="hljs-built_in">i2s_driver_uninstall</span>(i2s_num); <span class="hljs-comment">//stop &amp; destroy i2s driver</span><br><br></code></pre></td></tr></table></figure><h2 id="2-IIS-Data数据流如何写入，格式有要求吗？"><a href="#2-IIS-Data数据流如何写入，格式有要求吗？" class="headerlink" title="2.IIS Data数据流如何写入，格式有要求吗？"></a>2.IIS Data数据流如何写入，格式有要求吗？</h2><p>调用上述的 i2s_write 接口。<br>写入数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint8_t</span> *data_wr = (<span class="hljs-type">uint8_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint8_t</span>) * <span class="hljs-number">400</span>);<br><span class="hljs-type">size_t</span> i2s_bytes_write = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">i2s_write</span>(I2S_NUM_0, data_wr, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uint8_t</span>) * <span class="hljs-number">400</span>, &amp;i2s_bytes_write, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>关于data格式，可以是 u8* 也可以是u16*  u32*  int<em>，因为参数定义的是void</em><br>数据传入都是bit流的模式，只要注意与编码 .bits_per_sample 位数对应即可。<br>已经读过的数据会让&amp;i2s_bytes_write累加。</p><p>在各个audio框架中，想要把音源数据换成自己的数据，找到write语句，更改即可。</p><h2 id="3-典型的A2DP协议-驱动IIS的流程？"><a href="#3-典型的A2DP协议-驱动IIS的流程？" class="headerlink" title="3.典型的A2DP协议 驱动IIS的流程？"></a>3.典型的A2DP协议 驱动IIS的流程？</h2><p>数据流：<br><code>[Bluetooth] ---&gt; bt_stream_reader ---&gt; i2s_stream_writer ---&gt; codec_chip ---&gt; speaker</code><br>程序：<br>[ 1 ] Create Bluetooth service  初始化A2DP蓝牙协议</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_hf_client_api.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bluetooth_service.h&quot;</span></span><br><br>    <span class="hljs-type">bluetooth_service_cfg_t</span> bt_cfg = &#123;<br>             .device_name = <span class="hljs-string">&quot;ESP-ADF-AUDIO&quot;</span>,<br>            .mode = BLUETOOTH_A2DP_SINK,<br>        &#125;;<br>    <span class="hljs-built_in">bluetooth_service_start</span>(&amp;bt_cfg);<br>    <span class="hljs-built_in">esp_hf_client_register_callback</span>(bt_hf_client_cb);<br>    <span class="hljs-built_in">esp_hf_client_init</span>();<br></code></pre></td></tr></table></figure><p>[ 2 ] Start codec chip 初始化I2S编码解码芯片</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">audio_board_handle_t</span> board_handle = <span class="hljs-built_in">audio_board_init</span>();<br><span class="hljs-built_in">audio_hal_ctrl_codec</span>(board_handle-&gt;audio_hal, AUDIO_HAL_CODEC_MODE_DECODE, AUDIO_HAL_CTRL_START);<br></code></pre></td></tr></table></figure><p>[ 3 ] Create audio pipeline for playback 构建音频通道  并为pipeline绑定各种功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;i2s_stream.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;board.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;filter_resample.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;raw_stream.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;audio_element.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;audio_pipeline.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;audio_event_iface.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;audio_mem.h&quot;</span></span><br><br><br><span class="hljs-type">static</span> <span class="hljs-type">audio_element_handle_t</span>  raw_read, bt_stream_reader, i2s_stream_writer, i2s_stream_reader;<br><span class="hljs-type">static</span> <span class="hljs-type">audio_pipeline_handle_t</span> pipeline_d, pipeline_e;<br><br>...<br>    <span class="hljs-comment">//先初始化俩通道 编码和解码通道</span><br>    <span class="hljs-type">audio_pipeline_cfg_t</span> pipeline_cfg = <span class="hljs-built_in">DEFAULT_AUDIO_PIPELINE_CONFIG</span>();<br>    pipeline_d = <span class="hljs-built_in">audio_pipeline_init</span>(&amp;pipeline_cfg);<br>    pipeline_e = <span class="hljs-built_in">audio_pipeline_init</span>(&amp;pipeline_cfg);<br>    <br>    <span class="hljs-comment">//构建i2sstream  to write data 并read data</span><br>    <span class="hljs-type">i2s_stream_cfg_t</span> i2s_cfg1 = <span class="hljs-built_in">I2S_STREAM_CFG_DEFAULT</span>();<br>    i2s_cfg1.type = AUDIO_STREAM_WRITER;<br>    i2s_stream_writer = <span class="hljs-built_in">i2s_stream_init</span>(&amp;i2s_cfg1);<br>    <span class="hljs-type">i2s_stream_cfg_t</span> i2s_cfg2 = <span class="hljs-built_in">I2S_STREAM_CFG_DEFAULT</span>();<br>    i2s_cfg2.type = AUDIO_STREAM_READER;<br>    i2s_stream_reader = <span class="hljs-built_in">i2s_stream_init</span>(&amp;i2s_cfg2);<br>    <span class="hljs-comment">//audio 板使用的编解码芯片ES8388不仅有播放，还有从数字mic录音的功能 所以这里初始化了reader</span><br><br>    <span class="hljs-comment">//配置从蓝牙通道传过来的数据流</span><br>    <span class="hljs-type">raw_stream_cfg_t</span> raw_cfg = <span class="hljs-built_in">RAW_STREAM_CFG_DEFAULT</span>();<br>    raw_cfg.type = AUDIO_STREAM_READER;<br>    raw_read = <span class="hljs-built_in">raw_stream_init</span>(&amp;raw_cfg);<br>    bt_stream_reader = <span class="hljs-built_in">bluetooth_service_create_stream</span>();<br>    <br>    <span class="hljs-comment">//注册信息 到音频通道pipeline 并建立链接</span><br>    <span class="hljs-built_in">audio_pipeline_register</span>(pipeline_d, bt_stream_reader, <span class="hljs-string">&quot;bt&quot;</span>);<br>    <span class="hljs-built_in">audio_pipeline_register</span>(pipeline_d, i2s_stream_writer, <span class="hljs-string">&quot;i2s_w&quot;</span>);<br>    <span class="hljs-built_in">audio_pipeline_register</span>(pipeline_e, i2s_stream_reader, <span class="hljs-string">&quot;i2s_r&quot;</span>);<br>    <span class="hljs-built_in">audio_pipeline_register</span>(pipeline_e, raw_read, <span class="hljs-string">&quot;raw&quot;</span>);<br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *link_d[<span class="hljs-number">2</span>] = &#123;<span class="hljs-string">&quot;bt&quot;</span>, <span class="hljs-string">&quot;i2s_w&quot;</span>&#125;;<br>    <span class="hljs-built_in">audio_pipeline_link</span>(pipeline_d, &amp;link_d[<span class="hljs-number">0</span>], <span class="hljs-number">2</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *link_e[<span class="hljs-number">2</span>] = &#123;<span class="hljs-string">&quot;i2s_r&quot;</span>, <span class="hljs-string">&quot;raw&quot;</span>&#125;;<br>    <span class="hljs-built_in">audio_pipeline_link</span>(pipeline_e, &amp;link_e[<span class="hljs-number">0</span>], <span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-comment">//初始化外设  包括audio板的按键外设 和 Bluetooth音频输入外设</span><br>    <span class="hljs-type">esp_periph_config_t</span> periph_cfg = <span class="hljs-built_in">DEFAULT_ESP_PERIPH_SET_CONFIG</span>();<br>    <span class="hljs-type">esp_periph_set_handle_t</span> set = <span class="hljs-built_in">esp_periph_set_init</span>(&amp;periph_cfg);<br>    <span class="hljs-built_in">audio_board_key_init</span>(set);<br>    <span class="hljs-type">esp_periph_handle_t</span> bt_periph = <span class="hljs-built_in">bluetooth_service_create_periph</span>();<br>    <span class="hljs-built_in">esp_periph_start</span>(set, bt_periph);<br></code></pre></td></tr></table></figure><p> [ 4 ] 根据各种事件进行事件触发<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//根据相应的指令 播放or暂停事件</span><br><span class="hljs-keyword">if</span> (---)<br>    <span class="hljs-built_in">periph_bluetooth_play</span>(bt_periph);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>  (---)<br>    <span class="hljs-built_in">periph_bluetooth_pause</span>(bt_periph);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>  (---)<br>    <span class="hljs-built_in">periph_bluetooth_next</span>(bt_periph);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (---)<br>    <span class="hljs-built_in">periph_bluetooth_prev</span>(bt_periph);<br></code></pre></td></tr></table></figure><br> [ 5 ]  任务链最后就是释放内存<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">    <span class="hljs-comment">//结束任务 释放内存</span><br>    <span class="hljs-built_in">audio_pipeline_stop</span>(pipeline_d);<br>... 各种<span class="hljs-function">stop</span><br><span class="hljs-function">    <span class="hljs-title">audio_pipeline_unregister</span><span class="hljs-params">(pipeline_d, bt_stream_reader)</span></span>;<br>... 各种<span class="hljs-function">unregister</span><br><span class="hljs-function">    <span class="hljs-title">audio_pipeline_remove_listener</span><span class="hljs-params">(pipeline_d)</span></span>;<br>...<br>    <span class="hljs-built_in">audio_pipeline_deinit</span>(pipeline_d);<br>...<br>    <span class="hljs-built_in">bluetooth_service_destroy</span>();<br></code></pre></td></tr></table></figure></p><h2 id="4-编码解码的控制？目前有-mp3-aac-的编解码。"><a href="#4-编码解码的控制？目前有-mp3-aac-的编解码。" class="headerlink" title="4.编码解码的控制？目前有 mp3 aac 的编解码。"></a>4.编码解码的控制？目前有 mp3 aac 的编解码。</h2><p>可以找到相应的解码头文件。 aac、flac（Free Lossless Audio Codec -free无损压缩）、mp3。<br>在ESP32中配置相应的解码器，可以将收到的数据解码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mp3_decoder.h&quot;</span></span><br><br><span class="hljs-built_in">ESP_LOGI</span>(TAG, <span class="hljs-string">&quot;Create mp3 decoder to decode mp3 file.&quot;</span>);<br><span class="hljs-type">mp3_decoder_cfg_t</span> mp3_cfg = <span class="hljs-built_in">DEFAULT_MP3_DECODER_CONFIG</span>();<br>mp3_decoder = <span class="hljs-built_in">mp3_decoder_init</span>(&amp;mp3_cfg);<br><br><span class="hljs-built_in">audio_element_set_read_cb</span>(mp3_decoder, mp3_music_read_cb, <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//mp3_music_read_cb 在解码完成后的回调函数 继续解码下一段数据</span><br><span class="hljs-comment">//这里的回调函数决定了从哪里读mp3原始二进制数据 一般是file</span><br><br><span class="hljs-built_in">audio_pipeline_register</span>(pipeline, mp3_decoder, <span class="hljs-string">&quot;mp3&quot;</span>);<br> <span class="hljs-comment">//需要在音频通道中注册mp3解码器 </span><br></code></pre></td></tr></table></figure><p>传输时可以把数据压缩后，在ESP32中调用相应的解码器解码，再播放。<br>上面的例子封装程度比较高，在 配置完audio_pipeline 的解码器、I2S输出通道后，run时会自动写入I2S数据流，所以没有解码后的数据写入语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;audio_element.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;audio_pipeline.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;audio_event_iface.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;audio_mem.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;audio_common.h&quot;</span></span><br><br><span class="hljs-built_in">audio_pipeline_run</span>(pipeline);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief    Start Audio Pipeline.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *           With this function audio_pipeline will create tasks for all elements,</span><br><span class="hljs-comment"> *           that have been linked using the linking functions.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param[in]  pipeline   The Audio Pipeline Handle</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br>由于之前绑定了mp3解码器和i2s writer，run会触发绑定元素的事件：解码并写入。<br><span class="hljs-comment">//---各种错误检查 前置判断 如果正确的话，就会执行：</span><br>...<br>    <span class="hljs-built_in">audio_element_run</span>(el_item-&gt;el); <br>...<br><span class="hljs-comment">//---其中el_item 是输入Pipeline绑定的元素，el是对应的事件</span><br></code></pre></td></tr></table></figure><h2 id="5-DMA-IIS怎么使用，对于SRAM-是必需吗，不用SRAM会有何限制？流畅播放的典型缓存有多大？"><a href="#5-DMA-IIS怎么使用，对于SRAM-是必需吗，不用SRAM会有何限制？流畅播放的典型缓存有多大？" class="headerlink" title="5.DMA IIS怎么使用，对于SRAM 是必需吗，不用SRAM会有何限制？流畅播放的典型缓存有多大？"></a>5.DMA IIS怎么使用，对于SRAM 是必需吗，不用SRAM会有何限制？流畅播放的典型缓存有多大？</h2><p>不需要额外的命令，I2S驱动会自动调用DMA通道。write、read 命令在I2S总线的TX RX通道都有对应的DMA通道，两者独立。<br>I2S的数据传输：<br>I2S外设的所有数据传输都是通过DMA实现的。当发送或接收的数据达到一个 DMA 缓冲区的大小时，将触发 I2S_OUT_EOF 或 I2S_IN_SUC_EOF 中断。<br>具体的触发程序、回调函数没有说明的在哪一层，但是原理是收数据-到一定量-传到I2S数据缓存区。</p><p>SRAM不是必须的，可以用flash存。虽然flash的读写速度不如SRAM，但是也足够音频播放的数据读写了。<br>使用时，音频数据类似于一个环形链表，“环形”地读写新的数据。<br>注意程序设计时不要把数据链表读到内存，会放不下。之前写的程序把80k的缓存数据都放在内存，RAM基本就满了，不是合适的设计。可以放在flash内。某个例程中flash内数据表的大小约为60KB。<br>4MB ESP32的flash分区默认的是前1MB存运行程序，后3MB存数据，为了保护安全程序中不会修改固件分区的flash内容。</p><p>具体的flash操作API使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;esp_partition.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PARTITION_NAME   <span class="hljs-string">&quot;storage&quot;</span></span><br><span class="hljs-comment">//flash record size, for recording 5 seconds&#x27; data</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLASH_RECORD_SIZE         (EXAMPLE_I2S_CHANNEL_NUM * EXAMPLE_I2S_SAMPLE_RATE * EXAMPLE_I2S_SAMPLE_BITS / 8 * 5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLASH_ERASE_SIZE          (FLASH_RECORD_SIZE % FLASH_SECTOR_SIZE == 0) ? FLASH_RECORD_SIZE : FLASH_RECORD_SIZE + (FLASH_SECTOR_SIZE - FLASH_RECORD_SIZE % FLASH_SECTOR_SIZE)</span><br><span class="hljs-comment">//sector size of flash</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLASH_SECTOR_SIZE         (0x1000)</span><br><span class="hljs-comment">//flash read / write address</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLASH_ADDR                (0x200000)</span><br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @brief erase flash for recording</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">example_erase_flash</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief debug buffer data</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">example_disp_buf</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span>* buf, <span class="hljs-type">int</span> length)</span></span>;<br><br><span class="hljs-comment">//具体使用时的程序：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">example_flashuse_task</span><span class="hljs-params">(<span class="hljs-type">void</span>*arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//0.验证flash空间 </span><br>    <span class="hljs-type">const</span> <span class="hljs-type">esp_partition_t</span> *data_partition = <span class="hljs-literal">NULL</span>;<br>    data_partition = <span class="hljs-built_in">esp_partition_find_first</span>(ESP_PARTITION_TYPE_DATA,<br>            ESP_PARTITION_SUBTYPE_DATA_FAT, PARTITION_NAME);<br>    <span class="hljs-keyword">if</span> (data_partition != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;partiton addr: 0x%08x; size: %d; label: %s\n&quot;</span>, data_partition-&gt;address, data_partition-&gt;size, data_partition-&gt;label);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">ESP_LOGE</span>(TAG, <span class="hljs-string">&quot;Partition error: can&#x27;t find partition name: %s\n&quot;</span>, PARTITION_NAME);<br>        <span class="hljs-built_in">vTaskDelete</span>(<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-comment">//1. Erase flash</span><br>    <span class="hljs-built_in">example_erase_flash</span>();<br>    <span class="hljs-type">int</span> i2s_read_len = EXAMPLE_I2S_READ_LEN;<br>    <span class="hljs-type">int</span> flash_wr_size = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">size_t</span> bytes_read, bytes_written;<br><br>    <span class="hljs-comment">//2. write data to flash</span><br>    <span class="hljs-type">uint8_t</span>* flash_write_buff = (<span class="hljs-type">uint8_t</span>*) <span class="hljs-built_in">calloc</span>(i2s_read_len, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br>    <span class="hljs-keyword">while</span> (flash_wr_size &lt; FLASH_RECORD_SIZE) &#123;<br><br>        <span class="hljs-comment">//每次写入的数据flash_write_buff 长度write_buff_len data_partition记录分区和flash_wr_size分区后多少bytes开始写入</span><br>        <span class="hljs-comment">//在此修改flash_write_buff的值</span><br>        <br>        <span class="hljs-built_in">esp_partition_write</span>(data_partition, flash_wr_size, flash_write_buff, write_buff_len);<br>        flash_wr_size += write_buff_len;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(flash_write_buff);<br>    flash_write_buff = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">//3. Read flash</span><br>    <span class="hljs-type">uint8_t</span>* flash_read_buff = (<span class="hljs-type">uint8_t</span>*) <span class="hljs-built_in">calloc</span>(i2s_read_len, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> rd_offset = <span class="hljs-number">0</span>; rd_offset &lt; flash_wr_size; rd_offset += FLASH_SECTOR_SIZE) &#123;<br>        <span class="hljs-comment">//read I2S(ADC) original data from flash</span><br>        <span class="hljs-built_in">esp_partition_read</span>(data_partition, rd_offset, flash_read_buff, FLASH_SECTOR_SIZE);<br>        <br>        <span class="hljs-comment">//在此对读出的FLASH_SECTOR_SIZE 长度的数据flash_read_buff进行操作 </span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-比起IIC-DAC-或者直接DAC的方案，IIS的优势在哪？位深-频率-or数据处理逻辑？"><a href="#6-比起IIC-DAC-或者直接DAC的方案，IIS的优势在哪？位深-频率-or数据处理逻辑？" class="headerlink" title="6.比起IIC-DAC 或者直接DAC的方案，IIS的优势在哪？位深 频率 or数据处理逻辑？"></a>6.比起IIC-DAC 或者直接DAC的方案，IIS的优势在哪？位深 频率 or数据处理逻辑？</h2><p>目前所接触到的音频输出方式有三种：<br>1.MCU内置DAC通道输出<br>2.外置I2C-DAC 模块输出<br>3.外置I2S 解码 模块输出</p><table><thead><tr><th align="center"></th><th align="center">内置DAC</th><th align="center">I2C-DAC</th><th align="center">I2S</th></tr></thead><tbody><tr><td align="center">外接芯片</td><td align="center">N</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">频率</td><td align="center">&gt;48K</td><td align="center">高速模式可勉强&gt;48K</td><td align="center">&gt;48K</td></tr><tr><td align="center">位深</td><td align="center">8~12bit</td><td align="center">8~24bit <br />高位DAC芯片很贵</td><td align="center">16~32bit<br />24bit标配</td></tr><tr><td align="center">数据格式</td><td align="center">PCM-DAC</td><td align="center">PCM-DAC</td><td align="center">PCM &amp; PDM &amp;DAC</td></tr><tr><td align="center">总线通信带宽</td><td align="center">∞ 无片外通信</td><td align="center">I2C总线带宽<br />高速约3.4Mbit&#x2F;s</td><td align="center">32bit-96K<br />音频够用</td></tr></tbody></table><p>相较于I2C协议，I2S协议同样是同步时钟，无需应答，使用两条数据线实现双工通信，无抢占，可以实现更高频的通信。<br>I2S是专门为数字音频传输设计的，在音频输出时使用更合理。但是其他类型的DAC输出控制可能就不太适用。高质量音频输出还是得I2S解码芯片。<br>此外，手动写DAC，需要自己配置timer， 周期&#x3D;1s&#x2F;fs 。高频时每次都只进行一次DAC操作，占用CPU资源较多。而I2S协议，在ESP32的架构中，配有FIFO寄存器搭配MCLK分频的预设时钟进行通信，时序设计会简单很多。</p><h2 id="7-使用ESP32内部ADC-DAC-Mode可行吗？如何使用，有无接口？"><a href="#7-使用ESP32内部ADC-DAC-Mode可行吗？如何使用，有无接口？" class="headerlink" title="7.使用ESP32内部ADC&#x2F;DAC Mode可行吗？如何使用，有无接口？"></a>7.使用ESP32内部ADC&#x2F;DAC Mode可行吗？如何使用，有无接口？</h2><p>I2S 输出可以直接路由DAC通道输出(GPIO 25 和 GPIO 26),而不通过外部 I2S 编解码器.<br>ADC&#x2F;DAC Mode<br>ADC and DAC modes only exist on ESP32 and are only supported on I2S0. Actually, they are two sub-modes of LCD&#x2F;Camera mode. I2S0 can be routed directly to the internal analog-to-digital converter(ADC) and digital-to-analog converter(DAC). In other words, ADC and DAC peripherals can read or write continuously via I2S0 DMA. As they are not an actual communication mode, the I2S driver does not implement them.</p><p>使用内部DAC进行模拟输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;driver/i2s.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;freertos/queue.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> i2s_num = <span class="hljs-number">0</span>; <span class="hljs-comment">// i2s port number</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief I2S ADC/DAC mode init.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">example_i2s_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-type">int</span> i2s_num = EXAMPLE_I2S_NUM;<br>     <span class="hljs-type">i2s_config_t</span> i2s_config = &#123;<br>        .mode = I2S_MODE_MASTER | I2S_MODE_RX | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN | I2S_MODE_ADC_BUILT_IN,<br>        .sample_rate =  EXAMPLE_I2S_SAMPLE_RATE,<br>        .bits_per_sample = EXAMPLE_I2S_SAMPLE_BITS,<br>        .communication_format = I2S_COMM_FORMAT_STAND_MSB,<br>        .channel_format = EXAMPLE_I2S_FORMAT,<br>        .intr_alloc_flags = <span class="hljs-number">0</span>,<br>        .dma_buf_count = <span class="hljs-number">2</span>,<br>        .dma_buf_len = <span class="hljs-number">1024</span>,<br>        .use_apll = <span class="hljs-number">1</span>,<br>     &#125;;<br>     <span class="hljs-comment">//install and start i2s driver</span><br>     <span class="hljs-built_in">i2s_driver_install</span>(i2s_num, &amp;i2s_config, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>     <span class="hljs-comment">//init DAC pad</span><br>     <span class="hljs-built_in">i2s_set_dac_mode</span>(I2S_DAC_CHANNEL_BOTH_EN);<br>     <span class="hljs-comment">//init ADC pad</span><br>     <span class="hljs-built_in">i2s_set_adc_mode</span>(I2S_ADC_UNIT, I2S_ADC_CHANNEL);<br>&#125;<br></code></pre></td></tr></table></figure><p>设置initial后，不用设置I2Spin，配置DAC通道使能即可。<br>写入依然是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint8_t</span>* i2s_write_buff = (<span class="hljs-type">uint8_t</span>*) <span class="hljs-built_in">calloc</span>(i2s_read_len, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br><br><span class="hljs-built_in">i2s_write</span>(EXAMPLE_I2S_NUM, i2s_write_buff, FLASH_SECTOR_SIZE, &amp;bytes_written, portMAX_DELAY); <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>IOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【调研学习】蓝牙-音频-协议栈</title>
    <link href="/2022/09/06/%E3%80%90%E8%B0%83%E7%A0%94%E5%AD%A6%E4%B9%A0%E3%80%91%E8%93%9D%E7%89%99-%E9%9F%B3%E9%A2%91-%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
    <url>/2022/09/06/%E3%80%90%E8%B0%83%E7%A0%94%E5%AD%A6%E4%B9%A0%E3%80%91%E8%93%9D%E7%89%99-%E9%9F%B3%E9%A2%91-%E5%8D%8F%E8%AE%AE%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>项目需要使用蓝牙传输较多的数据，配置完发现带宽不够，所以找了市面上的嵌入式蓝牙模块，即使能找到最大带宽的模块，也只有60k byte&#x2F;S，而且是基于蓝牙2.0 ble双模模块HC-04，SSP协议下才能实现这么高带宽的传输。完成项目通讯需求，仅仅换一个能支持这个带宽的模块也许就完事儿了，但这对于技术的进步显然是不够的。在此，提出一些相关的问题，并尝试通过调研给出可能的答案。</p><h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><p>1.是什么限制了蓝牙通信的带宽？蓝牙耳机是如何实现高质量音频数据传输的？<br>2.调研时发现ESP系列MCU芯片可以支持蓝牙wifi通信，ESP32 系列MCU比起模块化的蓝牙芯片有什么优势，可以自己改协议栈吗？<br>3.各个协议栈到底是怎么回事，如果想根据要求自定义蓝牙协议栈，有无比较快上手的方法？<br>4.目前高性能鼠标会采用2.4G通信模块，比起蓝牙2.4G通信有什么优势，为什么2.4G通信没有蓝牙应用的广？<br>5.买的蓝牙模块在十几块到上百块不等，而且还都不能实现高带宽数据传输。为什么蓝牙耳机中，传音频的蓝牙模块能做的这么便宜，支持蓝牙耳机最小功能的蓝牙芯片大概长啥样？</p><h2 id="1-什么限制了蓝牙通信的带宽"><a href="#1-什么限制了蓝牙通信的带宽" class="headerlink" title="1.什么限制了蓝牙通信的带宽"></a>1.什么限制了蓝牙通信的带宽</h2><p>是功率，或者说物理层PHY协议栈。<br>蓝牙最初设计的初衷就是代替近红外无线遥控，走音视频实在难为人家。蓝牙和Wifi虽然同处于2.4G频段，但功率差了好几个量级，蓝牙设计时目标就是低功率无线通信，因此,[物理层协议栈]中的数据处理速率受到限制,以适配这种低功耗。<br>Wi-Fi has a maximum speed that is much faster than Bluetooth: at least 54 Mbps for Wi-Fi, vs. only 3 Mbps for Bluetooth. As a result, Bluetooth is typically used for transferring small chunks of data, such as numerical values from IoT sensors. Wi-Fi, on the other hand, is better for sending large data files, such as videos and photos.<br>目前物理层所能处理的极限速率是[54 M bps]，也就是在”理想信道条件”下PHY级别可实现的最大原始吞吐量，但实际应用中，最高也就 BT3.0 HighSpeed模式曾经实现的24M bps，3M bytes&#x2F;S。蓝牙具体的空中传输速率众说纷纭，甚至还有蓝牙版本越高传输速度越大的，怀疑是无量厂商宣传时不懂具体技术，然后做科普时也没弄懂就照搬了。<br>从蓝牙联盟官网找到的传输速率：</p><p><img src="/img/ESP-SPP/BT-DATARATE.PNG" alt="BT-DATARATE"></p><p>对于上电工作而非电池供电的系统，功率显然不是硬指标，所以低版本的蓝牙可能更适合。当然蓝牙5.2的传输速率在大多数时候也是够的，目前ble 5.0就可以传输高质量音频，但是需要一定的压缩编码。比如说48kHz 16位深双声道，数据量就有192kHz ，1.536Mbps，以及非常接近ble的物理极限了。实际应用中不可能在物理极限传输，如果做音频传输需要配置A2DP（Advanced Audio Distribution）蓝牙音乐协议，这个协议在蓝牙5.2的带宽是1Mbps，不支持48kHz 16位深双声道的音频传输。<br>目前高质量音频都需要编码解码，类似于压缩解压。<br>压缩编码主要在A2DP协议层中进行，主要包括：AAC、SBC、APTX、LDAC等。<br>简要介绍一下：<br>SBC，标准音质编码，A2DP强制规定的编码格式，也就是人们说的子带编码，所有蓝牙都支持这一编码。比特率较低，压缩率不高。<br>“AAC”， （Advanced Audio Coding，高级音频编码），属于高级音频的编码，高压缩比的编码算法。<br>“apt-X”，属于一种子带ADPCM的数字音频压缩算法，CSR发展，后被高通收购，后来衍生出低延时、HD两种编码方式。<br>“LDAC”，索尼所研发推出的一种“无线”编码技术，非常粗暴地提高信道，带宽：质量最优的990Kbps、默认的660Kbps普通版本，以及最后的标准330Kbps<br>HWA（HiRes Wireless Audio）高音质蓝牙协定，由华为提出，基于LHDC的编码协议。<br>好的音质不仅取决于蓝牙版本，更多地是编码的方式，这需要芯片有更高的算力。而蓝牙的带宽是基础协议栈决定的，比较难改，只能在压缩编码上下功夫。所以对于更高带宽追求，可以换成传统蓝牙的HighSpeed协议（不过目前还没找到这个模块，开发模块厂商HC2.0 4.0 5.0都有就是没有3.0）如果换不了，拿只能在协议栈上下功夫了</p><h2 id="2-ESP32-系列MCU比起模块化的蓝牙芯片有什么优势，可以自己改协议栈吗？"><a href="#2-ESP32-系列MCU比起模块化的蓝牙芯片有什么优势，可以自己改协议栈吗？" class="headerlink" title="2.ESP32 系列MCU比起模块化的蓝牙芯片有什么优势，可以自己改协议栈吗？"></a>2.ESP32 系列MCU比起模块化的蓝牙芯片有什么优势，可以自己改协议栈吗？</h2><p>ESP32可以改协议栈，但是只能改Host中的协议栈。当然，加入蓝牙功能后，controller的协议栈肯定是有的，但是改起来学习成本很大。<br>比起蓝牙模块，使用ESP32实现蓝牙功能，可以省一个MCU。ESP32的flash、SRAM都比同价位的STM32芯片大，而且主频也更高，就是IO口不够，往往需要功能复用。同时，虽然同价位的ESP32SRAM和ROM都比STM23大，近一倍，但是如果加入了蓝牙协议栈，几乎就占用了70%的SRAM，其余的可用空间也就和同价位STM32差不多了。</p><p>ESP32也是系列芯片，目前产品还没有STM23系列多，但是官方不止卖芯片，还买贴片模组和开发板，还很便宜！不过大多数芯片都不带DAC功能，可能需要IIC接口外接DAC芯片。不过ESP32基本都带IIS协议接口，这个可用接音频解码播放芯片，具体的播放芯片还没有调研选型，不过大概知道他能干这件事儿。</p><h2 id="3-各个协议栈到底是啥关系，如何快速改成想要的样子？"><a href="#3-各个协议栈到底是啥关系，如何快速改成想要的样子？" class="headerlink" title="3.各个协议栈到底是啥关系，如何快速改成想要的样子？"></a>3.各个协议栈到底是啥关系，如何快速改成想要的样子？</h2><p>协议栈的组成也是众说纷纭，具体原因的经典蓝牙、ble蓝牙的协议栈会有不同，而其他人搬过去的时候也只是机械地翻译 ，协议栈有多少多少层，每层有什么功能，对初学者非常不友好，看完往往是一头雾水。</p><p>后来找到一篇讲得好的教程：<a href="https://wlink.blog.csdn.net/article/details/107727900">CSDN:一篇文章足够你学习蓝牙技术</a><br><img src="/img/ESP-SPP/BTprofile.PNG" alt="BTprofile"></p><p>大致的原理都是类似的：controller于底层RF交互、HCI交连controller和Host，Host中搭建应用功能服务协议。架构都是相似的，其中controller层的协议决定了是BLE还是经典BT。手机、电脑中大多都是双模的底层协议。<br><img src="/img/ESP-SPP/BTPconstant.PNG" alt="BTPconstant"><br>transport层决定了controller和Host交互的通信协议，片外通信。常见的有UART USB SDIO。USB是D+、D-,用的是差分线,这样的话可以支持的速率更高，虽然和UART都是异步串行协议，但是USB通过差分稳定以及打包发送能实现更快的速度；SDIO是SD卡的读取协议，属于同步串行协议。SDIO和USB协议的通信速度都比UART高，但是对于2Mbps的底层速率，UART显然够用了。<br>之前买的很多模块，HC-05 ATK-BLE HC-08等等，大多都只是在无线收发芯片中封装了底层协议，给出了UART接口，然后就可以接入单片机使用了。但是这种使用方法，由于没有Host协议栈，即使能匹配上电脑的蓝牙，也无法通信。可以在单片机中完善Host协议栈，配置SSP协议，在与电脑内置蓝牙配对后，那么蓝牙设备会被识别出一个串口，可以生成对应的串口号进行通信了。亦或者配置A2DP协议，这一与电脑蓝牙匹配后会被识别出蓝牙耳机，进行音频数据传输。<br>协议栈给出了更多功能服务的协议组成，例如想搭载A2DP协议，就得先有AVDTP协议。在搭载了LE协议的同时，也有A2DP协议，则设备会被主机识别为音频播放设备。<br>在ESP32的开发平台中，有基于espressif IDF的框架和基于Arduino的框架。如果使用Espressif框架，在SDK configuration editor给出了无代码、选择配置的界面。<br><img src="/img/ESP-SPP/ESP32-BTconfig.PNG" alt="ESP32-BTconfig"><br>在创建工程时可以选择是否开启蓝牙协议栈、controller模式、运行内核、HCI接口、最大连接数等等。当然也可以基于协议栈代码自己改。</p><h2 id="4-目前高性能鼠标会采用2-4G通信模块，比起蓝牙2-4G通信有什么优势，为什么2-4G通信没有蓝牙应用的广？"><a href="#4-目前高性能鼠标会采用2-4G通信模块，比起蓝牙2-4G通信有什么优势，为什么2-4G通信没有蓝牙应用的广？" class="headerlink" title="4.目前高性能鼠标会采用2.4G通信模块，比起蓝牙2.4G通信有什么优势，为什么2.4G通信没有蓝牙应用的广？"></a>4.目前高性能鼠标会采用2.4G通信模块，比起蓝牙2.4G通信有什么优势，为什么2.4G通信没有蓝牙应用的广？</h2><p>蓝牙的标准比2.4G多 拥有IEEE标准，可以实现多设备传输，可以一对多，不需要外置专门的接收器。蓝牙计数可以使可连接的设备更加广泛，工作模式也更加便捷。蓝牙增加了自适应调频计数，一般只要有蓝牙模块即可连接，但是速度慢，带宽较小。<br>2.4G信号传输频率更高，需要专用的一对一接收器，且只能一对一通信，但是在单点性能上比蓝牙更好。需要和自带的USB接收器对码才能使用，一般来说不是自己的接收器无法使用。不过它占用的频宽大，响应快，中高端产品已经做到和USB有线一样的1000HZ，也就是1ms一个包，而蓝牙不行，最多每秒百次。<br>现在自己的鼠标MS Master基于 罗技USB UNIFYING RECEIVER ，这个模块基于nEF24L 2.4G通信模块。相对于蓝牙，其接收器需要占用USB口。早期罗技的U联接受只支持鼠标，后来加入了键盘、耳机。LIGHTSPEED计数在鼠标中更是天花板，UR相较而言会差一些，但能多设备接收，同时比蓝牙速度更快。</p><h2 id="5-支持蓝牙耳机最小功能的蓝牙芯片大概长啥样？"><a href="#5-支持蓝牙耳机最小功能的蓝牙芯片大概长啥样？" class="headerlink" title="5.支持蓝牙耳机最小功能的蓝牙芯片大概长啥样？"></a>5.支持蓝牙耳机最小功能的蓝牙芯片大概长啥样？</h2><p>某宝搜蓝牙耳机，最便宜的30块钱就能买到。是怎么做到这么便宜的？<br>降低蓝牙耳机成本的关键是芯片选型。找到一款便宜的WT2605-24SS 蓝牙MP3芯片：<br><img src="/img/ESP-SPP/WT2605-24SS.PNG" alt="WT2605-24SS"><br>像上面这一款，集成了蓝牙通信、扬声器播放、麦克风输入、UART通信配置、USB、SPI-SD卡数据读取。这是一款几乎集成了所有蓝牙MP3播放器功能的芯片。<br>有一个16 bit DAC音频解码器,通讯速率高达1Mbps 。具体的解码方式应该是最基础的SBC ，AAC带宽不支持。<br>也有其他的蓝牙-音频芯片，价格几块钱到几十块不等。支持不同的蓝牙版本、编解码方式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>IOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【IOT开发】蓝牙SPP协议的使用</title>
    <link href="/2022/09/06/%E3%80%90IOT%E5%BC%80%E5%8F%91%E3%80%91%E8%93%9D%E7%89%99SPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/06/%E3%80%90IOT%E5%BC%80%E5%8F%91%E3%80%91%E8%93%9D%E7%89%99SPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>之前有个项目需要在PC端通过蓝牙发送数据给单片机，由于当时还不太懂蓝牙协议，使用的是PC-USB-BT 到BT-MCU的方案，会多出来一个USB-UART-BT模块硬件。之后调研学习了解到 可以通过搭建SPP协议使得连接到PC蓝牙后生成一个COM号，进行数据传输。<br>本次使用基于 ESP32 的蓝牙串口协议，具体见官方例程：<br><code>esp-idf\examples\bluetooth\bluedroid\classic_bt\bt_spp_acceptor</code></p><h2 id="SPP"><a href="#SPP" class="headerlink" title="SPP"></a>SPP</h2><p>把例程编译下载后，在PC端连接上对应的蓝牙服务，会发现多出来两个端口：<br><img src="/img/ESP-SPP/COM.PNG" alt="SPP-COM"><br>很自然的生成了两个端口号  注意其中一个是 pc发送，下位机接收服务，另一个是pc接收，ESP32发送服务。具体哪个是发送,可以在蓝牙设备-更多蓝牙选项-COM端口中查看。</p><p>在使用时，遇到了带宽不够的问题，在论坛也遇到了类似问题，但是没有现成的回答。不过之后通过调研找到了可能的解决方案。<br><a href="https://github.com/espressif/esp-idf/issues/9356">https://github.com/espressif/esp-idf/issues/9356</a><br>我之后给ESPRESSIF技术支持发邮件，他答复了一下，然后我答复了一下他的答复：</p><blockquote><p>Thanks for reply. I think I have solved this problem by increasing the frequency of sending and the amount of data per packet.<br>  1.BT SPP speed is not affected by baud rate, because RFCOMM, the configuration file under SPP, will try to transmit data packets as fast as possible. You can change Virtue BT COM in the Device Manager, but it’s useless for transmission speed. We are used to the design of hardware UART, and the best way to increase the data rate is to change the baud rate, but this is not necessary when using Bluetooth SPP.<br>  2.The default MTU size is 990 bytes, but you can send a larger MTU to get more bandwidth. When increasing the packet size is useless, you can increase the sending frequency. Don’t config the send interval less than 10 ms, because the MAX ACK Fre of BT is about 100 Hz. Higher fre may lead to packet loss. In my Windows PC, the data speed can achieve 1200 kbps-150 kB&#x2F;s with 20 send interval and 3 kB Per packet.</p><blockquote><p>Hi @naragururaj,<br>Thanks for reporting the issue. The SPP throughput can be affected by many reasons:<br>The default MTU size of classic Bluetooth SPP on ESP32 is 990 bytes, and higher throughput can be achieved in the case that data chunck size is close to the MTU size or multiple of MTU size. For example, sending 100 bytes data per second is much better than sending 10 bytes every 100 milliseconds.<br>SPP uses credit based flow control. If the receiver can’t give the credit back to the sender as soon as possible, it can also slow down the throughput.<br>Unnecessary logs in the SPP callback functions.<br>The coexistence of BLE or Wi-Fi on ESP32.<br>Complex electromagnetic environment.</p></blockquote></blockquote><p>总结一下：<br>1.是PC端生成的虚拟串口波特率太低影响的速率吗，如果是的话应该如何更改PC端COM波特率呢？<br>打开蓝牙串口的波特率是协议栈内规定的，貌似没有给出修改接口，但是不影响带宽。蓝牙SPP基于RFCOMM，底层会尽可能多地传输数据，所以改带宽的关键不在波特率。<br>2.我之前开到一个解释：SPP协议的波特率不会影响通信速率，SPP协议层中也没有给出baudrate的配置选项，是因为底层通信不是基于波特率时钟吗？那通信时会有ACK吗？<br>有的。RFCOMM基于Scoket，有ACK。<br>3.在windows PC 与 ESP32 间进行约100kB&#x2F;s的无线数据传输，SPP可以实现吗？如果SPP无法实现，有其他的协议推荐吗？<br>大概能实现，看PC蓝牙的硬件及其是否有其他蓝牙设备，周围的2.4GHz频段有多少干扰。</p><p>SPP对蓝牙模块串口的读写实现通信，建立在串口仿真协议RFCOMM上实现；服务端和客户端对应为BluetoothServerSocket和BluetoothSocket，通过流进行数据传输，和java中的socket很像。<br>RFCOMM，它是蓝牙客户端和服务端的Socket通道，其目的为了解决如何在两个不同设备上的应用程序之间保证一条完整的通信路径，并在它们之间保持同一通信段的问题。设备配对后，还没有通信通道，BluetoothServerSocket监听RFCOMM，BluetoothSocket发起建立RFCOMM连接完成通信通道的建立。大致就像是下面这样：</p><p><img src="/img/ESP-SPP/RFCOMM.PNG" alt="RFCOMM"></p><p>什么是socket？<br>socket起源于Unix，而Unix&#x2F;Linux基本哲学之一就是“一切皆文件”，都可以用“open –&gt; write&#x2F;read –&gt; close”模式操作。Socket就是该模式的一个实现，是一种特殊的文件，一些socket函数就是对其进行的操作（读&#x2F;写IO、打开、关闭。<br>Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。其实socket也没有层的概念，它只是一个facade设计模式的应用，让编程变的更简单。是一个软件抽象层。</p><p><img src="/img/ESP-SPP/Socket.PNG" alt="socket"></p><p>Socket抽象层，会有请求-应答，也就是ACK。那这个ACK是总体传输开始时候的ACK呢，还是同步时钟用的ACK呢？这两个发送的速率是怎样的。如果没有每次包的同步ACK，那么应该有同步位检测，如果同步失败则返回错误ACK。在不同的线程调用同一个socket通道,会致错误产生.</p><p>所以如果要改PC端盖的蓝牙串口，重点是改RFCOMM服务。<br>RFCOMM通过L2CAP来处理单连接上的多路复用，并提供到多个设备的连接，从而提供多个并发连接。<br>RFCOMM数据速率将限制在涉及物理串行端口（类型2设备）的设备中。实现可以选择在虚拟串行端口（类型1设备中）上对数据进行调整。在允许范围内，RFCOMM将提供尽可能高的数据速率<br>什么是类型2？<br>RFCOMM支持两种类型的设备：<br>• 类型1–内部模拟串行端口（或等效端口）。<br>• 类型2–带物理串行端口的中间设备</p><p>PC是type1  PC没有把数据传给真实物理端口。通道打开后，如果持续一段时间（60s）没有数据传输，就会自动关闭通道。或者一方发送关闭通道的命令也行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>IOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【IOT开发】DEBUG_Mark</title>
    <link href="/2022/08/27/%E3%80%90IOT%E5%BC%80%E5%8F%91%E3%80%91DEBUG_Mark/"/>
    <url>/2022/08/27/%E3%80%90IOT%E5%BC%80%E5%8F%91%E3%80%91DEBUG_Mark/</url>
    
    <content type="html"><![CDATA[<h1 id="ESP32"><a href="#ESP32" class="headerlink" title="ESP32"></a>ESP32</h1><p>最近在使用ESP32开发一些无线应用，在经历重重困难能够顺DE利编译-下载工程后，尝试把STM32中的程序移植到ESP32中，但由于对FreeRTOS系统了解不够深入，所以遇到了很多导致板子一直Rebooting的bug，在此记录一下。</p><h2 id="1-消息队列溢出"><a href="#1-消息队列溢出" class="headerlink" title="1. 消息队列溢出"></a>1. 消息队列溢出</h2><p>在创建一个消息队列时需要给出队列长度，同时也需要相应的读取队列信息。如果入队过多没读完就满了，队列溢出则会导致系统重启。<br>所以在使用消息队列时注意消息写入与读取的对应关系。</p><h2 id="2-中断程序卡死-看门狗异常"><a href="#2-中断程序卡死-看门狗异常" class="headerlink" title="2. 中断程序卡死 看门狗异常"></a>2. 中断程序卡死 看门狗异常</h2><p>在程序中使用到了一个timer中断，刚写完发现一直重启，报错的原因是看门狗溢出，也就是高优先级线程卡死太久了。后来debug发现是卡死在timer中断内了。卡死的具体原因见我之前写的一个小总结：<a href="https://yiyangc18.github.io/2022/08/07/STM32%E4%B8%AD%E6%96%AD%E5%8D%A1%E6%AD%BB/">STM32-中断卡死</a><br>在ESP32-FreeRTOS系统中封装了太多层，直接去改中断标志位寄存器的值没有开放API，不过可以随意调用一个更改中断位的函数完成。<br>这点后来查阅官方文档，也有相应的说明：</p><blockquote><p>定时器启动后，可动态产生特定事件（如“警报事件”）。如需在事件发生时调用某些函数，请通过 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-reference/peripherals/gptimer.html#_CPPv432gptimer_register_event_callbacks16gptimer_handle_tPK25gptimer_event_callbacks_tPv">gptimer_register_event_callbacks()</a> 将函数挂载到中断服务例程 (ISR)。gptimer_event_callbacks_t::on_alarm 设置警报事件的回调函数。<font color=#FF0000 >由于此函数在 ISR 上下文中调用，必须确保该函数不会试图阻塞（例如，确保仅从函数内调用具有 ISR 后缀的 FreeRTOS API）</font>。函数原型在 gptimer_alarm_cb_t 中有所声明。&gt;<br>例如 xQueueSendFromISR、timer_group_get_counter_value_in_isr</p></blockquote><h2 id="3-printf重入"><a href="#3-printf重入" class="headerlink" title="3. printf重入"></a>3. printf重入</h2><p>由于之前写裸机程序习惯了，没想到有一天会因为printf卡死。<br>具体的场景是：中断A和B同时调用了printf，然后系统就很重启。printf不能在未返回的时候再次被调用。所以在中断中尽量不要用printf发送调试信息，应该改用ESP_LOG，日志输出。<br>详情见：<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-reference/system/log.html#c.ESP_LOGD">Logging library </a></p><p>大致就是以下几个API:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ESP_LOGE -<span class="hljs-built_in">error</span><br>ESP_LOGW -wornning<br>ESP_LOGI -information<br>ESP_LOGD -<span class="hljs-built_in">debug</span><br>ESP_LOGV -verbose<br></code></pre></td></tr></table></figure><h2 id="4-指针导致的内存错误"><a href="#4-指针导致的内存错误" class="headerlink" title="4. 指针导致的内存错误"></a>4. 指针导致的内存错误</h2><p>在程序中需要用到结构体指针、函数指针等稍微复杂一些的指针操作时，注意指向对象前先给对象分配内存空间，不然找不到地址就会报错重启。</p><h2 id="5-参数异常"><a href="#5-参数异常" class="headerlink" title="5. 参数异常"></a>5. 参数异常</h2><p>某些API参数设置没有保护或异常判断，输入参数溢出可能会导致错误。例如在设置定时器alarm周期时需要根据命令内容来设置，这时需要手动检测这个周期&gt;&#x3D;0，否则会导致重启。</p><h2 id="6-高频率任务超时"><a href="#6-高频率任务超时" class="headerlink" title="6. 高频率任务超时"></a>6. 高频率任务超时</h2><p>2022-9-22<br>今天又遇到了重启的bug，debug后发现是timer 回调函数中ESP_LOGI导致的。这玩意儿是可以重入的，但是timer的频率太高了，只有几十us，而执行一次ESP_LOGI的耗时会超过timer回调的周期，就会卡死重启。所以在高频率任务中注意任务耗时，尽量不要调用一些高耗时的API。<br>如果是很少启用的情况，例如几百次timer callback才会调用一次LOGI，可以使用 任务-消息队列-事件触发的逻辑 避免回调函数的重入error。</p><h2 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h2><p>2023-3-28</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">timer = x<span class="hljs-constructor">TimerCreate(<span class="hljs-string">&quot;timer&quot;</span>, <span class="hljs-params">pdMS_TO_TICKS</span>(TIMER_PERIOD_MS)</span>, pdTRUE, NULL, timer_callback);<br>x<span class="hljs-constructor">TimerStart(<span class="hljs-params">timer</span>, 0)</span>;<span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span>v<span class="hljs-constructor">TaskSuspendAll()</span>;  <span class="hljs-comment">// 暂停所有其他任务</span><br></code></pre></td></tr></table></figure><p>根据搜索结果，您可能遇到了ESP32和FreeRTOS的兼容性问题。一些用户报告说，使用vTaskSuspendAll()或者taskENTER_CRITICAL()等函数会导致看门狗定时器超时或者系统崩溃12。您可以尝试使用其他的同步机制，比如信号量或者互斥锁，来代替暂停其他任务的操作</p><h1 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h1><h2 id="中断退出"><a href="#中断退出" class="headerlink" title="中断退出"></a>中断退出</h2><p>在最近某个项目中，遇到了串口中断卡死主程序的问题，仔细debug后发现是没有读取接收缓存区buffer的原因。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">USART_ReceiveData(USART1);        <span class="hljs-comment">//读取一次数据，不然会一直进中断</span><br></code></pre></td></tr></table></figure><p>函数里面主要的语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(USARTx-&gt;DR &amp; (<span class="hljs-type">uint16_t</span>)<span class="hljs-number">0x01FF</span>); <span class="hljs-comment">//读取USARTx-&gt;DR</span><br></code></pre></td></tr></table></figure><p>USART1-&gt;DR是串口数据收发的缓存区寄存器。<br>串口中断标志位自动清空的前提是软件需要先读USART_SR寄存器，然后读USART_DR寄存器来自动清除。即串口中断事件发生后，如果使能的接收中断，而中断函数里面什么都不执行的话，接收中断标志位是无法自动清空的，故而，函数会一直卡在中断函数里面。</p><p>后来在定时器中断也遇到了类似的问题。由于任务需要，定时器需要根据串口命令更改不同的定时频率，但是在更改时如果只是在timer外部关闭定时器再重新initial，则程序会卡死 测试后发现是卡死在timer中断中。<br>timer关闭前一定要清空中中断标志，否则会在中断中出不来，所以中断timer再重启，需要的timer的中断中执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  <span class="hljs-comment">//清除TIMx的中断待处理位</span><br><span class="hljs-keyword">if</span>(IsTimerReset)<br>&#123;<br>    TIM_Cmd(TIM3, DISABLE);<br>    TIM3_Int_Init(IRQTimes,<span class="hljs-number">99</span>);<span class="hljs-comment">//重新启用</span><br>    IsTimerReset=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//printf(&quot;IsTimerReset=1,and timer is reset \r\n&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="STM32-掉电重启异常-bug"><a href="#STM32-掉电重启异常-bug" class="headerlink" title="STM32-掉电重启异常 bug"></a>STM32-掉电重启异常 bug</h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>基本相同的硬件原理图，上一版是好的，修改了 PCB 布局和走线后，新板子遇到了上电后无法工作的问题。</p><p>很诡异的 bug，烧录完程序一切正常，但是一掉电就无法工作了。</p><h3 id="排查过程："><a href="#排查过程：" class="headerlink" title="排查过程："></a>排查过程：</h3><p>1.怀疑 BOOT0 接触异常 或 Reset 电位异常 ，检查后发现 BOOT0 和 Reset 电位都是正常的。</p><p>2.使用 LED 电灯标准例程，上电发现没有效果。</p><p>3.检查晶振，发现少撸完成后晶振波形正常，复位后晶振波形不正常。尝试通过延长等待 HSE 启动成功的时间常数、直接使用内部 HSI 时钟，仍然无法掉电启动。</p><p>4.更改复位电路的充电电容。怀疑是复位电路时序不对，把 C23 换成了 10uF，仍然无法正常启动。</p><p><img src="C://Users//chery//chery-hexo//source//img/boxcnyEyuTG64D2uV6LrPo9Gfrh.png"></p><p>5.突发奇想使用前两天写的一个软件 Reset，发现软件 Reset 居然可以正常重新启动。</p><p>上位机的 reset 设置：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">serialPort1.RtsEnable <span class="hljs-operator">=</span> true<span class="hljs-comment">;</span><br>serialPort1.DtrEnable <span class="hljs-operator">=</span> false<span class="hljs-comment">;</span><br>Thread.Sleep(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>// RTS高电平，DTR低电平<br>serialPort1.RtsEnable <span class="hljs-operator">=</span> false<span class="hljs-comment">;</span><br>serialPort1.DtrEnable <span class="hljs-operator">=</span> true<span class="hljs-comment">;</span><br><br></code></pre></td></tr></table></figure><p>默认情况下 RTS DTR 都是高电平，用示波器测得的电位也是高电平。对比了一下自动下载电路的原理图，这个软件设置其实不会更改 BOOT0 和 EN 的电位，RTS 置高，DTR 无论高低，都是： BOOT0 低，EN 高，flash 启动状态。</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>把 RTS 引脚飞线到 3V3 或者把 DTR 飞线到 GND。</p><p>上位机命令把 DTR 控制成低电平后可以重启，然后飞线物理控制也可以重启，但是 DTR 高电平输出直接接地会短路，所以尝试把 RTS 飞高电平，发现也能够顺利重启。</p><p>注意 RTS 物理控制高电平时候不能进入串口下载模式，所以得用 SW 下载或者下载完程序再飞线。</p><p>虽然问题是靠运气解决的，可以尝试从结果排查原因：</p><p>飞线前后 RTS DTR 都是高电平，EN 和 BOOT0 的电位都正常，但是无法从 flash 启动，飞线后可以正常启动，用软件控制 RTS 高电平也可以。</p><p>板子的状态就像是单片机的 RST 引脚一直是拉低的，没有跑任何程序。怀疑是某些原因导致驱动能力不够，但是软件设置 RTS 或 DTR 的电平后又可以启动。检查了自动下载电路和复位电路的走线，发现没有过孔，走线也不长。。</p><p>各个引脚电位都正常，EN DTR RTS 都是 3V3，BOOT0 为 0 。</p><p>把 RTS 引脚和 3V3 接一下，就能够启动点亮 LED，从现象判断是拉高了 EN。所以之前的现象是 EN 高了（3V3），但没完全高。所以用杜邦线短接 EN 和 3V3，按 reset 可以正常启动。</p><p>把 BOOT0 和 GND 短接，按 reset 也可以正常启动。问题在自动下载电路上。虽然电位都是正常的，但可能是三极管驱动能力不够，电流太小没能正确驱动 EN 单片机内相应的模块开关？</p><p>把自动下载电路的两个三极管拆了，发现可以上电正常启动了。从电路原理图还是看不出什么问题，上面的解释也不是很能让自己认可。</p><p>感觉总结不出原因，目前知识储备还不够，大概率还是归咎于玄学，之后如果能解答了会来补充。</p><p>参考：</p><p><a href="https://blog.csdn.net/shx_2613/article/details/124022153">https://blog.csdn.net/shx_2613&#x2F;article&#x2F;details&#x2F;124022153</a></p><p><a href="https://community.st.com/s/question/0D53W00000V2YuwSAF/stm32g0-not-works-after-reset">https://community.st.com/s/question/0D53W00000V2YuwSAF/stm32g0-not-works-after-reset</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>IOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【文献学习】热电偶信号调理电路、IOT接入和处理算法</title>
    <link href="/2022/08/10/%E3%80%90%E6%96%87%E7%8C%AE%E5%AD%A6%E4%B9%A0%E3%80%91%E7%83%AD%E7%94%B5%E5%81%B6%E4%BF%A1%E5%8F%B7%E8%B0%83%E7%90%86%E7%94%B5%E8%B7%AF%E3%80%81IOT%E6%8E%A5%E5%85%A5%E5%92%8C%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/"/>
    <url>/2022/08/10/%E3%80%90%E6%96%87%E7%8C%AE%E5%AD%A6%E4%B9%A0%E3%80%91%E7%83%AD%E7%94%B5%E5%81%B6%E4%BF%A1%E5%8F%B7%E8%B0%83%E7%90%86%E7%94%B5%E8%B7%AF%E3%80%81IOT%E6%8E%A5%E5%85%A5%E5%92%8C%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>2021.10 ~ 12 参与了一个高温高精度测温项目，任务是做一个高精度高温传感器配套测试系统。在此记录一些文献的学习笔记与参考。仅做记录总结，转载注明出处。</p><h1 id="热电偶信号调理、IOT接入"><a href="#热电偶信号调理、IOT接入" class="headerlink" title="热电偶信号调理、IOT接入"></a>热电偶信号调理、IOT接入</h1><h2 id="1-基础知识复习"><a href="#1-基础知识复习" class="headerlink" title="1.基础知识复习"></a>1.基础知识复习</h2><p>热电偶传感器利用热电效应来进行工作的, 其热电势率一般为几十到几μV&#x2F;0℃。它直接和被测对象接触, 不受中间介质的影响, 因而测量精度高, 并且可以在-200 ~ 1600℃范围内进行连续测量。<br><img src="https://img-blog.csdnimg.cn/d303dd18a9d34b549da81a594d2050b2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pep552h5pep6LW355qEQ0hFUlk=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="热电偶测温方法"><br>理论上，热电偶是冷端以0℃(或者0K，看E（T，0）计算式的单位)为标准进行测量的。然而，通常测量时仪表是处于室温之下的，但由于冷端不为0℃，造成了热电势差减小，使测量不准，出现误差。因此为减少误差所做的补偿措施就是冷端温度补偿。</p><p>通常会采用一些措施来消除冷端温度变化所产生的影响，如冷端恒温法、冷端温度校正法、补偿导线法、补偿电桥法。</p><ul><li>（1）冷端恒温法</li></ul><p>冷端恒温法就不说了，把冷端泡在冰水混合物里，不经济，难实现。</p><ul><li>（2）冷端温度校正法</li></ul><p>由于热电偶的温度分度表是在冷端温度保持在0℃的情况下得到的，与它配套使用的测量电路或显示仪表又是根据这一关系曲线进行刻度的，因此冷端温度不等于0℃时，就需对仪表指示值加以修正。如冷端温度高于0℃，但恒定于t0℃,则测得的热电势要小于该热电偶的分度值，为求得真实温度，可利用中间温度法则，即用下式进行修正：</p><p><code>E（t,0）= E（t,t1）+ E（t1,0）</code></p><p>这里用到了一个热电偶重要的定律：中间温度定理，定义内容就是上面的式子。</p><p>3）补偿导线法</p><p>由于热电偶的材料一般都比较贵 (特别是采用贵金属时)，而测温点到仪表的距离都很远，为了节省热电偶材料，降低成本，通常采用补偿导线（compensating lead）把热电偶的冷端 (自由端)延伸到温度比较稳定的控制室内，连接到仪表端子上。这是一种专用导线，有正、负极性。选择某一对导线，当其与某种热电偶的热电特性小于100℃的范围里一致时，只要热电偶冷端小于100℃，并将它与热电偶冷端连结，则相当于将热电偶延长，这样便于热电偶的冷端温度处理，如果所移的冷端仍处于温度较高或有波动的地方，则此时的补偿导线就失去使用意义。</p><p>电桥补偿法其实就是冷端温度矫正的一种方法， 除此之外还有通过其他方式矫正的，这个会在下篇文献学习中详细描述。</p><h2 id="2、基础信号调理电路"><a href="#2、基础信号调理电路" class="headerlink" title="2、基础信号调理电路"></a>2、基础信号调理电路</h2><p>首先想到的就是某门课讲过的一种调理电路：<br><img src="https://img-blog.csdnimg.cn/c4219122cf184415a482fd2081c657f9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pep552h5pep6LW355qEQ0hFUlk=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="基础调理电路"><br>总结一下：偏置、滤波、放大。</p><p>这里冷端补偿的方式是外接温度传感器AD590，在AD转换输入单片机，软件部分进行冷端补偿。</p><p>书上就一电路图，没有分析过程，所以参数设计过程遇到了困难。<br><img src="https://img-blog.csdnimg.cn/28e28aabb49c4721a82cf38f2ca22b35.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pep552h5pep6LW355qEQ0hFUlk=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="电路仿真"><br>在调试仿真后发现，更改上拉电阻R1，可以改变偏置，如果上拉电阻小是反偏，电阻大是正偏置。上拉电阻一般要比后面的滤波器电阻大几个量级；上拉电阻过小会导致反偏的厉害，在输出后级再加反相器也能起到调偏置的目的，但是多个有源器件引入噪声。 选择上拉电阻大三个量级，滤波器电阻5.1k，正向偏置400mV左右，在输入信号为正时可以保证正偏；在输入信号为0时输出恒定偏置值，再通过运放offset调整。<br>原电路加偏置是为了适应运放单电源供电的工作状态，在仿真后偏置效果不太能保证，所示在PCB中加了分压电路，为运放双端供电，分压中间点位模拟地，接入板子公共地。</p><p>调整R5对输出幅值改变明显；信号截止频率通过调整电容来改变。分压电阻后面的无源滤波器，滤波截止频率主要又电容确定，大电容滤低频，图示值能滤除工频干扰。  </p><p>调整OP系列运放的OFFSET端电压能有效改善零输入失调电压，调整范围在100mA左右。</p><h2 id="3、其他相关信号调理"><a href="#3、其他相关信号调理" class="headerlink" title="3、其他相关信号调理"></a>3、其他相关信号调理</h2><p>在买的读数头（温度配送器）中，大多有一个转4-20mA输出的功能，之前也有很多传感器调理电路需要这类输出，但没深究为什么。在百度查了一些相关文章，电子发烧友一篇文章写的很好：</p><blockquote><p>采用电流信号的原因是不容易受干扰，因为工业现场的噪声电压的幅度可能达到数V，但是噪声的功率很弱，所以噪声电流通常小于nA级别，因此给4－20mA传输带来的误差非常小；电流源内阻趋于无穷大，导线电阻串联在回路中不影响精度，因此在普通双绞线上可以传输数百米；由于电流源的大内阻和恒流输出，在接收端我们只需放置一个250欧姆到地的电阻就可以获得0－5V的电压，低输入阻抗的接收器的好处是nA级的输入电流噪声只产生非常微弱的电压噪声<br>上限取20mA是因为防爆的要求：20mA的电流通断引起的火花能量不足以引燃瓦斯。下限没有取0mA的原因是为了能检测断线：正常工作时不会低于4mA，当传输线因故障断路，环路电流降为0。常取2mA作为断线报警值。电流型变送器将物理量转换成4 - 20mA电流输出，必然要有外电源为其供电。最典型的是变送器需要两根电源线，加上两根电流输出线，总共要接4根线，称之为四线制变送器。当然，电流输出可以与电源公用一根线（公用VCC或者GND），可节省一根线，所以现在基本上将四线制变送器称之为三线制变送器。其实大家可能注意到， 4-20mA电流本身就可以为变送器供电，变送器在电路中相当于一个特殊的负载，这种变送器只需外接2根线，因而被称为两线制变送器。<br>4-20mA.DC（1-5V.DC）信号制是国际电工委员会（IEC）：过程控制系统用模拟信号标准。我国从DDZ-Ⅲ型电动仪表开始采用这一国际标准信号制，仪表传输信号采用4 ~ 20mA.DC，联络信号采用1 ~ 5V.DC，即采用电流传输、电压接收的信号系统。</p></blockquote><p> 所以在第一版电路板上加入了V-A转换与A-V转换，以适应长距离传输情况，具体转换电路百度随便查一下，有很多。</p><h2 id="4、软件设计基础"><a href="#4、软件设计基础" class="headerlink" title="4、软件设计基础"></a>4、软件设计基础</h2><p>设计配套测试系统，重点部分在数据处理方式，这部分在下篇讲解。在此记录几篇有关信号安全传输、IOT系统接入和UI界面设计的文章：</p><p>[1]Chang, V., Martin, C., 2021. An industrial IoT sensor system for high-temperature measurement. Computers &amp; Electrical Engineering 95, 107439.. doi:10.1016&#x2F;j.compeleceng.2021.107439</p><p>[2]T. Xu, J. B. Wendt and M. Potkonjak, “Security of IoT systems: Design challenges and opportunities,” 2014 IEEE&#x2F;ACM International Conference on Computer-Aided Design (ICCAD), 2014, pp. 417-423, doi: 10.1109&#x2F;ICCAD.2014.7001385.</p><p>[3]K. Yordanov, P. Zlateva, I. Hadzhidimov and A. Stoyanova, “Testing and clearing the high temperature module error from 0 to 1250°C for measurement with 16 K-type thermocouples,” 2018 20th International Symposium on Electrical Apparatus and Technologies (SIELA), 2018, pp. 1-4, doi: 10.1109&#x2F;SIELA.2018.8447096.</p><p>文献[1]和[3]都做了测温系统，都用了：单片机、热电偶、无线通讯（蓝牙orWifi），总结一下就是使用物联网思维的分布式测控系统。主要学习其分布式系统的设计思路。</p><p>文献[1]的主要亮点是可分布式采集的数据存储、传输都体现了物联网思维，方便接入其他物联网系统，可拓展性强。</p><p>文献[3]则是用了在一个模块内集成了多个热电偶的方式，“用空间换精度”，具体实现的数学推导没太看懂，不过大体思路就是多点采集，剔除异常值，取有效数据均值以降低随机误差。</p><p>文献[2]主要讲了在物联网系统信号传输的主要方式中，如何做好数据加密，具体加密过程涉及到一些密码学的知识，不过其中一条简单的处理思路很受用：在配对再验证成功后传输数据，否则数据存储在安全的本地存储介质或上。还可以加入一个实时匹配检测程序，当物联网设备使用某种形式的通信技术连接到其他未验证渠道时，执行故障安全程序，例如，中断通讯或者启用报警程序。正好用电开发板有接入SD卡，在实现测试系统基础功能后，可以考虑加入这个安全保护措施。</p><p>在两篇关于多点分布测控的文章中，都提到了异常值判断的问题，目前做的项目如果采样频率足够高，可以迁移到时域多点异常值去除，当然，即使采样频率不太够这个过程也是很必要的。</p><p>基于之前的误差理论知识，剔除异常值有3σ原则、Grubbs检验法、回归分析判断等，文献中使用的方法是四分位距法，这个方法在商务数据分析课程中讲过，但只用了函数库，具体过程没自己做过。</p><p>学习了一下，具体的判断过程：按顺序取最后二十个温度读数，并将它们分成三个四分位数。四分位数一（Q1）是数据集前半部分的中位数，四分位数二 （Q2） 是整体集的中位数，四分位数三 （Q3） 是集后半部分的中位数。Q3-Q1计算四分位数Q4范围。最后，四分位数范围乘一个恒定值（这个值取决于你想要多大的有效数据范围）得到IQR(Interquartile Range)，然后有效数据的下限和上限就是[Q1−IQR,Q3+IQR]。如果当前温度低于下界或大于上界，则是一个异常值，给与剔除。</p><p>恒定值乘数的设置需要经过试验和错误测试。总体而言，使用四分位数范围的策略在消除可能的离群值方面更为有效，因为边界可以根据给出的数据集动态变化，而不是硬编码到特定值，这种动态变化允许更精确的检测。</p><p>此外，在设计软件系统功能时，想给出实时的测量精度，并通过串口进行系统误差的校正，在计算精度时需要实时计算标准不确定度，这个参数在进行3σ检验、Grubbs检验时可以直接拿来用，检验的时间复杂度会比用四分位法低，而且这种检验方法在误差理论中是普遍认可的。</p><p>简而言之，如果测试系统在进行实时精密度计算的情况下采样频率满足上升时间要求，则可以使用Grubbs检验异常值，否则不进行精密度实时计算，使用四分位法检验异常值。</p><p>最后，给出两篇在知网找到看着还行的文献：</p><p>[1]常广晖,常书平,张亚超.高精度热电偶测温电路设计与分析[J].计算机测量与控制,2021,29(03):67-71.</p><p>[2]张海涛,罗珊,郭涛.热电偶冷端补偿改进研究[J].仪表技术与传感器,2011(07):11-14.</p><p>这两篇文献的内容可以分别用一句话概括：[1]作者用最小二乘法拟合了热电偶温度计算函数t(E),比分段线性法和插值法精度高（存疑，这应该是在插值表密度低的情况下）复杂度还低。[2]作者把冷端补偿电路和热电偶测量电路分开了，因为合在一起不经有补偿电路本身精度影响，还有补偿的线性与热电偶非线性输出间不匹配造成的误差。</p><p>这两篇文章最大的作用就是在写一些材料时可以参考其中一些段落，作为众所周知……另外也看了一些其他知网的有关热电偶测温的文章，大多没啥参考价值。以以往在知网查文献的经验，知网最有价值的文章就是各大院校的学位论文，可能最简单的方法就是找做相关课题的学位论文然后参考着做。</p><h1 id="【文献学习】热电偶信号调理电路"><a href="#【文献学习】热电偶信号调理电路" class="headerlink" title="【文献学习】热电偶信号调理电路"></a>【文献学习】热电偶信号调理电路</h1><p>这篇笔记主要是记录一些文献中，热电偶温度测试系统相关的信号调理电路以及数据处理方式，并稍作总结，在之后做一些测试工作，归并改进，以对初步设计的系统进行升级迭代。</p><h2 id="1-用电压—频率转换的方法处理热电偶信号"><a href="#1-用电压—频率转换的方法处理热电偶信号" class="headerlink" title="1.用电压—频率转换的方法处理热电偶信号"></a>1.用电压—频率转换的方法处理热电偶信号</h2><p>Murmu, A., Bhattacharyya, B., Munshi, S., 2018. A synergy of voltage-to-frequency converter and continued-fraction algorithm for processing thermocouple signals. Measurement 116, 514–522.. doi:10.1016&#x2F;j.measurement.2017.11.047</p><p>文献主要的亮点是用了Vtof 电压频率转换电路处理热电偶信号，用 continued-fraction algorithm 连续分数算法在MCU中做信号处理。较之后面的其他文献，实现的精度不是特别高，但胜在简单可靠，没有复杂的硬件设计，实现过程也易于理解。</p><p>电路用了 负温度系数的热敏电阻，接入LM311的8引脚进行冷端温度补偿，再把带有补偿、热电偶输出的信息的方波输入MCU。</p><p>电路图：<br><img src="https://img-blog.csdnimg.cn/ccbaf9f1b00a44c0808ac98f7707de60.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pep552h5pep6LW355qEQ0hFUlk=,size_14,color_FFFFFF,t_70,g_se,x_16" alt="v-f电路"></p><p>电路首先使用三个OP07组成的差分放大器，按照虚短虚断推算，放大倍数为R1&#x2F;R2,放大后经过一个RC低通滤波滤除工频干扰，然后通过高精度电压频率转换器LM311转换成一定频率的脉冲序列。</p><p>输出方波频率与输入电压的关系：<img src="https://img-blog.csdnimg.cn/c3c9eaf126f4476689672a55d13c4c53.png" alt="eq1"><br>约束条件<img src="https://img-blog.csdnimg.cn/7a9bc4c5a7f4437cad355bafa50f7497.png" alt="eq2">使得LM311引脚 67 的时间常数匹配<br>而参考节点的电阻由方波的上升时间τ决定：<img src="https://img-blog.csdnimg.cn/ee0a67b8db3143a5a0b5f4db1a3309b4.png" alt="eq3"><br>再之后，把vout通过采集卡输入进处理器后，就可以由信号的上升时间、频率获得热电偶所测温度了。文献中使用PC声卡采集信号，因为要求输入信号有效值不超过1V所以进行了分压、去耦处理，然后分别使用上升沿触发、下降沿触发得到两个脉冲序列，从而获得τ与f。</p><p>在大多数实现线性化输出的技术，多是基于只读存储器 (ROM) 的查找表(LUT) 方法和涉及分段线性或多项式插值的软件方法。基于硬件的线性化方案，特别是模拟线性化电路很少。这是一个很不错的参考电路。<br>作者在恒温油箱中的测试结果：<br><img src="https://img-blog.csdnimg.cn/268e2cb0472d4de794767c3c1159f21a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pep552h5pep6LW355qEQ0hFUlk=,size_15,color_FFFFFF,t_70,g_se,x_16" alt="testresult1"><img src="https://img-blog.csdnimg.cn/c236f71410bb4eaa917cea5af8a37af1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pep552h5pep6LW355qEQ0hFUlk=,size_8,color_FFFFFF,t_70,g_se,x_16" alt="testresult2"></p><h2 id="2-双输入对数运算放大器处理，用模电提高线性化"><a href="#2-双输入对数运算放大器处理，用模电提高线性化" class="headerlink" title="2.双输入对数运算放大器处理，用模电提高线性化"></a>2.双输入对数运算放大器处理，用模电提高线性化</h2><p>A. Mukherjee, D. Sarkar, A. Sen, D. Dey and S. Munshi, “An analog signal conditioning circuit for thermocouple temperature sensor employing thermistor for cold junction compensation,” 2013 International Conference on Control, Automation, Robotics and Embedded Systems (CARE), 2013, pp. 1-5, doi: 10.1109&#x2F;CARE.2013.6733711.<br>先看电路图：<br><img src="https://img-blog.csdnimg.cn/4f4b5117f2754bf88c131ca2cb65db79.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pep552h5pep6LW355qEQ0hFUlk=,size_6,color_FFFFFF,t_70,g_se,x_16" alt="circuit-logamp"><br>冷端补偿：<img src="https://img-blog.csdnimg.cn/24dcdcc2896241b49ea79687e31932d7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pep552h5pep6LW355qEQ0hFUlk=,size_19,color_FFFFFF,t_70,g_se,x_16" alt="circuit-logamp"></p><p>上面的三运放放大网络的分析没太看懂，但这个作者设计这个电路的初衷是通过模拟电路的方式使得热电偶的输出信号能更具线性度，用这总方式可以实现不用MCU，仅仅通过模拟电路与基础ADC、译码器和显示电路就能完成温度读取。但在我所做的系统中并不想考虑这种方案，因为运放太多了，较多的有源器件会映入更多的噪声，也对电路测试调整带来了很大的困难，而且较之调研的这些方案我觉得我的软件设计能够成为一个亮点。</p><p>简而言之就这个电路比较复杂了，有一定的参考价值，但不值得做复现或者改良。</p><p>作者通过SPICE仿真验证了在非线性输入与温度补偿，从其他文献以及热敏电阻数据手册获得模拟参数，仿真结果   标准偏差在0.32°C 到 0.76°C   ，用实物做的话肯定达不到这个精度。</p><h2 id="3-用反向插值表or函数处理热电偶信号"><a href="#3-用反向插值表or函数处理热电偶信号" class="headerlink" title="3.用反向插值表or函数处理热电偶信号"></a>3.用反向插值表or函数处理热电偶信号</h2><p>L. Ximin, “A Linear Thermocouple Temperature Meter Based on Inverse Reference Function,” 2010 International Conference on Intelligent Computation Technology and Automation, 2010, pp. 138-143, doi: 10.1109&#x2F;ICICTA.2010.284.</p><p>这个处理电路使用了AD590读取冷端温度，AD转换输入单片机做数据处理与结果显示。</p><p>电路示意图：<br><img src="https://img-blog.csdnimg.cn/df89cb107d654a209b547c27a31c7692.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pep552h5pep6LW355qEQ0hFUlk=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="circuit2-complex"><br>这个实现比上一个还要复杂，其中冷端补偿的方式也是独具一格：用多路复用放大电路，对热电偶、校准电阻输出信号（U1~U5）进行一定的数学运算从而运算确定0℃电压值，进行零点校准的同时也完成了冷端补偿。这个思路很有特点，但是仔细一想，根本不用做的这么复杂。零点校准完全可以放到MCU里面来做，换一个运算速度更高的处理器，比实现这个复杂电路省钱还省力。</p><p>这里用AD590做冷端温度补偿，这个温度传感器在许多教程、课程中都有例举，但查了一下，典型的旧时代外国产品，又贵精度还低，完全是吃了老教材、教程的红利（个人观点），而且我设计的初步方案也有考虑用这个传感器，但是进行传感器调研选型后连买来试一下的想法都没有。</p><p>做输出计算，一般是根据标准参考函数或反向参考函数计算温度值。这样可以获得准确和线性的测量。但是，通过微处理器计算的函数比较低效，并且对实时测量有很大的影响。在这篇文献中，作者研究了标准参考表的方法，其不仅可以实现按标准参考功能进行温度测量，而且可以节省大量的计算时间，保证实时测量的准确性。与搜索标准参考表的方法相比，反向参考表的查找方法以热电动力经过简单运算为表地址，节省搜索时间，简化程序，也在一定程度上提高了实时性。</p><p>首先复习一下单片机中热电偶信号最简单的处理方法：首先通过冷端温度to  查表找到对应热电势Et，然后加上热电偶输出E2，得到所需要的E(t)  。中间温度定理，上节笔记有提到。</p><p>这里作者做了一件我认为非常有参考意义的事：他对比了多项式拟合法和参考函数表查找法的精度匹配情况：<br><img src="https://img-blog.csdnimg.cn/b841c803c2624f52b9f91f7327f38df0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pep552h5pep6LW355qEQ0hFUlk=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="index-table"><br>计算后发现，对数据进行九阶拟合的精度</p><p>对比：  0 ~ 50℃的参考表E ( t )  51个数据</p><p>-200 ~ 1372℃的反参考表t ( E )  2026个数据  </p><p>这两个表的查询、插值精度是和多项式拟合计算的结果相差不大的（甚至表做的数据够多，间隔等于Et分辨率时都不用插值）</p><p>这里作者做的反向差值表 ，温度区间根据测量不同决定，把计算得的热电动力E(t) 除以反向参考表的间隔（文中是30uV），商数乘以 2 作为查找表的地址，可以直接获得温度测量。根据存储空间的大小，对逆参考函数表t [ E (  t , 0 ) ]进行尽可能的扩展，以获得尽可能高的测量精度。</p><p>而在MCU中计算一个九阶多项式，花的时间是非常多的，使用ROM存储查询表，地址搜搜查找的方式， 明显后者复杂度更低。这是一种用静态内存换取运算速度的方式，考虑到我目前使用的STM32 512Kb内存，存三五千个数据的查询表完全够用（虽然这会对后面接入微处理器操作系统造成一定影响，不过开发板带了SD卡，大不了存SD卡，用的时候放到闪存里面），我会在后续的系统迭代中使用这个数据处理的方法。</p><p>此外，这个通过热电势的值简单运算得到查找表地址的思路，和有序向量插值查找的思路十分相似，甚至可以说如出一辙。而文献中的这种查找方式有很大的局限性：它必须要求查找表按照Et等间隔、在测量范围内全部有序的给出，这导致，如果想要提高查询表密度以提高精确的，就得全面地提高查找表的密度，占用更大的静态内存。虽然提高密度不过是在生产查询表的程序中改一个参数而已，不过占用内存总归不大方便。基于此，我准备利用有序向量插值查找的思路，对这个查找方法进行改写，实现在loglogn的时间复杂度内（这是非常低的了）实现Et到t 的查询、插值，且不必要求查询表等间隔分布，可以在重点测温范围内大密度做表，在其他地方小密度做表。</p><p>##4.基于递归B样条最小二乘的方法给出拟合函数<br>Guo Wei, Xin Wang and Jinwei Sun, “Signal processing method with cold junction compensation for thermocouple,” 2009 IEEE Instrumentation and Measurement Technology Conference, 2009, pp. 1458-1462, doi: 10.1109&#x2F;IMTC.2009.5168685.</p><p>作者用一种基于递归B样条最小二乘的方法作为解决方案 ，生产两个计算模型E(t) 、 t(E) ，来消除冷端干扰并计算热电偶热电势到温度转换。</p><p>采用 B 样条最小二乘法是因为它的近似质量很好。递归方法用于简化操作并使其适合在MCU中使用，所以就可以实时的在MCU中进行模型的校准（热电偶使用久了，要是不是校准标定），而其他的计算模型，无论是最小回归、查询表法，都得测得数据后在计算机中建立计算模型。这点是这篇文章所用方法的最大两点。</p><p>测试结果：</p><p>S型相对误差为0.45%，K型为0.29%  。作者仅使用热电偶标准表的模拟研究 ，但是没做实物。</p><p>再提一嘴，这些文章提到所做测试系统的精度时，用的标准都没有统一。这篇文章给的参数是最大相对误差和平均相对误差（做异常值判断了吗，给的是平均值与参考值的相对误差的话，需要给出测试点数啊），而其他文章有的给精度Accuracy（给精度要给置信区间啊），有的给绝对误差，有的给均方根误差（这个好），这对各方案的精度横向对比造成了很大的困难。</p><p>之后我写的各种报告，精度确定规范尽量按照国际计量标准来。</p><h1 id="【信号处理】一种热电偶信号处理算法"><a href="#【信号处理】一种热电偶信号处理算法" class="headerlink" title="【信号处理】一种热电偶信号处理算法"></a>【信号处理】一种热电偶信号处理算法</h1><p>热电偶信号处理，无非两种方法：<br>插值法：插值表密度决定精度；复杂度集中在搜索插值点<br>拟合法：数据密度和拟合方式决定精度；复杂计算耗时大；实现更容易</p><p>因为在所设计系统应用中，需要更新插值表，而再导出到PC软件中做拟合，太麻烦（在MCU中实现的拟合也有，例如之前文献学习提到的基于递归B样条最小二乘的方法给出拟合函数，但在单片机里写还是太难了），所以考虑用插值方法。</p><p>插值方法时间复杂度主要集中在插值地址搜索，在之前学习的文献中有一种方法：分度表等间隔分布，通过热电势的值简单运算得到查找表地址的思路；这和有序向量插值查找的思路十分相似。</p><p>L. Ximin, “A Linear Thermocouple Temperature Meter Based on Inverse Reference Function,” 2010 International Conference on Intelligent Computation Technology and Automation, 2010, pp. 138-143, doi: 10.1109&#x2F;ICICTA.2010.284.</p><p>而文献中的这种查找方式有很大的局限性：它必须要求查找表按照Et等间隔、在测量范围内全部有序的给出，这导致，如果想要提高查询表密度以提高精确的，就得全面地提高查找表的密度，占用更大的静态内存，而且需要E-t，t-E两个表。</p><p>基于此，我准备利用有序向量插值查找的思路，对这个查找方法进行改写，实现在loglogn的时间复杂度内实现Et到t 的查询、插值，且不必要求查询表等间隔分布，可以在重点测温范围内大密度做表，在其他地方小密度做表:</p><p>用MATLAB实现，因为之后可能要配合Simulink做模拟电路、数字数据处理的联合仿真：</p><p>先自己写一个插值函数，之后移植到单片机需要改写成C语言：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs m">function [index,Tout] <span class="hljs-built_in">=</span> insert_search(indextable_T,indextable_V,Vin)<br>    Vsearch<span class="hljs-built_in">=</span>Vin-indextable_V(<span class="hljs-number">1</span>);<br>    id1<span class="hljs-built_in">=</span>Vsearch/(indextable_V(end)-indextable_V(<span class="hljs-number">1</span>))*length(indextable_T);<br>    index<span class="hljs-built_in">=</span>fix(id1);<br>    <span class="hljs-built_in">if</span> index<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">0</span><br>    stepT<span class="hljs-built_in">=</span>(indextable_T(<span class="hljs-number">2</span>)-indextable_T(<span class="hljs-number">1</span>));<br>    stepV<span class="hljs-built_in">=</span>(Vin-indextable_V(<span class="hljs-number">1</span>))/(indextable_V(<span class="hljs-number">2</span>)-indextable_V(<span class="hljs-number">1</span>));<br>    Tout<span class="hljs-built_in">=</span>indextable_T(<span class="hljs-number">1</span>)+stepT*stepV;<br>    return<br>    end<br>    while Vin&lt;indextable_V(index)||Vin&gt;indextable_V(index+<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">if</span> Vin&lt;indextable_V(index)<br>        Vsearch<span class="hljs-built_in">=</span>Vin-indextable_V(<span class="hljs-number">1</span>);<br>        id1<span class="hljs-built_in">=</span>Vsearch/(indextable_V(index)-indextable_V(<span class="hljs-number">1</span>))*index;<br>        index<span class="hljs-built_in">=</span>fix(id1);<br>        elseif Vin&gt;indextable_V(index+<span class="hljs-number">1</span>)<br>        Vsearch<span class="hljs-built_in">=</span>Vin-indextable_V(index);<br>        id1<span class="hljs-built_in">=</span>Vsearch/(indextable_V(end)-indextable_V(index))*(length(indextable_T)-index);<br>        index<span class="hljs-built_in">=</span>index+fix(id1);<br>        end<br>    end<br>    stepT<span class="hljs-built_in">=</span>(indextable_T(index+<span class="hljs-number">1</span>)-indextable_T(index));<br>    stepV<span class="hljs-built_in">=</span>(Vin-indextable_V(index))/(indextable_V(index+<span class="hljs-number">1</span>)-indextable_V(index));<br>    Tout<span class="hljs-built_in">=</span>indextable_T(index)+stepT*stepV;<br> <br>end<br></code></pre></td></tr></table></figure><p>这里用到的插值搜索的思想：<br><img src="https://img-blog.csdnimg.cn/121c67f9294b47498944d3ce9d395025.png" alt="insert-find"></p><p> 插值得到大概的index，再判断Vin是不是在Vsearch[index，index+1]内，是的话直接线性插值，不是的话再判断是大了还是小了进入[index,end]或者[1,index]递归处理</p><p>考虑到所做系统对快速性的需求，所以改写算法的时候把最初的递归改成了while循环迭代，减小了函数栈开销。</p><p>测试程序：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs m">clear; clc; close <span class="hljs-built_in">all</span><br> <br>indextable_T <span class="hljs-built_in">=</span> xlsread(<span class="hljs-string">&#x27;K型热电偶分度表.xls&#x27;</span>,<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;A3:A143&#x27;</span>); <span class="hljs-comment">%in ℃</span><br>indextable_V <span class="hljs-built_in">=</span> xlsread(<span class="hljs-string">&#x27;K型热电偶分度表.xls&#x27;</span>,<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;B3:B143&#x27;</span>); <span class="hljs-comment">%分度表数据导入,in mV</span><br> <br>V_in<span class="hljs-built_in">=</span>input(<span class="hljs-string">&#x27;模拟热电偶输出电压 -0.392~51.82: &#x27;</span>);<br>T_in<span class="hljs-built_in">=</span>input(<span class="hljs-string">&#x27;模拟冷端补偿温度 -0~1370: &#x27;</span>);<br>[indexT,Tout] <span class="hljs-built_in">=</span> insert_search(indextable_T,indextable_V,V_in)<br>[indexV,Vout] <span class="hljs-built_in">=</span> insert_search(indextable_V,indextable_T,T_in)<br> <br>V_tc<span class="hljs-built_in">=</span>(indextable_V(<span class="hljs-number">1</span>):<span class="hljs-number">0.1</span>:indextable_V(end));<br>T_tc<span class="hljs-built_in">=</span>(<span class="hljs-number">1</span>:length(V_tc));<br>for i<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:length(V_tc)<br>    [~,Ttc_now]<span class="hljs-built_in">=</span>insert_search(indextable_T,indextable_V,V_tc(i));<br>    T_tc(i)<span class="hljs-built_in">=</span>Ttc_now;<br>end<br></code></pre></td></tr></table></figure><p>如果输入定值的V_in或者T_in,可以看到大多数时候2~4次搜索就可以找到地址了，这个效率是非常高的。</p><p>再检查输出更高密度V_tc分度表，看上去没什么大问题</p><p> V_tc(256) &#x3D; 25.5000</p><p> T_tc(256) &#x3D; 614</p><p>观察原分布表，输出值比较合理</p><h2 id="异常值处理和分度表更新"><a href="#异常值处理和分度表更新" class="headerlink" title="异常值处理和分度表更新"></a>异常值处理和分度表更新</h2><p>异常值处理会的有以下方法：</p><p>3σ检验、Grubbs检验法：  这需要实时计算标准不确定度，之前写在STM32里的不确定度计算函数，由于sqrt函数实现的不够好，总体效果不是很满意，而且单片机里面 u8 char，u32 int  float 和ADC转换的二进制数  相互运算、处理，总不知道哪一步是没转换还是怎么的，例如：</p><p>从温度传感器DS1820读取的一字节二进制数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">DS18B20_Read_Byte()<br>&#123;<br>    u8 data;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">8</span>;i++) <br>        &#123;<br>            j=DS18B20_Read_Bit();<br>            data=(j&lt;&lt;<span class="hljs-number">7</span>)|(dat&gt;&gt;<span class="hljs-number">1</span>);<br>        &#125;<br>    <span class="hljs-keyword">return</span> data<br>&#125;<br><br>u8 temp,TL,TH;<br>TL=DS18B20_Read_Byte(); <span class="hljs-comment">// LSB   </span><br>TH=DS18B20_Read_Byte(); <span class="hljs-comment">// MSB  </span><br>                    <br>tem=TH; <span class="hljs-comment">//获得高八位</span><br>tem&lt;&lt;=<span class="hljs-number">8</span>;    <br>tem+=TL;<span class="hljs-comment">//获得底八位</span><br>tem=(<span class="hljs-type">float</span>)tem;<span class="hljs-comment">//转换</span><br></code></pre></td></tr></table></figure><p>这样从存储器读取一个十六位二进制数，然后转到了 u32 float，32位单精度浮点数。之后如果和double、int之类的做运算，是不是都要先把两边转成float，例如：</p><p>float f &#x3D; 3.4 这样就是double3.4 应该写成： float f &#x3D; (float)3.4或者写成 float f &#x3D; 3.4f，总之标准差计算过程还需要进一步完善。</p><p>四分位数法：<br>四分位数一（Q1）数据集前半部分的中位数<br>四分位数二（Q2）整体集的中位数<br>四分位数三（Q3）集后半部分的中位数<br>Q3-Q1计算四分位数Q4范围，Q4乘一个恒定值得到IQR(Interquartile Range)<br>然后有效数据的下限和上限就是[Q1−IQR,Q3+IQR] </p><p>使用四分位法不用计算标准不确定度，会比较快一些，但是因为有效范围是自定义的，就是说不想σ或者Grubbs法这样确定异常值的把握有多少（99.75%，比如）</p><hr><p>分度表更新，有两个问题：</p><p>一是选用何种数据结构存储分度表，二是如何改变本地存储，就是变了之后单片机reset一下数据不会复原。存flash感觉不太安全，所以存了sd卡。</p><p>至于分度表的数据结构，简单的两个数组我觉得是不合适的（虽然这最简单而且常用），考虑到分度表更新，数组的话更新限制太大，在一个位置插入T，就要在另一数组相同索引加入E，插入过程也就是后面挪一下，但是数据安全完全没有保障，就是说如果在更新的时候出了一些意外，比如insert(T,E）,T不小心输大十了十倍，存最后去了，那E是跟着T的索引还是自己再寻找插值地址?</p><p>如果是E跟着T索引，那要改正只能说在数组里进行delete(T)，删除，后面全部前移，再delete（E）,如果不想这么复杂，在插入的时候得加一个判断，判断E跟着T的插值地址，其插值表两边的值是否合适。 这使得更新的逻辑特别复杂。如果是E，T分布自己寻找插值地址更新，那就失去了单调检验的功能：输入的（E，10T）分别插值到不同的索引，那么也是得定向delete刚插入的，没有发现插入错误的话就得重新制表了，这非常的不合理。</p><p>更新困难只是一小部分，另一重要原因是：如果存储的数组被不小心错误更改（因为要提供更新表的功能所以肯定要做修改的接口），例如 E T 两个数组删了索引没对上的一组元素，那么整么表在某个索引后就是错误的了，而且这种情况也能通过顺序排列检查！</p><p>概括：把分布表做为两个数组结构不适合更新，其不仅跟新复杂，而且安全性没有保障。要保障安全、可靠，需要非常非常复杂的逻辑判断防止错误操作，注意事项太多，很容易出问题。</p><p>改进的方案，一是做一个struct结构、Binary Search Tree结构或者 Class:ThermocoupleData ，每个元素(节点)存两个float数据和指针。 如果是struct结构可以用指针数组指向n个struct，完成分度表建立；如果是二叉搜索树，直接用搜索树Class模板，然后改一下树节点状态即可。</p><p>用指针数组的好处是分度表在struct内严格一一对应，这样数据安全有了保障，无论如何不会出现错误对应的数据。而插入、删除、搜索的复杂度都是和数组类似的；用二叉树结构存储，看起来更厉害一些，而且插入、删除、搜索都可以在log(n)复杂度内实现，但是上面写了半天的向量插值搜索就白写了。而且一个麻烦是Class 是C++适应，转成C头文件也挺累的。</p><p>最后使用的数据结构方案是：用datastruct+指针vector 存储分度表。</p>]]></content>
    
    
    
    <tags>
      
      <tag>文献学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/08/06/hello-world/"/>
    <url>/2022/08/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><p>Hello,Wrold！这是我首次使用hexo搭建自己的个人博客，希望能在此记录技术的进步。本博客基于<a href="https://hexo.io/">Hexo</a>框架和<a href="https://hexo.fluid-dev.com/docs/guide">Fluid</a>主题，如果你也觉得很酷，可以根据教程搭建。 ^_^</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Some-error"><a href="#Some-error" class="headerlink" title="Some error"></a>Some error</h3><p>deploy时报错，可试试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br>$ hexo generate<br>$ hexo deploy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
